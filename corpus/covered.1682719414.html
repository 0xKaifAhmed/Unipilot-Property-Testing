<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/UnipilotActiveFactory.sol</b>
<code>
   1 | *r  | <span class='executed'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {UnipilotActiveVault} from &quot;./UnipilotActiveVault.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./interfaces/IUnipilotFactory.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./dependencies/interfaces/IUniswapV3Factory.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./dependencies/interfaces/IUniswapV3Pool.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/// @title Unipilot Active Factory</span>
  10 |     | <span class='neutral'>/// @author 0xMudassir &amp; 721Orbit</span>
  11 |     | <span class='neutral'>/// @notice Deploys Unipilot active vaults and manages ownership and control over all active vaults</span>
  12 |     | <span class='neutral'>/// active liquidity managament strategy will be used in these vaults</span>
  13 | *r  | <span class='executed'>/// all active vaults will be managed by Unipilot Captains</span>
  14 |     | <span class='neutral'>contract UnipilotActiveFactory is IUnipilotFactory {</span>
  15 |     | <span class='neutral'>    address private admin;</span>
  16 |     | <span class='neutral'>    address private strategy;</span>
  17 |     | <span class='neutral'>    address private indexFund;</span>
  18 |     | <span class='neutral'>    address private WETH;</span>
  19 |     | <span class='neutral'>    uint8 private swapPercentage;</span>
  20 |     | <span class='neutral'>    uint8 private indexFundPercentage;</span>
  21 |     | <span class='neutral'>    IUniswapV3Factory private uniswapFactory;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    constructor(</span>
  24 |     | <span class='neutral'>        address _uniswapFactory,</span>
  25 |     | <span class='neutral'>        address _admin,</span>
  26 |     | <span class='neutral'>        address _uniStrategy,</span>
  27 |     | <span class='neutral'>        address _indexFund,</span>
  28 |     | <span class='neutral'>        address _WETH,</span>
  29 |     | <span class='neutral'>        uint8 percentage</span>
  30 |     | <span class='neutral'>    ) {</span>
  31 |     | <span class='unexecuted'>        admin = _admin;</span>
  32 |     | <span class='unexecuted'>        strategy = _uniStrategy;</span>
  33 |     | <span class='unexecuted'>        uniswapFactory = IUniswapV3Factory(_uniswapFactory);</span>
  34 |     | <span class='unexecuted'>        indexFund = _indexFund;</span>
  35 |     | <span class='unexecuted'>        WETH = _WETH;</span>
  36 |     | <span class='unexecuted'>        indexFundPercentage = percentage;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 | *   | <span class='executed'>    mapping(address =&gt; mapping(address =&gt; mapping(uint24 =&gt; mapping(uint16 =&gt; address))))</span>
  40 |     | <span class='neutral'>        public vaults;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    modifier onlyadmin() {</span>
  43 | r   | <span class='reverted'>        require(msg.sender == admin);</span>
  44 |     | <span class='unexecuted'>        _;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @inheritdoc IUnipilotFactory</span>
  48 | *   | <span class='executed'>    function getUnipilotDetails()</span>
  49 |     | <span class='neutral'>        external</span>
  50 |     | <span class='neutral'>        view</span>
  51 |     | <span class='neutral'>        override</span>
  52 |     | <span class='neutral'>        returns (</span>
  53 | *   | <span class='executed'>            address,</span>
  54 | *   | <span class='executed'>            address,</span>
  55 | *   | <span class='executed'>            address,</span>
  56 | *   | <span class='executed'>            uint8,</span>
  57 | *   | <span class='executed'>            uint8</span>
  58 |     | <span class='neutral'>        )</span>
  59 |     | <span class='neutral'>    {</span>
  60 | *   | <span class='executed'>        return (</span>
  61 | *   | <span class='executed'>            admin,</span>
  62 | *   | <span class='executed'>            strategy,</span>
  63 | *   | <span class='executed'>            indexFund,</span>
  64 | *   | <span class='executed'>            indexFundPercentage,</span>
  65 | *   | <span class='executed'>            swapPercentage</span>
  66 |     | <span class='neutral'>        );</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /// @inheritdoc IUnipilotFactory</span>
  70 | r   | <span class='reverted'>    function createVault(</span>
  71 |     | <span class='neutral'>        address _tokenA,</span>
  72 |     | <span class='neutral'>        address _tokenB,</span>
  73 |     | <span class='neutral'>        uint24 _fee,</span>
  74 |     | <span class='neutral'>        uint16 _vaultStrategy,</span>
  75 |     | <span class='neutral'>        uint160 _sqrtPriceX96,</span>
  76 |     | <span class='neutral'>        string memory _name,</span>
  77 |     | <span class='neutral'>        string memory _symbol</span>
  78 | r   | <span class='reverted'>    ) external override onlyadmin returns (address _vault) {</span>
  79 | r   | <span class='reverted'>        require(_tokenA != _tokenB);</span>
  80 |     | <span class='neutral'></span>
  81 | r   | <span class='reverted'>        (address token0, address token1) = _tokenA &lt; _tokenB</span>
  82 |     | <span class='unexecuted'>            ? (_tokenA, _tokenB)</span>
  83 | r   | <span class='reverted'>            : (_tokenB, _tokenA);</span>
  84 |     | <span class='neutral'></span>
  85 | r   | <span class='reverted'>        address pool = uniswapFactory.getPool(token0, token1, _fee);</span>
  86 |     | <span class='neutral'></span>
  87 | r   | <span class='reverted'>        if (pool != address(0)) {</span>
  88 |     | <span class='unexecuted'>            require(vaults[token0][token1][_fee][0] == address(0));</span>
  89 |     | <span class='neutral'>        } else {</span>
  90 | r   | <span class='reverted'>            pool = uniswapFactory.createPool(token0, token1, _fee);</span>
  91 |     | <span class='unexecuted'>            IUniswapV3Pool(pool).initialize(_sqrtPriceX96);</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        _vault = address(</span>
  95 |     | <span class='unexecuted'>            new UnipilotActiveVault{</span>
  96 |     | <span class='unexecuted'>                salt: keccak256(abi.encodePacked(_tokenA, _tokenB, _fee))</span>
  97 |     | <span class='unexecuted'>            }(pool, address(this), WETH, _vaultStrategy, _name, _symbol)</span>
  98 |     | <span class='neutral'>        );</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        vaults[token0][token1][_fee][_vaultStrategy] = _vault;</span>
 101 |     | <span class='unexecuted'>        vaults[token1][token0][_fee][_vaultStrategy] = _vault; // populate mapping in the reverse direction</span>
 102 |     | <span class='unexecuted'>        emit VaultCreated(token0, token1, _vaultStrategy, _fee, _vault);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /// @notice Updates the admin of the Unipilot factory</span>
 106 |     | <span class='neutral'>    /// @dev Must be called by the current admin</span>
 107 |     | <span class='neutral'>    /// @param _newadmin The new admin of the Unipilot factory</span>
 108 | r   | <span class='reverted'>    function setadmin(address _newadmin) external onlyadmin {</span>
 109 |     | <span class='unexecuted'>        require(_newadmin != address(0));</span>
 110 |     | <span class='neutral'>       // emit adminChanged(admin, _newadmin);</span>
 111 |     | <span class='unexecuted'>        admin = _newadmin;</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /// @notice Updates all the necessary Unipilot details used in active vaults</span>
 115 |     | <span class='neutral'>    /// @dev Must be called by the current admin</span>
 116 |     | <span class='neutral'>    /// @param _strategy Unipilot strategy address</span>
 117 |     | <span class='neutral'>    /// @param _indexFund Unipilot index fund account</span>
 118 |     | <span class='neutral'>    /// @param _indexFundPercentage Percentage of fees for index fund</span>
 119 | r   | <span class='reverted'>    function setUnipilotDetails(</span>
 120 |     | <span class='neutral'>        address _strategy,</span>
 121 |     | <span class='neutral'>        address _indexFund,</span>
 122 |     | <span class='neutral'>        uint8 _indexFundPercentage</span>
 123 |     | <span class='neutral'>    ) external onlyadmin {</span>
 124 |     | <span class='unexecuted'>        require(_indexFundPercentage &gt; 0 &amp;&amp; _indexFundPercentage &lt; 100);</span>
 125 |     | <span class='unexecuted'>        strategy = _strategy;</span>
 126 |     | <span class='unexecuted'>        indexFund = _indexFund;</span>
 127 |     | <span class='unexecuted'>        indexFundPercentage = _indexFundPercentage;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'>}</span>
 130 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/UnipilotActiveVault.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.7.6;</span>
   3 |     | <span class='neutral'>pragma abicoder v2;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {ERC20Permit, IERC20, ERC20, TransferHelper} from &quot;./libraries/TransferHelper.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./interfaces/external/IWETH9.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./interfaces/IUnipilotVault.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./interfaces/IUnipilotStrategy.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./interfaces/IUnipilotFactory.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./libraries/UniswapLiquidityManagement.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./libraries/SafeCastExtended.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;./libraries/UniswapPoolActions.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/// @title Unipilot Active Vault</span>
  15 |     | <span class='neutral'>/// @author 0xMudassir &amp; 721Orbit</span>
  16 |     | <span class='neutral'>/// @dev Active liquidity managment contract that handles user liquidity of any Uniswap V3 pool &amp; earn fees for them</span>
  17 |     | <span class='neutral'>/// @dev minimalist, and gas-optimized contract that ensures user liquidity is always</span>
  18 |     | <span class='neutral'>/// in range and earns maximum amount of fees available at current liquidity utilization</span>
  19 |     | <span class='neutral'>/// rate.</span>
  20 |     | <span class='unexecuted'>/// @dev In order to minimize IL for users contract pulls liquidity to the vault (HODL) when necessary</span>
  21 |     | <span class='neutral'>contract UnipilotActiveVault is ERC20Permit, IUnipilotVault {</span>
  22 |     | <span class='neutral'>    using SafeCastExtended for uint256;</span>
  23 |     | <span class='neutral'>    using LowGasSafeMath for uint256;</span>
  24 |     | <span class='neutral'>    using UniswapPoolActions for IUniswapV3Pool;</span>
  25 |     | <span class='neutral'>    using UniswapLiquidityManagement for IUniswapV3Pool;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    IERC20 private token0;</span>
  28 |     | <span class='neutral'>    IERC20 private token1;</span>
  29 |     | <span class='neutral'>    uint24 private fee;</span>
  30 |     | <span class='neutral'>    int24 private tickSpacing;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    TicksData public ticksData;</span>
  33 |     | <span class='neutral'>    IUniswapV3Pool private pool;</span>
  34 |     | <span class='neutral'>    IUnipilotFactory private unipilotFactory;</span>
  35 |     | <span class='unexecuted'>    uint256 internal constant MIN_INITIAL_SHARES = 1e3;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    address private WETH;</span>
  38 |     | <span class='neutral'>    uint16 private _strategyType;</span>
  39 |     | <span class='unexecuted'>    uint32 private _pulled = 1;</span>
  40 |     | <span class='unexecuted'>    uint32 private _unlocked = 1;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    mapping(address =&gt; bool) private _operatorApproved;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    modifier onlyGovernance() {</span>
  45 |     | <span class='unexecuted'>        (address governance, , , , ) = getProtocolDetails();</span>
  46 |     | <span class='unexecuted'>        require(msg.sender == governance);</span>
  47 |     | <span class='neutral'>        _;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    modifier onlyOperator() {</span>
  51 |     | <span class='unexecuted'>        require(_operatorApproved[msg.sender]);</span>
  52 |     | <span class='unexecuted'>        _;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    modifier nonReentrant() {</span>
  56 |     | <span class='unexecuted'>        require(_unlocked == 1);</span>
  57 |     | <span class='unexecuted'>        _unlocked = 2;</span>
  58 |     | <span class='unexecuted'>        _;</span>
  59 |     | <span class='unexecuted'>        _unlocked = 1;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    modifier checkDeviation() {</span>
  63 |     | <span class='unexecuted'>        (, address strategy, , , ) = getProtocolDetails();</span>
  64 |     | <span class='unexecuted'>        IUnipilotStrategy(strategy).checkDeviation(address(pool));</span>
  65 |     | <span class='unexecuted'>        _;</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    constructor(</span>
  69 |     | <span class='neutral'>        address _pool,</span>
  70 |     | <span class='neutral'>        address _unipilotFactory,</span>
  71 |     | <span class='neutral'>        address _WETH,</span>
  72 |     | <span class='neutral'>        uint16 _strategytype,</span>
  73 |     | <span class='neutral'>        string memory _name,</span>
  74 |     | <span class='neutral'>        string memory _symbol</span>
  75 |     | <span class='unexecuted'>    ) ERC20Permit(_name) ERC20(_name, _symbol) {</span>
  76 |     | <span class='unexecuted'>        require(_pool != address(0));</span>
  77 |     | <span class='unexecuted'>        require(_WETH != address(0));</span>
  78 |     | <span class='unexecuted'>        require(_unipilotFactory != address(0));</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        pool = IUniswapV3Pool(_pool);</span>
  81 |     | <span class='unexecuted'>        unipilotFactory = IUnipilotFactory(_unipilotFactory);</span>
  82 |     | <span class='unexecuted'>        WETH = _WETH;</span>
  83 |     | <span class='unexecuted'>        token0 = IERC20(pool.token0());</span>
  84 |     | <span class='unexecuted'>        token1 = IERC20(pool.token1());</span>
  85 |     | <span class='unexecuted'>        fee = pool.fee();</span>
  86 |     | <span class='unexecuted'>        tickSpacing = pool.tickSpacing();</span>
  87 |     | <span class='unexecuted'>        _strategyType = _strategytype;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    receive() external payable {}</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    fallback() external payable {}</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /// @inheritdoc IUnipilotVault</span>
  95 |     | <span class='unexecuted'>    function deposit(</span>
  96 |     | <span class='neutral'>        uint256 amount0Desired,</span>
  97 |     | <span class='neutral'>        uint256 amount1Desired,</span>
  98 |     | <span class='neutral'>        address recipient</span>
  99 |     | <span class='neutral'>    )</span>
 100 |     | <span class='neutral'>        external</span>
 101 |     | <span class='neutral'>        payable</span>
 102 |     | <span class='neutral'>        override</span>
 103 |     | <span class='neutral'>        nonReentrant</span>
 104 |     | <span class='neutral'>        checkDeviation</span>
 105 |     | <span class='neutral'>        returns (</span>
 106 |     | <span class='unexecuted'>            uint256 lpShares,</span>
 107 |     | <span class='unexecuted'>            uint256 amount0,</span>
 108 |     | <span class='unexecuted'>            uint256 amount1</span>
 109 |     | <span class='neutral'>        )</span>
 110 |     | <span class='neutral'>    {</span>
 111 |     | <span class='unexecuted'>        require(recipient != address(0));</span>
 112 |     | <span class='unexecuted'>        require(amount0Desired &gt; 0 &amp;&amp; amount1Desired &gt; 0);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        address sender = _msgSender();</span>
 115 |     | <span class='unexecuted'>        uint256 totalSupply = totalSupply();</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        (lpShares, amount0, amount1) = pool.computeLpShares(</span>
 118 |     | <span class='unexecuted'>            true,</span>
 119 |     | <span class='unexecuted'>            amount0Desired,</span>
 120 |     | <span class='unexecuted'>            amount1Desired,</span>
 121 |     | <span class='unexecuted'>            _balance0(),</span>
 122 |     | <span class='unexecuted'>            _balance1(),</span>
 123 |     | <span class='unexecuted'>            totalSupply,</span>
 124 |     | <span class='unexecuted'>            ticksData</span>
 125 |     | <span class='neutral'>        );</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        if (totalSupply == 0) {</span>
 128 |     | <span class='neutral'>            // prevent first LP from stealing funds of subsequent LPs</span>
 129 |     | <span class='neutral'>            // see https://code4rena.com/reports/2022-01-sherlock/#h-01-first-user-can-steal-everyone-elses-tokens</span>
 130 |     | <span class='unexecuted'>            require(lpShares &gt; MIN_INITIAL_SHARES, &quot;ML&quot;);</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>        require(lpShares != 0, &quot;IS&quot;);</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>        pay(address(token0), sender, address(this), amount0);</span>
 136 |     | <span class='unexecuted'>        pay(address(token1), sender, address(this), amount1);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        if (_pulled == 1) {</span>
 139 |     | <span class='unexecuted'>            pool.mintLiquidity(</span>
 140 |     | <span class='unexecuted'>                ticksData.baseTickLower,</span>
 141 |     | <span class='unexecuted'>                ticksData.baseTickUpper,</span>
 142 |     | <span class='unexecuted'>                amount0,</span>
 143 |     | <span class='unexecuted'>                amount1</span>
 144 |     | <span class='neutral'>            );</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>        if (address(this).balance &gt; 0)</span>
 148 |     | <span class='unexecuted'>            TransferHelper.safeTransferETH(sender, address(this).balance);</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>        _mint(recipient, lpShares);</span>
 151 |     | <span class='unexecuted'>        emit Deposit(sender, recipient, amount0, amount1, lpShares);</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    /// @inheritdoc IUnipilotVault</span>
 155 |     | <span class='unexecuted'>    function withdraw(</span>
 156 |     | <span class='neutral'>        uint256 liquidity,</span>
 157 |     | <span class='neutral'>        address recipient,</span>
 158 |     | <span class='neutral'>        bool refundAsETH</span>
 159 |     | <span class='neutral'>    )</span>
 160 |     | <span class='neutral'>        external</span>
 161 |     | <span class='neutral'>        override</span>
 162 |     | <span class='neutral'>        nonReentrant</span>
 163 |     | <span class='neutral'>        checkDeviation</span>
 164 |     | <span class='unexecuted'>        returns (uint256 amount0, uint256 amount1)</span>
 165 |     | <span class='neutral'>    {</span>
 166 |     | <span class='unexecuted'>        require(liquidity &gt; 0);</span>
 167 |     | <span class='unexecuted'>        uint256 totalSupply = totalSupply();</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>        /// @dev if liquidity has pulled in contract then calculate share accordingly</span>
 170 |     | <span class='unexecuted'>        if (_pulled == 1) {</span>
 171 |     | <span class='unexecuted'>            uint256 liquidityShare = FullMath.mulDiv(</span>
 172 |     | <span class='unexecuted'>                liquidity,</span>
 173 |     | <span class='unexecuted'>                1e18,</span>
 174 |     | <span class='unexecuted'>                totalSupply</span>
 175 |     | <span class='neutral'>            );</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>            (amount0, amount1) = pool.burnUserLiquidity(</span>
 178 |     | <span class='unexecuted'>                ticksData.baseTickLower,</span>
 179 |     | <span class='unexecuted'>                ticksData.baseTickUpper,</span>
 180 |     | <span class='unexecuted'>                liquidityShare,</span>
 181 |     | <span class='unexecuted'>                address(this)</span>
 182 |     | <span class='neutral'>            );</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='unexecuted'>            (uint256 fees0, uint256 fees1) = pool.collectPendingFees(</span>
 185 |     | <span class='unexecuted'>                address(this),</span>
 186 |     | <span class='unexecuted'>                ticksData.baseTickLower,</span>
 187 |     | <span class='unexecuted'>                ticksData.baseTickUpper</span>
 188 |     | <span class='neutral'>            );</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>            transferFeesToIF(false, fees0, fees1);</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>        uint256 unusedAmount0 = FullMath.mulDiv(</span>
 194 |     | <span class='unexecuted'>            _balance0().sub(amount0),</span>
 195 |     | <span class='unexecuted'>            liquidity,</span>
 196 |     | <span class='unexecuted'>            totalSupply</span>
 197 |     | <span class='neutral'>        );</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='unexecuted'>        uint256 unusedAmount1 = FullMath.mulDiv(</span>
 200 |     | <span class='unexecuted'>            _balance1().sub(amount1),</span>
 201 |     | <span class='unexecuted'>            liquidity,</span>
 202 |     | <span class='unexecuted'>            totalSupply</span>
 203 |     | <span class='neutral'>        );</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        amount0 = amount0.add(unusedAmount0);</span>
 206 |     | <span class='unexecuted'>        amount1 = amount1.add(unusedAmount1);</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
 209 |     | <span class='unexecuted'>            transferFunds(refundAsETH, recipient, address(token0), amount0);</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
 213 |     | <span class='unexecuted'>            transferFunds(refundAsETH, recipient, address(token1), amount1);</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>        _burn(msg.sender, liquidity);</span>
 217 |     | <span class='unexecuted'>        emit Withdraw(recipient, liquidity, amount0, amount1);</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>        if (_pulled == 1) {</span>
 220 |     | <span class='unexecuted'>            (uint256 c0, uint256 c1) = pool.mintLiquidity(</span>
 221 |     | <span class='unexecuted'>                ticksData.baseTickLower,</span>
 222 |     | <span class='unexecuted'>                ticksData.baseTickUpper,</span>
 223 |     | <span class='unexecuted'>                _balance0(),</span>
 224 |     | <span class='unexecuted'>                _balance1()</span>
 225 |     | <span class='neutral'>            );</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='unexecuted'>            emit CompoundFees(c0, c1);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    /// @inheritdoc IUnipilotVault</span>
 232 |     | <span class='unexecuted'>    function readjustLiquidity(uint8 swapBP)</span>
 233 |     | <span class='neutral'>        external</span>
 234 |     | <span class='neutral'>        override</span>
 235 |     | <span class='neutral'>        onlyOperator</span>
 236 |     | <span class='neutral'>        checkDeviation</span>
 237 |     | <span class='neutral'>    {</span>
 238 |     | <span class='unexecuted'>        _pulled = 1;</span>
 239 |     | <span class='unexecuted'>        ReadjustVars memory a;</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='unexecuted'>        (uint128 totalLiquidity, , ) = pool.getPositionLiquidity(</span>
 242 |     | <span class='unexecuted'>            ticksData.baseTickLower,</span>
 243 |     | <span class='unexecuted'>            ticksData.baseTickUpper</span>
 244 |     | <span class='neutral'>        );</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='unexecuted'>        (a.amount0Desired, a.amount1Desired, a.fees0, a.fees1) = pool</span>
 247 |     | <span class='neutral'>            .burnLiquidity(</span>
 248 |     | <span class='unexecuted'>                ticksData.baseTickLower,</span>
 249 |     | <span class='unexecuted'>                ticksData.baseTickUpper,</span>
 250 |     | <span class='unexecuted'>                address(this)</span>
 251 |     | <span class='neutral'>            );</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='unexecuted'>        transferFeesToIF(true, a.fees0, a.fees1);</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>        int24 baseThreshold = tickSpacing * getBaseThreshold();</span>
 256 |     | <span class='unexecuted'>        (, a.currentTick, ) = pool.getSqrtRatioX96AndTick();</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='unexecuted'>        (a.tickLower, a.tickUpper) = UniswapLiquidityManagement.getBaseTicks(</span>
 259 |     | <span class='unexecuted'>            a.currentTick,</span>
 260 |     | <span class='unexecuted'>            baseThreshold,</span>
 261 |     | <span class='unexecuted'>            tickSpacing</span>
 262 |     | <span class='neutral'>        );</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>        if (</span>
 265 |     | <span class='unexecuted'>            (totalLiquidity &gt; 0) &amp;&amp;</span>
 266 |     | <span class='unexecuted'>            (a.amount0Desired == 0 || a.amount1Desired == 0)</span>
 267 |     | <span class='neutral'>        ) {</span>
 268 |     | <span class='unexecuted'>            bool zeroForOne = a.amount0Desired &gt; 0 ? true : false;</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>            int256 amountSpecified = zeroForOne</span>
 271 |     | <span class='unexecuted'>                ? FullMath.mulDiv(a.amount0Desired, swapBP, 100).toInt256()</span>
 272 |     | <span class='unexecuted'>                : FullMath.mulDiv(a.amount1Desired, swapBP, 100).toInt256();</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>            pool.swapToken(address(this), zeroForOne, amountSpecified);</span>
 275 |     | <span class='neutral'>        } else {</span>
 276 |     | <span class='unexecuted'>            a.amount0Desired = _balance0();</span>
 277 |     | <span class='unexecuted'>            a.amount1Desired = _balance1();</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='unexecuted'>            a.liquidity = pool.getLiquidityForAmounts(</span>
 280 |     | <span class='unexecuted'>                a.amount0Desired,</span>
 281 |     | <span class='unexecuted'>                a.amount1Desired,</span>
 282 |     | <span class='unexecuted'>                a.tickLower,</span>
 283 |     | <span class='unexecuted'>                a.tickUpper</span>
 284 |     | <span class='neutral'>            );</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='unexecuted'>            (a.amount0, a.amount1) = pool.getAmountsForLiquidity(</span>
 287 |     | <span class='unexecuted'>                a.liquidity,</span>
 288 |     | <span class='unexecuted'>                a.tickLower,</span>
 289 |     | <span class='unexecuted'>                a.tickUpper</span>
 290 |     | <span class='neutral'>            );</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>            a.zeroForOne = UniswapLiquidityManagement.amountsDirection(</span>
 293 |     | <span class='unexecuted'>                a.amount0Desired,</span>
 294 |     | <span class='unexecuted'>                a.amount1Desired,</span>
 295 |     | <span class='unexecuted'>                a.amount0,</span>
 296 |     | <span class='unexecuted'>                a.amount1</span>
 297 |     | <span class='neutral'>            );</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='unexecuted'>            a.amountSpecified = a.zeroForOne</span>
 300 |     | <span class='neutral'>                ? int256(</span>
 301 |     | <span class='unexecuted'>                    FullMath.mulDiv(</span>
 302 |     | <span class='unexecuted'>                        a.amount0Desired.sub(a.amount0),</span>
 303 |     | <span class='unexecuted'>                        swapBP,</span>
 304 |     | <span class='unexecuted'>                        100</span>
 305 |     | <span class='neutral'>                    )</span>
 306 |     | <span class='neutral'>                )</span>
 307 |     | <span class='neutral'>                : int256(</span>
 308 |     | <span class='unexecuted'>                    FullMath.mulDiv(</span>
 309 |     | <span class='unexecuted'>                        a.amount1Desired.sub(a.amount1),</span>
 310 |     | <span class='unexecuted'>                        swapBP,</span>
 311 |     | <span class='unexecuted'>                        100</span>
 312 |     | <span class='neutral'>                    )</span>
 313 |     | <span class='neutral'>                );</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='unexecuted'>            pool.swapToken(address(this), a.zeroForOne, a.amountSpecified);</span>
 316 |     | <span class='neutral'>        }</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='unexecuted'>        a.amount0Desired = _balance0();</span>
 319 |     | <span class='unexecuted'>        a.amount1Desired = _balance1();</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>        (ticksData.baseTickLower, ticksData.baseTickUpper) = pool</span>
 322 |     | <span class='neutral'>            .getPositionTicks(</span>
 323 |     | <span class='unexecuted'>                a.amount0Desired,</span>
 324 |     | <span class='unexecuted'>                a.amount1Desired,</span>
 325 |     | <span class='unexecuted'>                baseThreshold,</span>
 326 |     | <span class='unexecuted'>                tickSpacing</span>
 327 |     | <span class='neutral'>            );</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='unexecuted'>        pool.mintLiquidity(</span>
 330 |     | <span class='unexecuted'>            ticksData.baseTickLower,</span>
 331 |     | <span class='unexecuted'>            ticksData.baseTickUpper,</span>
 332 |     | <span class='unexecuted'>            a.amount0Desired,</span>
 333 |     | <span class='unexecuted'>            a.amount1Desired</span>
 334 |     | <span class='neutral'>        );</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>    function rebalance(</span>
 338 |     | <span class='neutral'>        int256 swapAmount,</span>
 339 |     | <span class='neutral'>        bool zeroForOne,</span>
 340 |     | <span class='neutral'>        int24 tickLower,</span>
 341 |     | <span class='neutral'>        int24 tickUpper</span>
 342 |     | <span class='neutral'>    ) external onlyOperator checkDeviation {</span>
 343 |     | <span class='unexecuted'>        _pulled = 1;</span>
 344 |     | <span class='unexecuted'>        UniswapLiquidityManagement.checkRange(</span>
 345 |     | <span class='unexecuted'>            tickLower,</span>
 346 |     | <span class='unexecuted'>            tickUpper,</span>
 347 |     | <span class='unexecuted'>            tickSpacing</span>
 348 |     | <span class='neutral'>        );</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>        // Withdraw all current liquidity from Uniswap pool &amp; transfer fees</span>
 351 |     | <span class='unexecuted'>        (, , uint256 fees0, uint256 fees1) = pool.burnLiquidity(</span>
 352 |     | <span class='unexecuted'>            ticksData.baseTickLower,</span>
 353 |     | <span class='unexecuted'>            ticksData.baseTickUpper,</span>
 354 |     | <span class='unexecuted'>            address(this)</span>
 355 |     | <span class='neutral'>        );</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='unexecuted'>        transferFeesToIF(true, fees0, fees1);</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='unexecuted'>        if (swapAmount != 0)</span>
 360 |     | <span class='unexecuted'>            pool.swapToken(address(this), zeroForOne, swapAmount);</span>
 361 |     | <span class='neutral'></span>
 362 |     | <span class='unexecuted'>        pool.mintLiquidity(tickLower, tickUpper, _balance0(), _balance1());</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='unexecuted'>        (ticksData.baseTickLower, ticksData.baseTickUpper) = (</span>
 365 |     | <span class='unexecuted'>            tickLower,</span>
 366 |     | <span class='unexecuted'>            tickUpper</span>
 367 |     | <span class='neutral'>        );</span>
 368 |     | <span class='neutral'>    }</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>    /// @inheritdoc IUnipilotVault</span>
 371 |     | <span class='unexecuted'>    function uniswapV3MintCallback(</span>
 372 |     | <span class='neutral'>        uint256 amount0Owed,</span>
 373 |     | <span class='neutral'>        uint256 amount1Owed,</span>
 374 |     | <span class='neutral'>        bytes calldata data</span>
 375 |     | <span class='neutral'>    ) external override {</span>
 376 |     | <span class='unexecuted'>        _verifyCallback();</span>
 377 |     | <span class='unexecuted'>        address recipient = _msgSender();</span>
 378 |     | <span class='unexecuted'>        address payer = abi.decode(data, (address));</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='unexecuted'>        if (amount0Owed &gt; 0)</span>
 381 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(</span>
 382 |     | <span class='unexecuted'>                address(token0),</span>
 383 |     | <span class='unexecuted'>                recipient,</span>
 384 |     | <span class='unexecuted'>                amount0Owed</span>
 385 |     | <span class='neutral'>            );</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='unexecuted'>        if (amount1Owed &gt; 0)</span>
 388 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(</span>
 389 |     | <span class='unexecuted'>                address(token1),</span>
 390 |     | <span class='unexecuted'>                recipient,</span>
 391 |     | <span class='unexecuted'>                amount1Owed</span>
 392 |     | <span class='neutral'>            );</span>
 393 |     | <span class='neutral'>    }</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='neutral'>    /// @inheritdoc IUnipilotVault</span>
 396 |     | <span class='unexecuted'>    function uniswapV3SwapCallback(</span>
 397 |     | <span class='neutral'>        int256 amount0,</span>
 398 |     | <span class='neutral'>        int256 amount1,</span>
 399 |     | <span class='neutral'>        bytes calldata data</span>
 400 |     | <span class='neutral'>    ) external override {</span>
 401 |     | <span class='unexecuted'>        _verifyCallback();</span>
 402 |     | <span class='neutral'></span>
 403 |     | <span class='unexecuted'>        require(amount0 &gt; 0 || amount1 &gt; 0);</span>
 404 |     | <span class='unexecuted'>        bool zeroForOne = abi.decode(data, (bool));</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='unexecuted'>        if (zeroForOne)</span>
 407 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(</span>
 408 |     | <span class='unexecuted'>                address(token0),</span>
 409 |     | <span class='unexecuted'>                _msgSender(),</span>
 410 |     | <span class='unexecuted'>                uint256(amount0)</span>
 411 |     | <span class='neutral'>            );</span>
 412 |     | <span class='neutral'>        else</span>
 413 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(</span>
 414 |     | <span class='unexecuted'>                address(token1),</span>
 415 |     | <span class='unexecuted'>                _msgSender(),</span>
 416 |     | <span class='unexecuted'>                uint256(amount1)</span>
 417 |     | <span class='neutral'>            );</span>
 418 |     | <span class='neutral'>    }</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='neutral'>    /// @dev Burns all the Unipilot position and HODL in the vault to prevent users from huge IL</span>
 421 |     | <span class='neutral'>    /// Only called by the selected operators</span>
 422 |     | <span class='neutral'>    /// @dev Users can also deposit/withdraw during HODL period.</span>
 423 |     | <span class='unexecuted'>    function pullLiquidity() external onlyOperator {</span>
 424 |     | <span class='unexecuted'>        (</span>
 425 |     | <span class='unexecuted'>            uint256 reserves0,</span>
 426 |     | <span class='unexecuted'>            uint256 reserves1,</span>
 427 |     | <span class='unexecuted'>            uint256 fees0,</span>
 428 |     | <span class='unexecuted'>            uint256 fees1</span>
 429 |     | <span class='unexecuted'>        ) = pool.burnLiquidity(</span>
 430 |     | <span class='unexecuted'>                ticksData.baseTickLower,</span>
 431 |     | <span class='unexecuted'>                ticksData.baseTickUpper,</span>
 432 |     | <span class='unexecuted'>                address(this)</span>
 433 |     | <span class='neutral'>            );</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='unexecuted'>        _pulled = 2;</span>
 436 |     | <span class='unexecuted'>        emit PullLiquidity(reserves0, reserves1, fees0, fees1);</span>
 437 |     | <span class='neutral'>    }</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>    /// @notice Calculates the vault&#39;s total holdings of TOKEN0 and TOKEN1 - in</span>
 440 |     | <span class='neutral'>    /// other words, how much of each token the vault would hold if it withdrew</span>
 441 |     | <span class='neutral'>    /// all its liquidity from Uniswap.</span>
 442 |     | <span class='neutral'>    /// @dev Updates the position and return the updated reserves, fees &amp; liquidity.</span>
 443 |     | <span class='neutral'>    /// @return amount0 Amount of token0 in the unipilot vault</span>
 444 |     | <span class='neutral'>    /// @return amount1 Amount of token1 in the unipilot vault</span>
 445 |     | <span class='neutral'>    /// @return fees0 Total amount of fees collected by unipilot position in terms of token0</span>
 446 |     | <span class='neutral'>    /// @return fees1 Total amount of fees collected by unipilot position in terms of token1</span>
 447 |     | <span class='neutral'>    /// @return baseLiquidity The total liquidity of the base position</span>
 448 |     | <span class='neutral'>    /// @return rangeLiquidity The total liquidity of the range position - N/A for active vault</span>
 449 |     | <span class='unexecuted'>    function getPositionDetails()</span>
 450 |     | <span class='neutral'>        external</span>
 451 |     | <span class='neutral'>        returns (</span>
 452 |     | <span class='unexecuted'>            uint256 amount0,</span>
 453 |     | <span class='unexecuted'>            uint256 amount1,</span>
 454 |     | <span class='unexecuted'>            uint256 fees0,</span>
 455 |     | <span class='unexecuted'>            uint256 fees1,</span>
 456 |     | <span class='unexecuted'>            uint128 baseLiquidity,</span>
 457 |     | <span class='unexecuted'>            uint128 rangeLiquidity</span>
 458 |     | <span class='neutral'>        )</span>
 459 |     | <span class='neutral'>    {</span>
 460 |     | <span class='unexecuted'>        return pool.getTotalAmounts(true, ticksData);</span>
 461 |     | <span class='neutral'>    }</span>
 462 |     | <span class='neutral'></span>
 463 |     | <span class='neutral'>    /// @notice Updates the status of given account as operator</span>
 464 |     | <span class='neutral'>    /// @dev Must be called by the current governance</span>
 465 |     | <span class='neutral'>    /// @param _operator Account to update status</span>
 466 |     | <span class='unexecuted'>    function toggleOperator(address _operator) external onlyGovernance {</span>
 467 |     | <span class='unexecuted'>        _operatorApproved[_operator] = !_operatorApproved[_operator];</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>    /// @notice Returns the status for a given operator that can operate readjust &amp; pull liquidity</span>
 471 |     | <span class='unexecuted'>    function isOperator(address _operator) external view returns (bool) {</span>
 472 |     | <span class='unexecuted'>        return _operatorApproved[_operator];</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>    /// @notice Returns unipilot vault details</span>
 476 |     | <span class='neutral'>    /// @return The first of the two tokens of the pool, sorted by address</span>
 477 |     | <span class='neutral'>    /// @return The second of the two tokens of the pool, sorted by address</span>
 478 |     | <span class='neutral'>    /// @return The pool&#39;s fee in hundredths of a bip, i.e. 1e-6</span>
 479 |     | <span class='neutral'>    /// @return The address of the Uniswap V3 Pool</span>
 480 |     | <span class='unexecuted'>    function getVaultInfo()</span>
 481 |     | <span class='neutral'>        external</span>
 482 |     | <span class='neutral'>        view</span>
 483 |     | <span class='neutral'>        returns (</span>
 484 |     | <span class='unexecuted'>            address,</span>
 485 |     | <span class='unexecuted'>            address,</span>
 486 |     | <span class='unexecuted'>            uint24,</span>
 487 |     | <span class='unexecuted'>            address</span>
 488 |     | <span class='neutral'>        )</span>
 489 |     | <span class='neutral'>    {</span>
 490 |     | <span class='unexecuted'>        return (address(token0), address(token1), fee, address(pool));</span>
 491 |     | <span class='neutral'>    }</span>
 492 |     | <span class='neutral'></span>
 493 |     | <span class='neutral'>    /// @dev Amount of token0 held as unused balance.</span>
 494 |     | <span class='unexecuted'>    function _balance0() internal view returns (uint256) {</span>
 495 |     | <span class='unexecuted'>        return token0.balanceOf(address(this));</span>
 496 |     | <span class='neutral'>    }</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='neutral'>    /// @dev Amount of token1 held as unused balance.</span>
 499 |     | <span class='unexecuted'>    function _balance1() internal view returns (uint256) {</span>
 500 |     | <span class='unexecuted'>        return token1.balanceOf(address(this));</span>
 501 |     | <span class='neutral'>    }</span>
 502 |     | <span class='neutral'></span>
 503 |     | <span class='neutral'>    /// @notice Verify that caller should be the address of a valid Uniswap V3 Pool</span>
 504 |     | <span class='unexecuted'>    function _verifyCallback() internal view {</span>
 505 |     | <span class='unexecuted'>        require(msg.sender == address(pool));</span>
 506 |     | <span class='neutral'>    }</span>
 507 |     | <span class='neutral'></span>
 508 |     | <span class='unexecuted'>    function getBaseThreshold() internal view returns (int24 baseThreshold) {</span>
 509 |     | <span class='unexecuted'>        (, address strategy, , , ) = getProtocolDetails();</span>
 510 |     | <span class='unexecuted'>        return</span>
 511 |     | <span class='unexecuted'>            IUnipilotStrategy(strategy).getBaseThreshold(</span>
 512 |     | <span class='unexecuted'>                address(pool),</span>
 513 |     | <span class='unexecuted'>                _strategyType</span>
 514 |     | <span class='neutral'>            );</span>
 515 |     | <span class='neutral'>    }</span>
 516 |     | <span class='neutral'></span>
 517 |     | <span class='unexecuted'>    function getProtocolDetails()</span>
 518 |     | <span class='neutral'>        internal</span>
 519 |     | <span class='neutral'>        view</span>
 520 |     | <span class='neutral'>        returns (</span>
 521 |     | <span class='unexecuted'>            address governance,</span>
 522 |     | <span class='unexecuted'>            address strategy,</span>
 523 |     | <span class='unexecuted'>            address indexFund,</span>
 524 |     | <span class='unexecuted'>            uint8 indexFundPercentage,</span>
 525 |     | <span class='unexecuted'>            uint8 swapPercentage</span>
 526 |     | <span class='neutral'>        )</span>
 527 |     | <span class='neutral'>    {</span>
 528 |     | <span class='unexecuted'>        return unipilotFactory.getUnipilotDetails();</span>
 529 |     | <span class='neutral'>    }</span>
 530 |     | <span class='neutral'></span>
 531 |     | <span class='neutral'>    /// @dev method to transfer unipilot earned fees to Index Fund</span>
 532 |     | <span class='unexecuted'>    function transferFeesToIF(</span>
 533 |     | <span class='neutral'>        bool isReadjustLiquidity,</span>
 534 |     | <span class='neutral'>        uint256 fees0,</span>
 535 |     | <span class='neutral'>        uint256 fees1</span>
 536 |     | <span class='neutral'>    ) internal {</span>
 537 |     | <span class='unexecuted'>        (, , address indexFund, uint8 percentage, ) = getProtocolDetails();</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='unexecuted'>        if (percentage &gt; 0) {</span>
 540 |     | <span class='unexecuted'>            if (fees0 &gt; 0)</span>
 541 |     | <span class='unexecuted'>                TransferHelper.safeTransfer(</span>
 542 |     | <span class='unexecuted'>                    address(token0),</span>
 543 |     | <span class='unexecuted'>                    indexFund,</span>
 544 |     | <span class='unexecuted'>                    FullMath.mulDiv(fees0, percentage, 100)</span>
 545 |     | <span class='neutral'>                );</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='unexecuted'>            if (fees1 &gt; 0)</span>
 548 |     | <span class='unexecuted'>                TransferHelper.safeTransfer(</span>
 549 |     | <span class='unexecuted'>                    address(token1),</span>
 550 |     | <span class='unexecuted'>                    indexFund,</span>
 551 |     | <span class='unexecuted'>                    FullMath.mulDiv(fees1, percentage, 100)</span>
 552 |     | <span class='neutral'>                );</span>
 553 |     | <span class='neutral'></span>
 554 |     | <span class='unexecuted'>            emit FeesSnapshot(isReadjustLiquidity, fees0, fees1);</span>
 555 |     | <span class='neutral'>        }</span>
 556 |     | <span class='neutral'>    }</span>
 557 |     | <span class='neutral'></span>
 558 |     | <span class='unexecuted'>    function transferFunds(</span>
 559 |     | <span class='neutral'>        bool refundAsETH,</span>
 560 |     | <span class='neutral'>        address recipient,</span>
 561 |     | <span class='neutral'>        address token,</span>
 562 |     | <span class='neutral'>        uint256 amount</span>
 563 |     | <span class='neutral'>    ) internal {</span>
 564 |     | <span class='unexecuted'>        if (refundAsETH &amp;&amp; token == WETH) {</span>
 565 |     | <span class='unexecuted'>            IWETH9(WETH).withdraw(amount);</span>
 566 |     | <span class='unexecuted'>            TransferHelper.safeTransferETH(recipient, amount);</span>
 567 |     | <span class='neutral'>        } else {</span>
 568 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token, recipient, amount);</span>
 569 |     | <span class='neutral'>        }</span>
 570 |     | <span class='neutral'>    }</span>
 571 |     | <span class='neutral'></span>
 572 |     | <span class='neutral'>    /// @param token The token to pay</span>
 573 |     | <span class='neutral'>    /// @param payer The entity that must pay</span>
 574 |     | <span class='neutral'>    /// @param recipient The entity that will receive payment</span>
 575 |     | <span class='neutral'>    /// @param value The amount to pay</span>
 576 |     | <span class='unexecuted'>    function pay(</span>
 577 |     | <span class='neutral'>        address token,</span>
 578 |     | <span class='neutral'>        address payer,</span>
 579 |     | <span class='neutral'>        address recipient,</span>
 580 |     | <span class='neutral'>        uint256 value</span>
 581 |     | <span class='neutral'>    ) internal {</span>
 582 |     | <span class='unexecuted'>        if (token == WETH &amp;&amp; address(this).balance &gt;= value) {</span>
 583 |     | <span class='neutral'>            // pay with WETH9</span>
 584 |     | <span class='unexecuted'>            IWETH9(WETH).deposit{ value: value }(); // wrap only what is needed to pay</span>
 585 |     | <span class='unexecuted'>            IWETH9(WETH).transfer(recipient, value);</span>
 586 |     | <span class='unexecuted'>        } else if (payer == address(this)) {</span>
 587 |     | <span class='neutral'>            // pay with tokens already in the contract (for the exact input multihop case)</span>
 588 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token, recipient, value);</span>
 589 |     | <span class='neutral'>        } else {</span>
 590 |     | <span class='neutral'>            // pull payment</span>
 591 |     | <span class='unexecuted'>            TransferHelper.safeTransferFrom(token, payer, recipient, value);</span>
 592 |     | <span class='neutral'>        }</span>
 593 |     | <span class='neutral'>    }</span>
 594 |     | <span class='neutral'>}</span>
 595 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/UnipilotStrategy.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
   4 |     | <span class='neutral'>pragma abicoder v2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./interfaces/IUnipilotStrategy.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./base/oracle/libraries/OracleLibrary.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>// import &quot;./dependencies/libraries/TickMath.sol&quot;;</span>
  10 |     | <span class='neutral'>// import &quot;./dependencies/interfaces/IUniswapV3Pool.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * @notice</span>
  15 |     | <span class='neutral'> *   This contract calculates suitable tick ranges to fully deposit liquidity asset.</span>
  16 |     | <span class='neutral'> *   It maintains two strategies for unipilot vaults</span>
  17 |     | <span class='neutral'> *   1) Base order =&gt; For depositing in-range liquidity</span>
  18 |     | <span class='neutral'> *   2) Range order =&gt; To distribute remaining assets behind or ahead of base order ticks,</span>
  19 |     | <span class='neutral'> *   so that users liquidity does not abruptly goes out of range</span>
  20 |     | <span class='neutral'> *   @dev These ranges are named as follows.</span>
  21 |     | <span class='neutral'> *   Base =&gt; upper and lower ticks for main range to deposit</span>
  22 |     | <span class='neutral'> *   Ask =&gt; Upper and lower ticks ahead of the current tick and base upper</span>
  23 |     | <span class='neutral'> *   Bid =&gt; Upper and lower ticks behind the current and base lower</span>
  24 | *r  | <span class='executed'> **/</span>
  25 |     | <span class='neutral'>contract UnipilotStrategy is IUnipilotStrategy {</span>
  26 |     | <span class='neutral'>    /// @dev governance address is set on deployment for the governance based functions</span>
  27 | *   | <span class='executed'>    address public governance;</span>
  28 |     | <span class='neutral'>    /// @dev rangeTicks is multiplied with tick spacing to calculate range order spread</span>
  29 | *   | <span class='executed'>    int24 public rangeTicks;</span>
  30 |     | <span class='neutral'>    /// @dev baseTicks is multiplied with tick spacing to calculate base order spread</span>
  31 | *   | <span class='executed'>    int24 public baseTicks;</span>
  32 |     | <span class='neutral'>    /// @dev rangeOrder is the range calculate the spread behind and ahead of the base range</span>
  33 |     | <span class='neutral'>    int24 private rangeOrder;</span>
  34 |     | <span class='neutral'>    /// @dev baseMultiplier multiplier for base position for active pools</span>
  35 | *   | <span class='executed'>    int24 public baseMultiplier;</span>
  36 |     | <span class='neutral'>    /// @dev readjustMultiplier is the percentage multiplier of raedjust threshold</span>
  37 |     | <span class='neutral'>    int24 private readjustMultiplier;</span>
  38 |     | <span class='neutral'>    /// @dev maxTwapDeviation is the max time weighted average deviation of price from the normal range in both directions</span>
  39 | *   | <span class='executed'>    int24 public override maxTwapDeviation;</span>
  40 |     | <span class='neutral'>    /// @dev twapDuration is the minimum duration in which the diviated price moves</span>
  41 | *   | <span class='executed'>    uint32 public override twapDuration;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    constructor(address _governance) {</span>
  44 |     | <span class='unexecuted'>        governance = _governance;</span>
  45 |     | <span class='unexecuted'>        maxTwapDeviation = 300;</span>
  46 |     | <span class='unexecuted'>        twapDuration = 3600;</span>
  47 |     | <span class='unexecuted'>        rangeTicks = 1800;</span>
  48 |     | <span class='unexecuted'>        baseTicks = 1800;</span>
  49 |     | <span class='unexecuted'>        readjustMultiplier = 10;</span>
  50 |     | <span class='unexecuted'>        baseMultiplier = 30;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /// @dev poolStrategy maintains the base,range multipliers and</span>
  54 |     | <span class='neutral'>    ///  twap variations for each pool</span>
  55 |     | <span class='neutral'>    mapping(address =&gt; PoolStrategy) internal poolStrategy;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    mapping(address =&gt; mapping(uint16 =&gt; int24)) internal activePoolStrategy;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    modifier onlyGovernance() {</span>
  60 | r   | <span class='reverted'>        require(msg.sender == governance, &quot;NG&quot;);</span>
  61 |     | <span class='unexecuted'>        _;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 | r   | <span class='reverted'>    function setGovernance(address _governance) external onlyGovernance {</span>
  65 |     | <span class='unexecuted'>        require(_governance != address(0), &quot;IGA&quot;);</span>
  66 |     | <span class='unexecuted'>        emit GovernanceUpdated(governance, _governance);</span>
  67 |     | <span class='unexecuted'>        governance = _governance;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     *   @notice This function returns base,ask and bid range ticks for the given pool</span>
  72 |     | <span class='neutral'>     *   - It fetches the current tick and tick spacing of the pool</span>
  73 |     | <span class='neutral'>     *   - Multiples the tick spacing with pools base and range multipliers</span>
  74 |     | <span class='neutral'>     *   - Calculates pools twap and verifies whether it is under the maxtwapdeviation</span>
  75 |     | <span class='neutral'>     *   - If the price is under the deviation limit, it returns the base ranges along with range order ticks</span>
  76 |     | <span class='neutral'>     *   @param _pool: pool address</span>
  77 |     | <span class='neutral'>     **/</span>
  78 | r   | <span class='reverted'>    function getTicks(address _pool)</span>
  79 |     | <span class='neutral'>        external</span>
  80 |     | <span class='neutral'>        override</span>
  81 |     | <span class='neutral'>        returns (</span>
  82 | r   | <span class='reverted'>            int24 baseLower,</span>
  83 | r   | <span class='reverted'>            int24 baseUpper,</span>
  84 | r   | <span class='reverted'>            int24 bidLower,</span>
  85 | r   | <span class='reverted'>            int24 bidUpper,</span>
  86 | r   | <span class='reverted'>            int24 askLower,</span>
  87 | r   | <span class='reverted'>            int24 askUpper</span>
  88 |     | <span class='neutral'>        )</span>
  89 |     | <span class='neutral'>    {</span>
  90 | r   | <span class='reverted'>        (int24 tick, int24 tickSpacing) = getCurrentTick(_pool);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        if (</span>
  93 |     | <span class='unexecuted'>            poolStrategy[_pool].baseThreshold == 0 ||</span>
  94 |     | <span class='unexecuted'>            poolStrategy[_pool].rangeThreshold == 0</span>
  95 |     | <span class='neutral'>        ) {</span>
  96 |     | <span class='unexecuted'>            int24 baseFloor = _floor(baseTicks, tickSpacing);</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>            poolStrategy[_pool] = PoolStrategy({</span>
  99 |     | <span class='unexecuted'>                baseThreshold: baseFloor,</span>
 100 |     | <span class='unexecuted'>                rangeThreshold: _floor(rangeTicks, tickSpacing),</span>
 101 |     | <span class='unexecuted'>                maxTwapDeviation: maxTwapDeviation,</span>
 102 |     | <span class='unexecuted'>                readjustThreshold: (baseFloor * readjustMultiplier) / 100,</span>
 103 |     | <span class='unexecuted'>                twapDuration: twapDuration,</span>
 104 |     | <span class='unexecuted'>                baseMultiplier: baseMultiplier</span>
 105 |     | <span class='neutral'>            });</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='unexecuted'>        rangeOrder = poolStrategy[_pool].rangeThreshold;</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        int24 maxThreshold = poolStrategy[_pool].baseThreshold &gt; rangeOrder</span>
 110 |     | <span class='unexecuted'>            ? poolStrategy[_pool].baseThreshold</span>
 111 |     | <span class='unexecuted'>            : rangeOrder;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        require(</span>
 114 |     | <span class='unexecuted'>            (tick &gt; TickMath.MIN_TICK + maxThreshold + tickSpacing) &amp;&amp;</span>
 115 |     | <span class='unexecuted'>                (tick &lt; (TickMath.MAX_TICK - maxThreshold - tickSpacing)),</span>
 116 |     | <span class='neutral'>            &quot;IT&quot;</span>
 117 |     | <span class='neutral'>        );</span>
 118 |     | <span class='unexecuted'>        int24 twap = calculateTwap(_pool);</span>
 119 |     | <span class='unexecuted'>        int24 deviation = tick &gt; twap ? tick - twap : twap - tick;</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        require(deviation &lt;= poolStrategy[_pool].maxTwapDeviation, &quot;MTF&quot;);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>        int24 tickFloor = _floor(tick, tickSpacing);</span>
 124 |     | <span class='unexecuted'>        int24 tickCeil = tickFloor + tickSpacing;</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>        baseLower = tickFloor - poolStrategy[_pool].baseThreshold;</span>
 127 |     | <span class='unexecuted'>        baseUpper = tickFloor + poolStrategy[_pool].baseThreshold;</span>
 128 |     | <span class='unexecuted'>        bidLower = tickFloor - rangeOrder;</span>
 129 |     | <span class='unexecuted'>        bidUpper = tickFloor;</span>
 130 |     | <span class='unexecuted'>        askLower = tickCeil;</span>
 131 |     | <span class='unexecuted'>        askUpper = tickCeil + rangeOrder;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /**</span>
 135 |     | <span class='neutral'>     *   @notice This function sets the global multipier value of the range order</span>
 136 |     | <span class='neutral'>     *   @param _rangeTicks: a multiplier value to decide the spread of range order</span>
 137 |     | <span class='neutral'>     **/</span>
 138 | r   | <span class='reverted'>    function setRangeTicks(int24 _rangeTicks) external onlyGovernance {</span>
 139 |     | <span class='unexecuted'>        require(_rangeTicks &gt; 0, &quot;IRM&quot;);</span>
 140 |     | <span class='unexecuted'>        emit RangeTicksUpdated(rangeTicks, _rangeTicks);</span>
 141 |     | <span class='unexecuted'>        rangeTicks = _rangeTicks;</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /**</span>
 145 |     | <span class='neutral'>     *   @notice This function updates the base range mutiplier</span>
 146 |     | <span class='neutral'>     *   @param _baseMultiplier: a mutiplier value to decide the spread of base range</span>
 147 |     | <span class='neutral'>     **/</span>
 148 | r   | <span class='reverted'>    function setBaseTicks(</span>
 149 |     | <span class='neutral'>        address[] memory _pools,</span>
 150 |     | <span class='neutral'>        uint16[] memory _strategyType,</span>
 151 |     | <span class='neutral'>        int24[] memory _baseMultiplier</span>
 152 |     | <span class='neutral'>    ) external onlyGovernance {</span>
 153 |     | <span class='unexecuted'>        require(_pools.length == _baseMultiplier.length);</span>
 154 |     | <span class='unexecuted'>        require(_pools.length == _strategyType.length);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _pools.length; i++) {</span>
 157 |     | <span class='unexecuted'>            activePoolStrategy[_pools[i]][_strategyType[i]] = _baseMultiplier[</span>
 158 |     | <span class='unexecuted'>                i</span>
 159 |     | <span class='neutral'>            ];</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /**</span>
 164 |     | <span class='neutral'>     *   @notice This function updates the deviation limit of tick spread</span>
 165 |     | <span class='neutral'>     *   @param _twapDeviation: a value to decide the maximum price deviation</span>
 166 |     | <span class='neutral'>     **/</span>
 167 | r   | <span class='reverted'>    function setMaxTwapDeviation(int24 _twapDeviation) external onlyGovernance {</span>
 168 |     | <span class='unexecuted'>        require(_twapDeviation &gt;= 20, &quot;PF&quot;);</span>
 169 |     | <span class='unexecuted'>        emit MaxTwapDeviationUpdated(</span>
 170 |     | <span class='unexecuted'>            maxTwapDeviation,</span>
 171 |     | <span class='unexecuted'>            maxTwapDeviation = _twapDeviation</span>
 172 |     | <span class='neutral'>        );</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /**</span>
 176 |     | <span class='neutral'>     *   @notice This function updates the twap duration</span>
 177 |     | <span class='neutral'>     *   @param _twapDuration: a value for the duration of recalbiration of the twap</span>
 178 |     | <span class='neutral'>     **/</span>
 179 | r   | <span class='reverted'>    function setTwapDuration(uint32 _twapDuration) external onlyGovernance {</span>
 180 |     | <span class='unexecuted'>        require(_twapDuration &gt;= 100, &quot;TD&quot;);</span>
 181 |     | <span class='unexecuted'>        emit TwapDurationUpdated(twapDuration, twapDuration = _twapDuration);</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 | r   | <span class='reverted'>    function setReadjustMultiplier(int24 _readjustMultipier)</span>
 185 |     | <span class='neutral'>        external</span>
 186 |     | <span class='neutral'>        onlyGovernance</span>
 187 |     | <span class='neutral'>    {</span>
 188 |     | <span class='unexecuted'>        require(_readjustMultipier &gt; 0, &quot;IREM&quot;);</span>
 189 |     | <span class='unexecuted'>        emit ReadjustMultiplierUpdated(</span>
 190 |     | <span class='unexecuted'>            readjustMultiplier,</span>
 191 |     | <span class='unexecuted'>            readjustMultiplier = _readjustMultipier</span>
 192 |     | <span class='neutral'>        );</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /**</span>
 196 |     | <span class='neutral'>     *   @notice This function updates the range,base threshold and twap values specific to a pool</span>
 197 |     | <span class='neutral'>     *   @param params: struct values of PoolStrategy struct, the values can be inspected from interface</span>
 198 |     | <span class='neutral'>     *   @param _pool&lt;: pool address</span>
 199 |     | <span class='neutral'>     **/</span>
 200 | r   | <span class='reverted'>    function changeStrategy(PoolStrategy memory params, address _pool)</span>
 201 |     | <span class='neutral'>        public</span>
 202 |     | <span class='neutral'>        onlyGovernance</span>
 203 |     | <span class='neutral'>    {</span>
 204 |     | <span class='unexecuted'>        PoolStrategy memory oldStrategy = poolStrategy[_pool];</span>
 205 |     | <span class='unexecuted'>        validateStrategy(</span>
 206 |     | <span class='unexecuted'>            params.baseThreshold,</span>
 207 |     | <span class='unexecuted'>            IUniswapV3Pool(_pool).tickSpacing()</span>
 208 |     | <span class='neutral'>        );</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>        emit StrategyUpdated(</span>
 211 |     | <span class='unexecuted'>            oldStrategy,</span>
 212 |     | <span class='unexecuted'>            poolStrategy[_pool] = PoolStrategy({</span>
 213 |     | <span class='unexecuted'>                baseThreshold: params.baseThreshold,</span>
 214 |     | <span class='unexecuted'>                rangeThreshold: params.rangeThreshold,</span>
 215 |     | <span class='unexecuted'>                maxTwapDeviation: params.maxTwapDeviation,</span>
 216 |     | <span class='unexecuted'>                readjustThreshold: params.readjustThreshold,</span>
 217 |     | <span class='unexecuted'>                twapDuration: params.twapDuration,</span>
 218 |     | <span class='unexecuted'>                baseMultiplier: params.baseMultiplier</span>
 219 |     | <span class='neutral'>            })</span>
 220 |     | <span class='neutral'>        );</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 | r   | <span class='reverted'>    function setAllStrategies(</span>
 224 |     | <span class='neutral'>        PoolStrategy[] memory params,</span>
 225 |     | <span class='neutral'>        address[] memory pools</span>
 226 |     | <span class='neutral'>    ) external onlyGovernance {</span>
 227 |     | <span class='unexecuted'>        require(params.length == pools.length, &quot;IVI&quot;);</span>
 228 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; params.length; i++) {</span>
 229 |     | <span class='unexecuted'>            changeStrategy(params[i], pools[i]);</span>
 230 |     | <span class='neutral'>        }</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    /**</span>
 234 |     | <span class='neutral'>     *   @notice This function updates the twapDeviation value of pools iteratively</span>
 235 |     | <span class='neutral'>     *   @param _pools: pools addresses</span>
 236 |     | <span class='neutral'>     *   @param _twapDeviations: devaiation values</span>
 237 |     | <span class='neutral'>     **/</span>
 238 | r   | <span class='reverted'>    function setPoolTwapDeviation(</span>
 239 |     | <span class='neutral'>        address[] memory _pools,</span>
 240 |     | <span class='neutral'>        int24[] memory _twapDeviations</span>
 241 |     | <span class='neutral'>    ) external onlyGovernance {</span>
 242 |     | <span class='unexecuted'>        require(_pools.length == _twapDeviations.length, &quot;IVI&quot;);</span>
 243 |     | <span class='unexecuted'>        for (uint256 i; i &lt; _pools.length; i++) {</span>
 244 |     | <span class='unexecuted'>            poolStrategy[_pools[i]].maxTwapDeviation = _twapDeviations[i];</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 | r   | <span class='reverted'>    function checkDeviation(address pool) external view override {</span>
 249 | r   | <span class='reverted'>        int24 twap = calculateTwap(pool);</span>
 250 |     | <span class='unexecuted'>        (int24 tick, ) = getCurrentTick(pool);</span>
 251 |     | <span class='unexecuted'>        int24 deviation = tick &gt; twap ? tick - twap : twap - tick;</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='unexecuted'>        require(deviation &lt;= poolStrategy[pool].maxTwapDeviation, &quot;MTF&quot;);</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>    function getStrategy(address _pool)</span>
 257 |     | <span class='neutral'>        external</span>
 258 |     | <span class='neutral'>        view</span>
 259 |     | <span class='neutral'>        override</span>
 260 | *   | <span class='executed'>        returns (PoolStrategy memory strategy)</span>
 261 |     | <span class='neutral'>    {</span>
 262 | *   | <span class='executed'>        strategy = poolStrategy[_pool];</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>    /**</span>
 266 |     | <span class='neutral'>     *   @notice This function returns the readjust threshold of a pool</span>
 267 |     | <span class='neutral'>     *   @param _pool: pool address</span>
 268 |     | <span class='neutral'>     **/</span>
 269 | *   | <span class='executed'>    function getReadjustThreshold(address _pool)</span>
 270 |     | <span class='neutral'>        public</span>
 271 |     | <span class='neutral'>        view</span>
 272 | *   | <span class='executed'>        returns (int24 readjustThreshold)</span>
 273 |     | <span class='neutral'>    {</span>
 274 | *   | <span class='executed'>        readjustThreshold = poolStrategy[_pool].readjustThreshold;</span>
 275 |     | <span class='neutral'>        return readjustThreshold;</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 | *   | <span class='executed'>    function getBaseThreshold(address _pool, uint16 _strategyType)</span>
 279 |     | <span class='neutral'>        external</span>
 280 |     | <span class='neutral'>        view</span>
 281 |     | <span class='neutral'>        override</span>
 282 | *   | <span class='executed'>        returns (int24 baseThreshold)</span>
 283 |     | <span class='neutral'>    {</span>
 284 | *   | <span class='executed'>        baseThreshold = activePoolStrategy[_pool][_strategyType];</span>
 285 |     | <span class='neutral'>    }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>    /**</span>
 288 |     | <span class='neutral'>     *   @notice This function calculates the current twap of pool</span>
 289 |     | <span class='neutral'>     *   @param pool: pool address</span>
 290 |     | <span class='neutral'>     **/</span>
 291 | r   | <span class='reverted'>    function calculateTwap(address pool) internal view returns (int24 twap) {</span>
 292 | r   | <span class='reverted'>        uint128 inRangeLiquidity = IUniswapV3Pool(pool).liquidity();</span>
 293 |     | <span class='unexecuted'>        if (inRangeLiquidity == 0) {</span>
 294 |     | <span class='unexecuted'>            (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();</span>
 295 |     | <span class='unexecuted'>            twap = TickMath.getTickAtSqrtRatio(sqrtPriceX96);</span>
 296 |     | <span class='neutral'>        } else {</span>
 297 |     | <span class='unexecuted'>            twap = getTwap(pool);</span>
 298 |     | <span class='neutral'>        }</span>
 299 |     | <span class='neutral'>    }</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>    /**</span>
 302 |     | <span class='neutral'>     *   @notice This function fetches the twap of pool from the observation</span>
 303 |     | <span class='neutral'>     *   @param _pool: pool address</span>
 304 |     | <span class='neutral'>     **/</span>
 305 | r   | <span class='reverted'>    function getTwap(address _pool) public view override returns (int24 twap) {</span>
 306 | r   | <span class='reverted'>        IUniswapV3Pool uniswapV3Pool = IUniswapV3Pool(_pool);</span>
 307 |     | <span class='unexecuted'>        (</span>
 308 |     | <span class='neutral'>            ,</span>
 309 |     | <span class='neutral'>            ,</span>
 310 | r   | <span class='reverted'>            uint16 observationIndex,</span>
 311 | r   | <span class='reverted'>            uint16 observationCardinality,</span>
 312 |     | <span class='neutral'>            ,</span>
 313 |     | <span class='neutral'>            ,</span>
 314 |     | <span class='neutral'></span>
 315 | r   | <span class='reverted'>        ) = uniswapV3Pool.slot0();</span>
 316 |     | <span class='unexecuted'>        (uint32 lastTimeStamp, , , ) = uniswapV3Pool.observations(</span>
 317 |     | <span class='unexecuted'>            (observationIndex + 1) % observationCardinality</span>
 318 |     | <span class='neutral'>        );</span>
 319 |     | <span class='unexecuted'>        uint32 timeDiff = uint32(block.timestamp) - lastTimeStamp;</span>
 320 |     | <span class='unexecuted'>        uint32 duration = poolStrategy[_pool].twapDuration;</span>
 321 |     | <span class='unexecuted'>        if (duration == 0) {</span>
 322 |     | <span class='unexecuted'>            duration = twapDuration;</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='unexecuted'>        twap = OracleLibrary.consult(</span>
 325 |     | <span class='unexecuted'>            _pool,</span>
 326 |     | <span class='unexecuted'>            timeDiff &gt; duration ? duration : timeDiff</span>
 327 |     | <span class='neutral'>        );</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    /**</span>
 331 |     | <span class='neutral'>     *   @notice This function calculates the lower tick value from the current tick</span>
 332 |     | <span class='neutral'>     *   @param tick: current tick of the pool</span>
 333 |     | <span class='neutral'>     *   @param tickSpacing: tick spacing according to the fee tier</span>
 334 |     | <span class='neutral'>     **/</span>
 335 |     | <span class='unexecuted'>    function _floor(int24 tick, int24 tickSpacing)</span>
 336 |     | <span class='neutral'>        internal</span>
 337 |     | <span class='neutral'>        pure</span>
 338 |     | <span class='unexecuted'>        returns (int24)</span>
 339 |     | <span class='neutral'>    {</span>
 340 |     | <span class='unexecuted'>        int24 compressed = tick / tickSpacing;</span>
 341 |     | <span class='unexecuted'>        if (tick &lt; 0 &amp;&amp; tick % tickSpacing != 0) compressed--;</span>
 342 |     | <span class='unexecuted'>        return compressed * tickSpacing;</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    /**</span>
 346 |     | <span class='neutral'>     *   @notice This function fetches the current tick of the pool</span>
 347 |     | <span class='neutral'>     *   @param pool: pool address</span>
 348 |     | <span class='neutral'>     **/</span>
 349 | r   | <span class='reverted'>    function getCurrentTick(address pool)</span>
 350 |     | <span class='neutral'>        internal</span>
 351 |     | <span class='neutral'>        view</span>
 352 | r   | <span class='reverted'>        returns (int24 tick, int24 tickSpacing)</span>
 353 |     | <span class='neutral'>    {</span>
 354 | r   | <span class='reverted'>        (, tick, , , , , ) = IUniswapV3PoolState(pool).slot0();</span>
 355 |     | <span class='unexecuted'>        tickSpacing = IUniswapV3Pool(pool).tickSpacing();</span>
 356 |     | <span class='neutral'>    }</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>    /**</span>
 359 |     | <span class='neutral'>     *   @notice This function validates that the updating strategy of the pool during the update</span>
 360 |     | <span class='neutral'>     *   @param _strategy: a value for baseThreshold</span>
 361 |     | <span class='neutral'>     *   @param _tickSpacing: spacing of tick according to fee tier</span>
 362 |     | <span class='neutral'>     **/</span>
 363 |     | <span class='unexecuted'>    function validateStrategy(int24 _strategy, int24 _tickSpacing)</span>
 364 |     | <span class='neutral'>        internal</span>
 365 |     | <span class='neutral'>        pure</span>
 366 |     | <span class='neutral'>    {</span>
 367 |     | <span class='unexecuted'>        require(</span>
 368 |     | <span class='unexecuted'>            _strategy &lt;= TickMath.MAX_TICK &amp;&amp;</span>
 369 |     | <span class='unexecuted'>                _strategy % _tickSpacing == 0 &amp;&amp;</span>
 370 |     | <span class='unexecuted'>                _strategy &gt; 0,</span>
 371 |     | <span class='neutral'>            &quot;INS&quot;</span>
 372 |     | <span class='neutral'>        );</span>
 373 |     | <span class='neutral'>    }</span>
 374 |     | <span class='neutral'>}</span>
 375 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/base/oracle/libraries/OracleLibrary.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../../../dependencies/interfaces/IUniswapV3Pool.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../../dependencies/libraries/FullMath.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../../../dependencies/libraries/TickMath.sol&quot;;</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>library OracleLibrary {</span>
  9 |     | <span class='neutral'>    /// @notice Fetches time-weighted average tick using Uniswap V3 oracle</span>
 10 |     | <span class='neutral'>    /// @param pool Address of Uniswap V3 pool that we want to observe</span>
 11 |     | <span class='neutral'>    /// @param period Number of seconds in the past to start calculating time-weighted average</span>
 12 |     | <span class='neutral'>    /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp</span>
 13 |     | <span class='unexecuted'>    function consult(address pool, uint32 period)</span>
 14 |     | <span class='neutral'>        internal</span>
 15 |     | <span class='neutral'>        view</span>
 16 |     | <span class='unexecuted'>        returns (int24 timeWeightedAverageTick)</span>
 17 |     | <span class='neutral'>    {</span>
 18 |     | <span class='unexecuted'>        require(period != 0, &quot;BP&quot;);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>        uint32[] memory secondAgos = new uint32[](2);</span>
 21 |     | <span class='unexecuted'>        secondAgos[0] = period;</span>
 22 |     | <span class='unexecuted'>        secondAgos[1] = 0;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>        (int56[] memory tickCumulatives, ) = IUniswapV3Pool(pool).observe(</span>
 25 |     | <span class='unexecuted'>            secondAgos</span>
 26 |     | <span class='neutral'>        );</span>
 27 |     | <span class='unexecuted'>        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        timeWeightedAverageTick = int24(tickCumulativesDelta / period);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>        // Always round to negative infinity</span>
 32 |     | <span class='unexecuted'>        if (tickCumulativesDelta &lt; 0 &amp;&amp; (tickCumulativesDelta % period != 0))</span>
 33 |     | <span class='unexecuted'>            timeWeightedAverageTick--;</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange</span>
 37 |     | <span class='neutral'>    /// @param tick Tick value used to calculate the quote</span>
 38 |     | <span class='neutral'>    /// @param baseAmount Amount of token to be converted</span>
 39 |     | <span class='neutral'>    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination</span>
 40 |     | <span class='neutral'>    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination</span>
 41 |     | <span class='neutral'>    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken</span>
 42 |     | <span class='neutral'>    function getQuoteAtTick(</span>
 43 |     | <span class='neutral'>        int24 tick,</span>
 44 |     | <span class='neutral'>        uint128 baseAmount,</span>
 45 |     | <span class='neutral'>        address baseToken,</span>
 46 |     | <span class='neutral'>        address quoteToken</span>
 47 |     | <span class='neutral'>    ) internal pure returns (uint256 quoteAmount) {</span>
 48 |     | <span class='neutral'>        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>        // Calculate quoteAmount with better precision if it doesn&#39;t overflow when multiplied by itself</span>
 51 |     | <span class='neutral'>        if (sqrtRatioX96 &lt;= type(uint128).max) {</span>
 52 |     | <span class='neutral'>            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;</span>
 53 |     | <span class='neutral'>            quoteAmount = baseToken &lt; quoteToken</span>
 54 |     | <span class='neutral'>                ? FullMath.mulDiv(ratioX192, baseAmount, 1 &lt;&lt; 192)</span>
 55 |     | <span class='neutral'>                : FullMath.mulDiv(1 &lt;&lt; 192, baseAmount, ratioX192);</span>
 56 |     | <span class='neutral'>        } else {</span>
 57 |     | <span class='neutral'>            uint256 ratioX128 = FullMath.mulDiv(</span>
 58 |     | <span class='neutral'>                sqrtRatioX96,</span>
 59 |     | <span class='neutral'>                sqrtRatioX96,</span>
 60 |     | <span class='neutral'>                1 &lt;&lt; 64</span>
 61 |     | <span class='neutral'>            );</span>
 62 |     | <span class='neutral'>            quoteAmount = baseToken &lt; quoteToken</span>
 63 |     | <span class='neutral'>                ? FullMath.mulDiv(ratioX128, baseAmount, 1 &lt;&lt; 128)</span>
 64 |     | <span class='neutral'>                : FullMath.mulDiv(1 &lt;&lt; 128, baseAmount, ratioX128);</span>
 65 |     | <span class='neutral'>        }</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/crytic/testSetup.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
   3 |     | <span class='neutral'>pragma abicoder v2;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./testUnipilot.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../dependencies/libraries/SafeMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import { UnipilotActiveVault } from &quot;../UnipilotActiveVault.sol&quot;;</span>
   8 | *r  | <span class='executed'></span>
   9 |     | <span class='neutral'>contract UnipilotFuzz is testUnipiot {</span>
  10 |     | <span class='neutral'>    using SafeMath for uint256;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    address t0;</span>
  13 |     | <span class='neutral'>    address t1;</span>
  14 | *   | <span class='executed'>    UnipilotActiveVault public UAV;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    event notmytoken(address);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    enum FeeTier {</span>
  19 |     | <span class='neutral'>        LOW, // 0.05% fee tier</span>
  20 |     | <span class='neutral'>        MEDIUM, // 0.30% fee tier</span>
  21 |     | <span class='neutral'>        HIGH // 1.00% fee tier</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    mapping(FeeTier =&gt; uint24) feeValues;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    constructor() {</span>
  27 |     | <span class='unexecuted'>        feeValues[FeeTier.LOW] = 500; // 0.05% fee tier</span>
  28 |     | <span class='unexecuted'>        feeValues[FeeTier.MEDIUM] = 3000; // 0.30% fee tier</span>
  29 |     | <span class='unexecuted'>        feeValues[FeeTier.HIGH] = 10000; // 1.00% fee tier</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 | *   | <span class='executed'>    function gettokens() public {</span>
  33 | *   | <span class='executed'>        (t0, t1) = createToken(msg.sender);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 | r   | <span class='reverted'>    function encodePriceSqrt(</span>
  37 |     | <span class='neutral'>        uint256 reserve1,</span>
  38 |     | <span class='neutral'>        uint256 reserve0</span>
  39 | r   | <span class='reverted'>    ) private pure returns (uint160 encodedPriceSqrt) {</span>
  40 |     | <span class='neutral'>        // uint256 priceSqrt = SafeMath</span>
  41 |     | <span class='neutral'>        //     .sqrt(reserve1.mul(1e18).div(reserve0))</span>
  42 |     | <span class='neutral'>        //     .mul(2 ** 96)</span>
  43 |     | <span class='neutral'>        //     .div(1e9);</span>
  44 | r   | <span class='reverted'>        encodedPriceSqrt = uint160(1);</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>//Createting UnipilotActiveVault using UnipilotActiveFactory</span>
  48 |     | <span class='neutral'>//Arbitary (valid in range) values been sent by echidna to fuzz different scenarios</span>
  49 | r   | <span class='reverted'>    function testAddressValidity(</span>
  50 |     | <span class='neutral'>        uint256 amount0,</span>
  51 |     | <span class='neutral'>        uint256 amount1,</span>
  52 |     | <span class='neutral'>        uint16 _vaultStrategy,</span>
  53 |     | <span class='neutral'>        FeeTier fee</span>
  54 |     | <span class='neutral'>    ) public {</span>
  55 | r   | <span class='reverted'>        uint160 _sqrtPriceX96 = encodePriceSqrt(amount0, amount1);</span>
  56 | r   | <span class='reverted'>        require(t0 != address(0) &amp;&amp; _vaultStrategy &lt; 5, &quot;TV&quot;);</span>
  57 | r   | <span class='reverted'>        address vault = UAF.createVault(</span>
  58 | r   | <span class='reverted'>            address(t0),</span>
  59 | r   | <span class='reverted'>            address(t1),</span>
  60 | r   | <span class='reverted'>            uint24(fee),</span>
  61 | r   | <span class='reverted'>            _vaultStrategy,</span>
  62 | r   | <span class='reverted'>            _sqrtPriceX96,</span>
  63 |     | <span class='neutral'>            &quot;Fuzz&quot;,</span>
  64 |     | <span class='neutral'>            &quot;fuzz&quot;</span>
  65 |     | <span class='neutral'>        );</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        assert(vault != address(0));</span>
  68 |     | <span class='neutral'>       // UAV = UnipilotActiveVault(payable(vault));</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /*</span>
  72 |     | <span class='neutral'>    Depositing tokens should increase the total supply of LP tokens and the balance of the </span>
  73 |     | <span class='neutral'>    contract in both token0 and token1:</span>
  74 |     | <span class='neutral'>    This invariant ensures that the deposit function is working as intended. When tokens </span>
  75 |     | <span class='neutral'>    are deposited into the contract, the total supply of LP tokens should increase, and the </span>
  76 |     | <span class='neutral'>    balance of the contract in both token0 and token1 should also increase by the appropriate </span>
  77 |     | <span class='neutral'>    amounts. This invariant should be checked after every deposit.</span>
  78 |     | <span class='neutral'>    */</span>
  79 | r   | <span class='reverted'>    function testLpIncrease(uint256 amount0, uint256 amount1) public {</span>
  80 | r   | <span class='reverted'>        uint256 preLP = UAV._totalSupply();</span>
  81 |     | <span class='unexecuted'>        UAV.deposit(amount0, amount1, msg.sender);</span>
  82 |     | <span class='unexecuted'>        uint256 postLP = UAV._totalSupply();</span>
  83 |     | <span class='unexecuted'>        assert(preLP &lt; postLP);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'>}</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>/*</span>
  88 |     | <span class='neutral'>The total supply of LP tokens must always be greater than or equal to the minimum </span>
  89 |     | <span class='neutral'>initial shares required for the first deposit:</span>
  90 |     | <span class='neutral'>This invariant ensures that the contract always has sufficient LP tokens to represent </span>
  91 |     | <span class='neutral'>the liquidity of the pool. If the total supply of LP tokens falls below the minimum </span>
  92 |     | <span class='neutral'>initial shares required for the first deposit, it means that there is not enough </span>
  93 |     | <span class='neutral'>liquidity in the pool to support trading. This invariant should be checked after </span>
  94 |     | <span class='neutral'>every deposit or withdrawal.</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>Calculate the LP tokens accourding to the balance of t0 and t1 on unipilot position on </span>
  97 |     | <span class='neutral'>uniswap and make a bat while depositing the same amount through unipilot should be the same:</span>
  98 |     | <span class='neutral'>This invariant ensures that the LP tokens minted through Unipilot are accurately reflecting </span>
  99 |     | <span class='neutral'>the balance of token0 and token1 in the Unipilot position on Uniswap, and that there are no </span>
 100 |     | <span class='neutral'>discrepancies or unexpected errors in the calculation.</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>Withdrawing LP tokens should decrease the total supply of LP tokens and the balance of </span>
 103 |     | <span class='neutral'>the contract in both token0 and token1, and should result in the correct amounts of token0 </span>
 104 |     | <span class='neutral'>and token1 being transferred to the recipient:</span>
 105 |     | <span class='neutral'>This invariant ensures that the withdrawal function is working as intended. When LP tokens </span>
 106 |     | <span class='neutral'>are withdrawn from the contract, the total supply of LP tokens should decrease, and the </span>
 107 |     | <span class='neutral'>balance of the contract in both token0 and token1 should decrease by the appropriate amounts. </span>
 108 |     | <span class='neutral'>The correct amounts of token0 and token1 should also be transferred to the recipient. </span>
 109 |     | <span class='neutral'>This invariant should be checked after every withdrawal.</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>The operator must be approved before executing any function that requires operator approval:</span>
 112 |     | <span class='neutral'>This invariant ensures that the operator approval system is working as intended. </span>
 113 |     | <span class='neutral'>Functions that require operator approval should only be executed if the operator has been </span>
 114 |     | <span class='neutral'>approved by the contract owner. This invariant should be checked before executing any function </span>
 115 |     | <span class='neutral'>that requires operator approval.</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>The contract must not allow reentrant calls:</span>
 118 |     | <span class='neutral'>This invariant ensures that the contract is protected against reentrancy attacks. Reentrancy </span>
 119 |     | <span class='neutral'>attacks occur when a function can be called recursively before the initial call has completed, </span>
 120 |     | <span class='neutral'>which can lead to unexpected behavior and potentially allow an attacker to drain the contract&#39;s </span>
 121 |     | <span class='neutral'>funds. This invariant should be checked for every function in the contract.</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>The contract must ensure that the deviation of the current liquidity from the target liquidity </span>
 124 |     | <span class='neutral'>does not exceed a certain threshold before executing any function that involves modifying the </span>
 125 |     | <span class='neutral'>liquidity of the pool:</span>
 126 |     | <span class='neutral'>This invariant ensures that the contract maintains the target liquidity range specified by the owner. </span>
 127 |     | <span class='neutral'>Before executing any function that involves modifying the liquidity of the pool, the contract should </span>
 128 |     | <span class='neutral'>check that the deviation of the current liquidity from the target liquidity does not exceed a certain </span>
 129 |     | <span class='neutral'>threshold. This invariant should be checked before executing any function that modifies the liquidity </span>
 130 |     | <span class='neutral'>of the pool.</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>The contract must not allow the protocol governance address to be changed:</span>
 133 |     | <span class='neutral'>This invariant ensures that the governance address of the protocol cannot be changed by anyone other </span>
 134 |     | <span class='neutral'>than the contract owner. This is important for ensuring the security and stability of the protocol. </span>
 135 |     | <span class='neutral'>This invariant should be checked for any function that allows the governance address to be modified.</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>dollor value before rebalnce is always greator then after rebalce because of fee </span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>uncompounded fee before rebalnce will always be greator then after rebalance</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>uncompounded fee before withdraw will always be greator then after rebalance</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>A - B != 0 before rebalce/withdraw ---------- false assumption (PreCondition)</span>
 145 |     | <span class='neutral'>A - B = 0 , A = tickHiher - currentTick, B = currentTick - lowerTick ----- after rebalce/withdraw (PostCondition)</span>
 146 |     | <span class='neutral'>*/</span>
 147 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/crytic/testUnipilot.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
   3 |     | <span class='neutral'>pragma abicoder v2;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../dependencies/UniswapV3Factory.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../UnipilotStrategy.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../dependencies/WETH.sol&quot;;</span>
   8 |     | <span class='neutral'>// import { UnipilotActiveFactory as uniFac } from &quot;../UnipilotActiveFactory.sol&quot;;</span>
   9 |     | <span class='neutral'>import { UnipilotActiveFactory } from &quot;../UnipilotActiveFactory.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 | r   | <span class='reverted'></span>
  12 |     | <span class='neutral'>contract indexfund {</span>
  13 |     | <span class='neutral'>    mapping(address =&gt; uint256) private balance0;</span>
  14 |     | <span class='neutral'>    mapping(address =&gt; uint256) private balance1;</span>
  15 |     | <span class='neutral'>}</span>
  16 | r   | <span class='reverted'></span>
  17 |     | <span class='neutral'>contract token {</span>
  18 |     | <span class='neutral'>    // --- Auth ---</span>
  19 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public wards;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    function rely(address usr) external auth {</span>
  22 |     | <span class='unexecuted'>        wards[usr] = 1;</span>
  23 |     | <span class='unexecuted'>        emit Rely(usr);</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    function deny(address usr) external auth {</span>
  27 |     | <span class='unexecuted'>        wards[usr] = 0;</span>
  28 |     | <span class='unexecuted'>        emit Deny(usr);</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    modifier auth() {</span>
  32 |     | <span class='unexecuted'>        require(wards[msg.sender] == 1, &quot;Dai/not-authorized&quot;);</span>
  33 |     | <span class='neutral'>        _;</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    // --- ERC20 Data ---</span>
  37 |     | <span class='unexecuted'>    string public constant name = &quot;Dai Stablecoin&quot;;</span>
  38 |     | <span class='unexecuted'>    string public constant symbol = &quot;DAI&quot;;</span>
  39 |     | <span class='unexecuted'>    string public constant version = &quot;2&quot;;</span>
  40 |     | <span class='unexecuted'>    uint8 public constant decimals = 18;</span>
  41 |     | <span class='unexecuted'>    uint256 public totalSupply;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
  44 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
  45 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    event Approval(</span>
  48 |     | <span class='neutral'>        address indexed owner,</span>
  49 |     | <span class='neutral'>        address indexed spender,</span>
  50 |     | <span class='neutral'>        uint256 value</span>
  51 |     | <span class='neutral'>    );</span>
  52 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  53 |     | <span class='neutral'>    event Rely(address indexed usr);</span>
  54 |     | <span class='neutral'>    event Deny(address indexed usr);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    // --- Math ---</span>
  57 |     | <span class='unexecuted'>    function _add(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  58 |     | <span class='unexecuted'>        require((z = x + y) &gt;= x);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    function _sub(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  62 |     | <span class='neutral'>        require((z = x - y) &lt;= x);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    // --- EIP712 niceties ---</span>
  66 |     | <span class='unexecuted'>    uint256 public immutable deploymentChainId;</span>
  67 |     | <span class='neutral'>    bytes32 private immutable _DOMAIN_SEPARATOR;</span>
  68 |     | <span class='unexecuted'>    bytes32 public constant PERMIT_TYPEHASH =</span>
  69 |     | <span class='unexecuted'>        keccak256(</span>
  70 |     | <span class='neutral'>            &quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;</span>
  71 |     | <span class='neutral'>        );</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>    constructor(address _sender) {</span>
  74 |     | <span class='unexecuted'>        wards[msg.sender] = 1;</span>
  75 |     | <span class='unexecuted'>        _mint(_sender, 100 ether);</span>
  76 |     | <span class='unexecuted'>        emit Rely(msg.sender);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        uint256 chainId;</span>
  79 |     | <span class='neutral'>        assembly {</span>
  80 |     | <span class='unexecuted'>            chainId := chainid()</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='unexecuted'>        deploymentChainId = chainId;</span>
  83 |     | <span class='unexecuted'>        _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>    function _calculateDomainSeparator(</span>
  87 |     | <span class='neutral'>        uint256 chainId</span>
  88 |     | <span class='unexecuted'>    ) private view returns (bytes32) {</span>
  89 |     | <span class='unexecuted'>        return</span>
  90 |     | <span class='unexecuted'>            keccak256(</span>
  91 |     | <span class='unexecuted'>                abi.encode(</span>
  92 |     | <span class='unexecuted'>                    keccak256(</span>
  93 |     | <span class='neutral'>                        &quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;</span>
  94 |     | <span class='neutral'>                    ),</span>
  95 |     | <span class='unexecuted'>                    keccak256(bytes(name)),</span>
  96 |     | <span class='unexecuted'>                    keccak256(bytes(version)),</span>
  97 |     | <span class='unexecuted'>                    chainId,</span>
  98 |     | <span class='unexecuted'>                    address(this)</span>
  99 |     | <span class='neutral'>                )</span>
 100 |     | <span class='neutral'>            );</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() external view returns (bytes32) {</span>
 104 |     | <span class='unexecuted'>        uint256 chainId;</span>
 105 |     | <span class='neutral'>        assembly {</span>
 106 |     | <span class='unexecuted'>            chainId := chainid()</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='unexecuted'>        return</span>
 109 |     | <span class='unexecuted'>            chainId == deploymentChainId</span>
 110 |     | <span class='unexecuted'>                ? _DOMAIN_SEPARATOR</span>
 111 |     | <span class='unexecuted'>                : _calculateDomainSeparator(chainId);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    // --- ERC20 Mutations ---</span>
 115 |     | <span class='unexecuted'>    function transfer(address to, uint256 value) external returns (bool) {</span>
 116 |     | <span class='unexecuted'>        require(to != address(0) &amp;&amp; to != address(this), &quot;Dai/invalid-address&quot;);</span>
 117 |     | <span class='unexecuted'>        uint256 balance = balanceOf[msg.sender];</span>
 118 |     | <span class='unexecuted'>        require(balance &gt;= value, &quot;Dai/insufficient-balance&quot;);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>        balanceOf[msg.sender] = balance - value;</span>
 121 |     | <span class='unexecuted'>        balanceOf[to] += value;</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>        emit Transfer(msg.sender, to, value);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        return true;</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>    function transferFrom(</span>
 129 |     | <span class='neutral'>        address from,</span>
 130 |     | <span class='neutral'>        address to,</span>
 131 |     | <span class='neutral'>        uint256 value</span>
 132 |     | <span class='unexecuted'>    ) external returns (bool) {</span>
 133 |     | <span class='unexecuted'>        require(to != address(0) &amp;&amp; to != address(this), &quot;Dai/invalid-address&quot;);</span>
 134 |     | <span class='unexecuted'>        uint256 balance = balanceOf[from];</span>
 135 |     | <span class='unexecuted'>        require(balance &gt;= value, &quot;Dai/insufficient-balance&quot;);</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>        // if (from != msg.sender) {</span>
 138 |     | <span class='neutral'>        //   uint256 allowed = allowance[from][msg.sender];</span>
 139 |     | <span class='neutral'>        //   if (allowed != type(uint256).max) {</span>
 140 |     | <span class='neutral'>        //     require(allowed &gt;= value, &quot;Dai/insufficient-allowance&quot;);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>        //     allowance[from][msg.sender] = allowed - value;</span>
 143 |     | <span class='neutral'>        //   }</span>
 144 |     | <span class='neutral'>        // }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>        balanceOf[from] = balance - value;</span>
 147 |     | <span class='unexecuted'>        balanceOf[to] += value;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>        emit Transfer(from, to, value);</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>        return true;</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    //   function approve(address spender, uint256 value) external returns (bool) {</span>
 155 |     | <span class='neutral'>    //     allowance[msg.sender][spender] = value;</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    //     emit Approval(msg.sender, spender, value);</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    //     return true;</span>
 160 |     | <span class='neutral'>    //   }</span>
 161 |     | <span class='neutral'>    //   function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {</span>
 162 |     | <span class='neutral'>    //     uint256 newValue = _add(allowance[msg.sender][spender], addedValue);</span>
 163 |     | <span class='neutral'>    //     allowance[msg.sender][spender] = newValue;</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    //     emit Approval(msg.sender, spender, newValue);</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    //     return true;</span>
 168 |     | <span class='neutral'>    //   }</span>
 169 |     | <span class='neutral'>    //   function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {</span>
 170 |     | <span class='neutral'>    //     uint256 allowed = allowance[msg.sender][spender];</span>
 171 |     | <span class='neutral'>    //     require(allowed &gt;= subtractedValue, &quot;Dai/insufficient-allowance&quot;);</span>
 172 |     | <span class='neutral'>    //     allowed = allowed - subtractedValue;</span>
 173 |     | <span class='neutral'>    //     allowance[msg.sender][spender] = allowed;</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    //     emit Approval(msg.sender, spender, allowed);</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    //     return true;</span>
 178 |     | <span class='neutral'>    //   }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    // --- Mint/Burn ---</span>
 181 |     | <span class='unexecuted'>    function mint(address to, uint256 value) external auth {</span>
 182 |     | <span class='unexecuted'>        require(to != address(0) &amp;&amp; to != address(this), &quot;Dai/invalid-address&quot;);</span>
 183 |     | <span class='unexecuted'>        balanceOf[to] = balanceOf[to] + value; // note: we don&#39;t need an overflow check here b/c balanceOf[to] &lt;= totalSupply and there is an overflow check below</span>
 184 |     | <span class='unexecuted'>        totalSupply = _add(totalSupply, value);</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>        emit Transfer(address(0), to, value);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>    function _mint(address to, uint256 value) private {</span>
 190 |     | <span class='unexecuted'>        require(to != address(0) &amp;&amp; to != address(this), &quot;Dai/invalid-address&quot;);</span>
 191 |     | <span class='unexecuted'>        balanceOf[to] = balanceOf[to] + value; // note: we don&#39;t need an overflow check here b/c balanceOf[to] &lt;= totalSupply and there is an overflow check below</span>
 192 |     | <span class='unexecuted'>        totalSupply = _add(totalSupply, value);</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='unexecuted'>        emit Transfer(address(0), to, value);</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>    function burn(address from, uint256 value) external {</span>
 198 |     | <span class='unexecuted'>        uint256 balance = balanceOf[from];</span>
 199 |     | <span class='unexecuted'>        require(balance &gt;= value, &quot;Dai/insufficient-balance&quot;);</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>        // if (from != msg.sender &amp;&amp; wards[msg.sender] != 1) {</span>
 202 |     | <span class='neutral'>        //   uint256 allowed = allowance[from][msg.sender];</span>
 203 |     | <span class='neutral'>        //   if (allowed != type(uint256).max) {</span>
 204 |     | <span class='neutral'>        //     require(allowed &gt;= value, &quot;Dai/insufficient-allowance&quot;);</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>        //     allowance[from][msg.sender] = allowed - value;</span>
 207 |     | <span class='neutral'>        //   }</span>
 208 |     | <span class='neutral'>        // }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>        balanceOf[from] = balance - value; // note: we don&#39;t need overflow checks b/c require(balance &gt;= value) and balance &lt;= totalSupply</span>
 211 |     | <span class='unexecuted'>        totalSupply = totalSupply - value;</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='unexecuted'>        emit Transfer(from, address(0), value);</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    // --- Approve by signature ---</span>
 217 |     | <span class='unexecuted'>    function permit(</span>
 218 |     | <span class='neutral'>        address owner,</span>
 219 |     | <span class='neutral'>        address spender,</span>
 220 |     | <span class='neutral'>        uint256 value,</span>
 221 |     | <span class='neutral'>        uint256 deadline,</span>
 222 |     | <span class='neutral'>        uint8 v,</span>
 223 |     | <span class='neutral'>        bytes32 r,</span>
 224 |     | <span class='neutral'>        bytes32 s</span>
 225 |     | <span class='neutral'>    ) external {</span>
 226 |     | <span class='unexecuted'>        require(block.timestamp &lt;= deadline, &quot;Dai/permit-expired&quot;);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>        uint256 chainId;</span>
 229 |     | <span class='neutral'>        assembly {</span>
 230 |     | <span class='unexecuted'>            chainId := chainid()</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>        bytes32 digest = keccak256(</span>
 234 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 235 |     | <span class='neutral'>                &quot;\x19\x01&quot;,</span>
 236 |     | <span class='unexecuted'>                chainId == deploymentChainId</span>
 237 |     | <span class='unexecuted'>                    ? _DOMAIN_SEPARATOR</span>
 238 |     | <span class='unexecuted'>                    : _calculateDomainSeparator(chainId),</span>
 239 |     | <span class='unexecuted'>                keccak256(</span>
 240 |     | <span class='unexecuted'>                    abi.encode(</span>
 241 |     | <span class='neutral'>                        PERMIT_TYPEHASH,</span>
 242 |     | <span class='unexecuted'>                        owner,</span>
 243 |     | <span class='unexecuted'>                        spender,</span>
 244 |     | <span class='unexecuted'>                        value,</span>
 245 |     | <span class='unexecuted'>                        nonces[owner]++,</span>
 246 |     | <span class='unexecuted'>                        deadline</span>
 247 |     | <span class='neutral'>                    )</span>
 248 |     | <span class='neutral'>                )</span>
 249 |     | <span class='neutral'>            )</span>
 250 |     | <span class='neutral'>        );</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>        require(</span>
 253 |     | <span class='unexecuted'>            owner != address(0) &amp;&amp; owner == ecrecover(digest, v, r, s),</span>
 254 |     | <span class='neutral'>            &quot;Dai/invalid-permit&quot;</span>
 255 |     | <span class='neutral'>        );</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>        allowance[owner][spender] = value;</span>
 258 |     | <span class='unexecuted'>        emit Approval(owner, spender, value);</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'>}</span>
 261 |     | <span class='unexecuted'></span>
 262 |     | <span class='neutral'>contract testUnipiot {</span>
 263 |     | <span class='neutral'>    UniswapV3Factory factory;</span>
 264 | *   | <span class='executed'>    UnipilotActiveFactory public UAF;</span>
 265 |     | <span class='neutral'>    UnipilotStrategy ST;</span>
 266 |     | <span class='neutral'>    indexfund IF;</span>
 267 |     | <span class='neutral'>    WETH9 weth;</span>
 268 | *   | <span class='executed'>    token public tk1;</span>
 269 | *   | <span class='executed'>    token public tk2;</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='unexecuted'>    constructor() {</span>
 272 |     | <span class='unexecuted'>        factory = new UniswapV3Factory();</span>
 273 |     | <span class='unexecuted'>        ST = new UnipilotStrategy(address(this));</span>
 274 |     | <span class='unexecuted'>        IF = new indexfund();</span>
 275 |     | <span class='unexecuted'>        weth = new WETH9();</span>
 276 |     | <span class='unexecuted'>        UAF = new UnipilotActiveFactory(</span>
 277 |     | <span class='unexecuted'>            address(factory),</span>
 278 |     | <span class='unexecuted'>            address(this),</span>
 279 |     | <span class='unexecuted'>            address(ST),</span>
 280 |     | <span class='unexecuted'>            address(IF),</span>
 281 |     | <span class='unexecuted'>            address(weth),</span>
 282 |     | <span class='unexecuted'>            1</span>
 283 |     | <span class='neutral'>        );</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 | *r  | <span class='executed'>    function createToken(address sender) public returns(address t0, address t1){</span>
 287 | *r  | <span class='executed'>        tk1 = new token(sender);</span>
 288 | *r  | <span class='executed'>        tk2 = new token(sender);</span>
 289 | *   | <span class='executed'>        t1 = address(tk1);</span>
 290 | *   | <span class='executed'>        t0 = address(tk2);</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'>}</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/ERC20Permit.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity &gt;=0.6.5 &lt;0.8.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>// import &quot;../token/ERC20/ERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>// import &quot;./IERC20Permit.sol&quot;;</span>
   7 |     | <span class='neutral'>// import &quot;../cryptography/ECDSA.sol&quot;;</span>
   8 |     | <span class='neutral'>// import &quot;../utils/Counters.sol&quot;;</span>
   9 |     | <span class='neutral'>// import &quot;./EIP712.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
  13 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
  16 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn&#39;t</span>
  17 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * _Available since v3.4._</span>
  20 |     | <span class='neutral'> */</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'> abstract contract EIP712 {</span>
  23 |     | <span class='neutral'>    /* solhint-disable var-name-mixedcase */</span>
  24 |     | <span class='neutral'>    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to</span>
  25 |     | <span class='neutral'>    // invalidate the cached domain separator if the chain id changes.</span>
  26 |     | <span class='neutral'>    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;</span>
  27 |     | <span class='neutral'>    uint256 private immutable _CACHED_CHAIN_ID;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    bytes32 private immutable _HASHED_NAME;</span>
  30 |     | <span class='neutral'>    bytes32 private immutable _HASHED_VERSION;</span>
  31 |     | <span class='neutral'>    bytes32 private immutable _TYPE_HASH;</span>
  32 |     | <span class='neutral'>    /* solhint-enable var-name-mixedcase */</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /**</span>
  35 |     | <span class='neutral'>     * @dev Initializes the domain separator and parameter caches.</span>
  36 |     | <span class='neutral'>     *</span>
  37 |     | <span class='neutral'>     * The meaning of `name` and `version` is specified in</span>
  38 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:</span>
  39 |     | <span class='neutral'>     *</span>
  40 |     | <span class='neutral'>     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.</span>
  41 |     | <span class='neutral'>     * - `version`: the current major version of the signing domain.</span>
  42 |     | <span class='neutral'>     *</span>
  43 |     | <span class='neutral'>     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart</span>
  44 |     | <span class='neutral'>     * contract upgrade].</span>
  45 |     | <span class='neutral'>     */</span>
  46 |     | <span class='unexecuted'>    constructor(string memory name, string memory version) {</span>
  47 |     | <span class='unexecuted'>        bytes32 hashedName = keccak256(bytes(name));</span>
  48 |     | <span class='unexecuted'>        bytes32 hashedVersion = keccak256(bytes(version));</span>
  49 |     | <span class='unexecuted'>        bytes32 typeHash = keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;);</span>
  50 |     | <span class='unexecuted'>        _HASHED_NAME = hashedName;</span>
  51 |     | <span class='unexecuted'>        _HASHED_VERSION = hashedVersion;</span>
  52 |     | <span class='unexecuted'>        _CACHED_CHAIN_ID = _getChainId();</span>
  53 |     | <span class='unexecuted'>        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);</span>
  54 |     | <span class='unexecuted'>        _TYPE_HASH = typeHash;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @dev Returns the domain separator for the current chain.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='unexecuted'>    function _domainSeparatorV4() internal view virtual returns (bytes32) {</span>
  61 |     | <span class='unexecuted'>        if (_getChainId() == _CACHED_CHAIN_ID) {</span>
  62 |     | <span class='unexecuted'>            return _CACHED_DOMAIN_SEPARATOR;</span>
  63 |     | <span class='neutral'>        } else {</span>
  64 |     | <span class='unexecuted'>            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {</span>
  69 |     | <span class='unexecuted'>        return keccak256(</span>
  70 |     | <span class='unexecuted'>            abi.encode(</span>
  71 |     | <span class='unexecuted'>                typeHash,</span>
  72 |     | <span class='unexecuted'>                name,</span>
  73 |     | <span class='unexecuted'>                version,</span>
  74 |     | <span class='unexecuted'>                _getChainId(),</span>
  75 |     | <span class='unexecuted'>                address(this)</span>
  76 |     | <span class='neutral'>            )</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this</span>
  82 |     | <span class='neutral'>     * function returns the hash of the fully encoded EIP712 message for this domain.</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:</span>
  85 |     | <span class='neutral'>     *</span>
  86 |     | <span class='neutral'>     * ```solidity</span>
  87 |     | <span class='neutral'>     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(</span>
  88 |     | <span class='neutral'>     *     keccak256(&quot;Mail(address to,string contents)&quot;),</span>
  89 |     | <span class='neutral'>     *     mailTo,</span>
  90 |     | <span class='neutral'>     *     keccak256(bytes(mailContents))</span>
  91 |     | <span class='neutral'>     * )));</span>
  92 |     | <span class='neutral'>     * address signer = ECDSA.recover(digest, signature);</span>
  93 |     | <span class='neutral'>     * ```</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='unexecuted'>    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {</span>
  96 |     | <span class='unexecuted'>        return keccak256(abi.encodePacked(&quot;\x19\x01&quot;, _domainSeparatorV4(), structHash));</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function _getChainId() private view returns (uint256 chainId) {</span>
 100 |     | <span class='neutral'>        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691</span>
 101 |     | <span class='neutral'>        // solhint-disable-next-line no-inline-assembly</span>
 102 |     | <span class='unexecuted'>        assembly {</span>
 103 |     | <span class='unexecuted'>            chainId := chainid()</span>
 104 |     | <span class='neutral'>        }</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'>}</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'></span>
 109 |     | <span class='neutral'>library SafeMath {</span>
 110 |     | <span class='neutral'>    /**</span>
 111 |     | <span class='neutral'>     * @dev Returns the addition of two unsigned integers, with an overflow flag.</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * _Available since v3.4._</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
 116 |     | <span class='neutral'>        uint256 c = a + b;</span>
 117 |     | <span class='neutral'>        if (c &lt; a) return (false, 0);</span>
 118 |     | <span class='neutral'>        return (true, c);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /**</span>
 122 |     | <span class='neutral'>     * @dev Returns the substraction of two unsigned integers, with an overflow flag.</span>
 123 |     | <span class='neutral'>     *</span>
 124 |     | <span class='neutral'>     * _Available since v3.4._</span>
 125 |     | <span class='neutral'>     */</span>
 126 |     | <span class='neutral'>    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
 127 |     | <span class='neutral'>        if (b &gt; a) return (false, 0);</span>
 128 |     | <span class='neutral'>        return (true, a - b);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * _Available since v3.4._</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='neutral'>    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
 137 |     | <span class='neutral'>        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the</span>
 138 |     | <span class='neutral'>        // benefit is lost if &#39;b&#39; is also tested.</span>
 139 |     | <span class='neutral'>        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522</span>
 140 |     | <span class='neutral'>        if (a == 0) return (true, 0);</span>
 141 |     | <span class='neutral'>        uint256 c = a * b;</span>
 142 |     | <span class='neutral'>        if (c / a != b) return (false, 0);</span>
 143 |     | <span class='neutral'>        return (true, c);</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    /**</span>
 147 |     | <span class='neutral'>     * @dev Returns the division of two unsigned integers, with a division by zero flag.</span>
 148 |     | <span class='neutral'>     *</span>
 149 |     | <span class='neutral'>     * _Available since v3.4._</span>
 150 |     | <span class='neutral'>     */</span>
 151 |     | <span class='neutral'>    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
 152 |     | <span class='neutral'>        if (b == 0) return (false, 0);</span>
 153 |     | <span class='neutral'>        return (true, a / b);</span>
 154 |     | <span class='neutral'>    }</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    /**</span>
 157 |     | <span class='neutral'>     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.</span>
 158 |     | <span class='neutral'>     *</span>
 159 |     | <span class='neutral'>     * _Available since v3.4._</span>
 160 |     | <span class='neutral'>     */</span>
 161 |     | <span class='neutral'>    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
 162 |     | <span class='neutral'>        if (b == 0) return (false, 0);</span>
 163 |     | <span class='neutral'>        return (true, a % b);</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    /**</span>
 167 |     | <span class='neutral'>     * @dev Returns the addition of two unsigned integers, reverting on</span>
 168 |     | <span class='neutral'>     * overflow.</span>
 169 |     | <span class='neutral'>     *</span>
 170 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `+` operator.</span>
 171 |     | <span class='neutral'>     *</span>
 172 |     | <span class='neutral'>     * Requirements:</span>
 173 |     | <span class='neutral'>     *</span>
 174 |     | <span class='neutral'>     * - Addition cannot overflow.</span>
 175 |     | <span class='neutral'>     */</span>
 176 |     | <span class='unexecuted'>    function add(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 177 |     | <span class='unexecuted'>        uint256 c = a + b;</span>
 178 |     | <span class='unexecuted'>        require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);</span>
 179 |     | <span class='unexecuted'>        return c;</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    /**</span>
 183 |     | <span class='neutral'>     * @dev Returns the subtraction of two unsigned integers, reverting on</span>
 184 |     | <span class='neutral'>     * overflow (when the result is negative).</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `-` operator.</span>
 187 |     | <span class='neutral'>     *</span>
 188 |     | <span class='neutral'>     * Requirements:</span>
 189 |     | <span class='neutral'>     *</span>
 190 |     | <span class='neutral'>     * - Subtraction cannot overflow.</span>
 191 |     | <span class='neutral'>     */</span>
 192 |     | <span class='unexecuted'>    function sub(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 193 |     | <span class='unexecuted'>        require(b &lt;= a, &quot;SafeMath: subtraction overflow&quot;);</span>
 194 |     | <span class='unexecuted'>        return a - b;</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>    /**</span>
 198 |     | <span class='neutral'>     * @dev Returns the multiplication of two unsigned integers, reverting on</span>
 199 |     | <span class='neutral'>     * overflow.</span>
 200 |     | <span class='neutral'>     *</span>
 201 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `*` operator.</span>
 202 |     | <span class='neutral'>     *</span>
 203 |     | <span class='neutral'>     * Requirements:</span>
 204 |     | <span class='neutral'>     *</span>
 205 |     | <span class='neutral'>     * - Multiplication cannot overflow.</span>
 206 |     | <span class='neutral'>     */</span>
 207 |     | <span class='neutral'>    function mul(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 208 |     | <span class='neutral'>        if (a == 0) return 0;</span>
 209 |     | <span class='neutral'>        uint256 c = a * b;</span>
 210 |     | <span class='neutral'>        require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);</span>
 211 |     | <span class='neutral'>        return c;</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    /**</span>
 215 |     | <span class='neutral'>     * @dev Returns the integer division of two unsigned integers, reverting on</span>
 216 |     | <span class='neutral'>     * division by zero. The result is rounded towards zero.</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `/` operator. Note: this function uses a</span>
 219 |     | <span class='neutral'>     * `revert` opcode (which leaves remaining gas untouched) while Solidity</span>
 220 |     | <span class='neutral'>     * uses an invalid opcode to revert (consuming all remaining gas).</span>
 221 |     | <span class='neutral'>     *</span>
 222 |     | <span class='neutral'>     * Requirements:</span>
 223 |     | <span class='neutral'>     *</span>
 224 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 225 |     | <span class='neutral'>     */</span>
 226 |     | <span class='neutral'>    function div(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 227 |     | <span class='neutral'>        require(b &gt; 0, &quot;SafeMath: division by zero&quot;);</span>
 228 |     | <span class='neutral'>        return a / b;</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    /**</span>
 232 |     | <span class='neutral'>     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),</span>
 233 |     | <span class='neutral'>     * reverting when dividing by zero.</span>
 234 |     | <span class='neutral'>     *</span>
 235 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `%` operator. This function uses a `revert`</span>
 236 |     | <span class='neutral'>     * opcode (which leaves remaining gas untouched) while Solidity uses an</span>
 237 |     | <span class='neutral'>     * invalid opcode to revert (consuming all remaining gas).</span>
 238 |     | <span class='neutral'>     *</span>
 239 |     | <span class='neutral'>     * Requirements:</span>
 240 |     | <span class='neutral'>     *</span>
 241 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 242 |     | <span class='neutral'>     */</span>
 243 |     | <span class='neutral'>    function mod(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 244 |     | <span class='neutral'>        require(b &gt; 0, &quot;SafeMath: modulo by zero&quot;);</span>
 245 |     | <span class='neutral'>        return a % b;</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /**</span>
 249 |     | <span class='neutral'>     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on</span>
 250 |     | <span class='neutral'>     * overflow (when the result is negative).</span>
 251 |     | <span class='neutral'>     *</span>
 252 |     | <span class='neutral'>     * CAUTION: This function is deprecated because it requires allocating memory for the error</span>
 253 |     | <span class='neutral'>     * message unnecessarily. For custom revert reasons use {trySub}.</span>
 254 |     | <span class='neutral'>     *</span>
 255 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `-` operator.</span>
 256 |     | <span class='neutral'>     *</span>
 257 |     | <span class='neutral'>     * Requirements:</span>
 258 |     | <span class='neutral'>     *</span>
 259 |     | <span class='neutral'>     * - Subtraction cannot overflow.</span>
 260 |     | <span class='neutral'>     */</span>
 261 |     | <span class='unexecuted'>    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {</span>
 262 |     | <span class='unexecuted'>        require(b &lt;= a, errorMessage);</span>
 263 |     | <span class='unexecuted'>        return a - b;</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /**</span>
 267 |     | <span class='neutral'>     * @dev Returns the integer division of two unsigned integers, reverting with custom message on</span>
 268 |     | <span class='neutral'>     * division by zero. The result is rounded towards zero.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * CAUTION: This function is deprecated because it requires allocating memory for the error</span>
 271 |     | <span class='neutral'>     * message unnecessarily. For custom revert reasons use {tryDiv}.</span>
 272 |     | <span class='neutral'>     *</span>
 273 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `/` operator. Note: this function uses a</span>
 274 |     | <span class='neutral'>     * `revert` opcode (which leaves remaining gas untouched) while Solidity</span>
 275 |     | <span class='neutral'>     * uses an invalid opcode to revert (consuming all remaining gas).</span>
 276 |     | <span class='neutral'>     *</span>
 277 |     | <span class='neutral'>     * Requirements:</span>
 278 |     | <span class='neutral'>     *</span>
 279 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 280 |     | <span class='neutral'>     */</span>
 281 |     | <span class='neutral'>    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {</span>
 282 |     | <span class='neutral'>        require(b &gt; 0, errorMessage);</span>
 283 |     | <span class='neutral'>        return a / b;</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /**</span>
 287 |     | <span class='neutral'>     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),</span>
 288 |     | <span class='neutral'>     * reverting with custom message when dividing by zero.</span>
 289 |     | <span class='neutral'>     *</span>
 290 |     | <span class='neutral'>     * CAUTION: This function is deprecated because it requires allocating memory for the error</span>
 291 |     | <span class='neutral'>     * message unnecessarily. For custom revert reasons use {tryMod}.</span>
 292 |     | <span class='neutral'>     *</span>
 293 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `%` operator. This function uses a `revert`</span>
 294 |     | <span class='neutral'>     * opcode (which leaves remaining gas untouched) while Solidity uses an</span>
 295 |     | <span class='neutral'>     * invalid opcode to revert (consuming all remaining gas).</span>
 296 |     | <span class='neutral'>     *</span>
 297 |     | <span class='neutral'>     * Requirements:</span>
 298 |     | <span class='neutral'>     *</span>
 299 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 300 |     | <span class='neutral'>     */</span>
 301 |     | <span class='neutral'>    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {</span>
 302 |     | <span class='neutral'>        require(b &gt; 0, errorMessage);</span>
 303 |     | <span class='neutral'>        return a % b;</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'>}</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='unexecuted'> library Counters {</span>
 309 |     | <span class='neutral'>    using SafeMath for uint256;</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    struct Counter {</span>
 312 |     | <span class='neutral'>        // This variable should never be directly accessed by users of the library: interactions must be restricted to</span>
 313 |     | <span class='neutral'>        // the library&#39;s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add</span>
 314 |     | <span class='neutral'>        // this feature: see https://github.com/ethereum/solidity/issues/4637</span>
 315 |     | <span class='neutral'>        uint256 _value; // default: 0</span>
 316 |     | <span class='neutral'>    }</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='unexecuted'>    function current(Counter storage counter) internal view returns (uint256) {</span>
 319 |     | <span class='unexecuted'>        return counter._value;</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='unexecuted'>    function increment(Counter storage counter) internal {</span>
 323 |     | <span class='neutral'>        // The {SafeMath} overflow check can be skipped here, see the comment at the top</span>
 324 |     | <span class='unexecuted'>        counter._value += 1;</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    function decrement(Counter storage counter) internal {</span>
 328 |     | <span class='neutral'>        counter._value = counter._value.sub(1);</span>
 329 |     | <span class='neutral'>    }</span>
 330 |     | <span class='neutral'>}</span>
 331 |     | <span class='unexecuted'></span>
 332 |     | <span class='neutral'>library ECDSA {</span>
 333 |     | <span class='neutral'>    /**</span>
 334 |     | <span class='neutral'>     * @dev Returns the address that signed a hashed message (`hash`) with</span>
 335 |     | <span class='neutral'>     * `signature`. This address can then be used for verification purposes.</span>
 336 |     | <span class='neutral'>     *</span>
 337 |     | <span class='neutral'>     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:</span>
 338 |     | <span class='neutral'>     * this function rejects them by requiring the `s` value to be in the lower</span>
 339 |     | <span class='neutral'>     * half order, and the `v` value to be either 27 or 28.</span>
 340 |     | <span class='neutral'>     *</span>
 341 |     | <span class='neutral'>     * IMPORTANT: `hash` _must_ be the result of a hash operation for the</span>
 342 |     | <span class='neutral'>     * verification to be secure: it is possible to craft signatures that</span>
 343 |     | <span class='neutral'>     * recover to arbitrary addresses for non-hashed data. A safe way to ensure</span>
 344 |     | <span class='neutral'>     * this is by receiving a hash of the original message (which may otherwise</span>
 345 |     | <span class='neutral'>     * be too long), and then calling {toEthSignedMessageHash} on it.</span>
 346 |     | <span class='neutral'>     */</span>
 347 |     | <span class='neutral'>    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {</span>
 348 |     | <span class='neutral'>        // Check the signature length</span>
 349 |     | <span class='neutral'>        if (signature.length != 65) {</span>
 350 |     | <span class='neutral'>            revert(&quot;ECDSA: invalid signature length&quot;);</span>
 351 |     | <span class='neutral'>        }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>        // Divide the signature in r, s and v variables</span>
 354 |     | <span class='neutral'>        bytes32 r;</span>
 355 |     | <span class='neutral'>        bytes32 s;</span>
 356 |     | <span class='neutral'>        uint8 v;</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>        // ecrecover takes the signature parameters, and the only way to get them</span>
 359 |     | <span class='neutral'>        // currently is to use assembly.</span>
 360 |     | <span class='neutral'>        // solhint-disable-next-line no-inline-assembly</span>
 361 |     | <span class='neutral'>        assembly {</span>
 362 |     | <span class='neutral'>            r := mload(add(signature, 0x20))</span>
 363 |     | <span class='neutral'>            s := mload(add(signature, 0x40))</span>
 364 |     | <span class='neutral'>            v := byte(0, mload(add(signature, 0x60)))</span>
 365 |     | <span class='neutral'>        }</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='neutral'>        return recover(hash, v, r, s);</span>
 368 |     | <span class='neutral'>    }</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>    /**</span>
 371 |     | <span class='neutral'>     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,</span>
 372 |     | <span class='neutral'>     * `r` and `s` signature fields separately.</span>
 373 |     | <span class='neutral'>     */</span>
 374 |     | <span class='unexecuted'>    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {</span>
 375 |     | <span class='neutral'>        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature</span>
 376 |     | <span class='neutral'>        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines</span>
 377 |     | <span class='neutral'>        // the valid range for s in (281): 0 &lt; s &lt; secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most</span>
 378 |     | <span class='neutral'>        // signatures from current libraries generate a unique signature with an s-value in the lower half order.</span>
 379 |     | <span class='neutral'>        //</span>
 380 |     | <span class='neutral'>        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value</span>
 381 |     | <span class='neutral'>        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or</span>
 382 |     | <span class='neutral'>        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept</span>
 383 |     | <span class='neutral'>        // these malleable signatures as well.</span>
 384 |     | <span class='unexecuted'>        require(uint256(s) &lt;= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, &quot;ECDSA: invalid signature &#39;s&#39; value&quot;);</span>
 385 |     | <span class='unexecuted'>        require(v == 27 || v == 28, &quot;ECDSA: invalid signature &#39;v&#39; value&quot;);</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='neutral'>        // If the signature is valid (and not malleable), return the signer address</span>
 388 |     | <span class='unexecuted'>        address signer = ecrecover(hash, v, r, s);</span>
 389 |     | <span class='unexecuted'>        require(signer != address(0), &quot;ECDSA: invalid signature&quot;);</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='unexecuted'>        return signer;</span>
 392 |     | <span class='neutral'>    }</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='neutral'>    /**</span>
 395 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Message, created from a `hash`. This</span>
 396 |     | <span class='neutral'>     * replicates the behavior of the</span>
 397 |     | <span class='neutral'>     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]</span>
 398 |     | <span class='neutral'>     * JSON-RPC method.</span>
 399 |     | <span class='neutral'>     *</span>
 400 |     | <span class='neutral'>     * See {recover}.</span>
 401 |     | <span class='neutral'>     */</span>
 402 |     | <span class='neutral'>    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {</span>
 403 |     | <span class='neutral'>        // 32 is the length in bytes of hash,</span>
 404 |     | <span class='neutral'>        // enforced by the type signature above</span>
 405 |     | <span class='neutral'>        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, hash));</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'>}</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'> interface IERC20Permit {</span>
 410 |     | <span class='neutral'>    /**</span>
 411 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over `owner`&#39;s tokens,</span>
 412 |     | <span class='neutral'>     * given `owner`&#39;s signed approval.</span>
 413 |     | <span class='neutral'>     *</span>
 414 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 415 |     | <span class='neutral'>     * ordering also apply here.</span>
 416 |     | <span class='neutral'>     *</span>
 417 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 418 |     | <span class='neutral'>     *</span>
 419 |     | <span class='neutral'>     * Requirements:</span>
 420 |     | <span class='neutral'>     *</span>
 421 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 422 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 423 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 424 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 425 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 426 |     | <span class='neutral'>     *</span>
 427 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 428 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 429 |     | <span class='neutral'>     * section].</span>
 430 |     | <span class='neutral'>     */</span>
 431 |     | <span class='neutral'>    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='neutral'>    /**</span>
 434 |     | <span class='neutral'>     * @dev Returns the current nonce for `owner`. This value must be</span>
 435 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 436 |     | <span class='neutral'>     *</span>
 437 |     | <span class='neutral'>     * Every successful call to {permit} increases ``owner``&#39;s nonce by one. This</span>
 438 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 439 |     | <span class='neutral'>     */</span>
 440 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='neutral'>    /**</span>
 443 |     | <span class='neutral'>     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.</span>
 444 |     | <span class='neutral'>     */</span>
 445 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 446 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 447 |     | <span class='neutral'>}</span>
 448 |     | <span class='neutral'></span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='neutral'> abstract contract Context {</span>
 451 |     | <span class='unexecuted'>    function _msgSender() internal view virtual returns (address payable) {</span>
 452 |     | <span class='unexecuted'>        return msg.sender;</span>
 453 |     | <span class='neutral'>    }</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes memory) {</span>
 456 |     | <span class='neutral'>        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691</span>
 457 |     | <span class='neutral'>        return msg.data;</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'>}</span>
 460 |     | <span class='neutral'></span>
 461 |     | <span class='neutral'>interface IERC20 {</span>
 462 |     | <span class='neutral'>    /**</span>
 463 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 464 |     | <span class='neutral'>     */</span>
 465 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>    /**</span>
 468 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 469 |     | <span class='neutral'>     */</span>
 470 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='neutral'>    /**</span>
 473 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `recipient`.</span>
 474 |     | <span class='neutral'>     *</span>
 475 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 476 |     | <span class='neutral'>     *</span>
 477 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 478 |     | <span class='neutral'>     */</span>
 479 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool);</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='neutral'>    /**</span>
 482 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 483 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 484 |     | <span class='neutral'>     * zero by default.</span>
 485 |     | <span class='neutral'>     *</span>
 486 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 487 |     | <span class='neutral'>     */</span>
 488 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='neutral'>    /**</span>
 491 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 492 |     | <span class='neutral'>     *</span>
 493 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 494 |     | <span class='neutral'>     *</span>
 495 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 496 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 497 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 498 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 499 |     | <span class='neutral'>     * desired value afterwards:</span>
 500 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 501 |     | <span class='neutral'>     *</span>
 502 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 503 |     | <span class='neutral'>     */</span>
 504 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>    /**</span>
 507 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `sender` to `recipient` using the</span>
 508 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 509 |     | <span class='neutral'>     * allowance.</span>
 510 |     | <span class='neutral'>     *</span>
 511 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 512 |     | <span class='neutral'>     *</span>
 513 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 514 |     | <span class='neutral'>     */</span>
 515 |     | <span class='neutral'>    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span>
 516 |     | <span class='neutral'></span>
 517 |     | <span class='neutral'>    /**</span>
 518 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 519 |     | <span class='neutral'>     * another (`to`).</span>
 520 |     | <span class='neutral'>     *</span>
 521 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 522 |     | <span class='neutral'>     */</span>
 523 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 524 |     | <span class='neutral'></span>
 525 |     | <span class='neutral'>    /**</span>
 526 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 527 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 528 |     | <span class='neutral'>     */</span>
 529 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 530 |     | <span class='neutral'>}</span>
 531 |     | <span class='neutral'></span>
 532 |     | <span class='unexecuted'></span>
 533 |     | <span class='neutral'>contract ERC20 is Context, IERC20 {</span>
 534 |     | <span class='neutral'>    using SafeMath for uint256;</span>
 535 |     | <span class='neutral'></span>
 536 |     | <span class='neutral'>    mapping (address =&gt; uint256) private _balances;</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='neutral'>    mapping (address =&gt; mapping (address =&gt; uint256)) private _allowances;</span>
 539 |     | <span class='neutral'></span>
 540 |     | <span class='unexecuted'>    uint256 public _totalSupply;</span>
 541 |     | <span class='neutral'></span>
 542 |     | <span class='neutral'>    string private _name;</span>
 543 |     | <span class='neutral'>    string private _symbol;</span>
 544 |     | <span class='neutral'>    uint8 private _decimals;</span>
 545 |     | <span class='neutral'></span>
 546 |     | <span class='neutral'>    /**</span>
 547 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with</span>
 548 |     | <span class='neutral'>     * a default value of 18.</span>
 549 |     | <span class='neutral'>     *</span>
 550 |     | <span class='neutral'>     * To select a different value for {decimals}, use {_setupDecimals}.</span>
 551 |     | <span class='neutral'>     *</span>
 552 |     | <span class='neutral'>     * All three of these values are immutable: they can only be set once during</span>
 553 |     | <span class='neutral'>     * construction.</span>
 554 |     | <span class='neutral'>     */</span>
 555 |     | <span class='unexecuted'>    constructor (string memory name_, string memory symbol_) {</span>
 556 |     | <span class='unexecuted'>        _name = name_;</span>
 557 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
 558 |     | <span class='unexecuted'>        _decimals = 18;</span>
 559 |     | <span class='neutral'>    }</span>
 560 |     | <span class='neutral'></span>
 561 |     | <span class='neutral'>    /**</span>
 562 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 563 |     | <span class='neutral'>     */</span>
 564 |     | <span class='unexecuted'>    function name() public view virtual returns (string memory) {</span>
 565 |     | <span class='unexecuted'>        return _name;</span>
 566 |     | <span class='neutral'>    }</span>
 567 |     | <span class='neutral'></span>
 568 |     | <span class='neutral'>    /**</span>
 569 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
 570 |     | <span class='neutral'>     * name.</span>
 571 |     | <span class='neutral'>     */</span>
 572 |     | <span class='unexecuted'>    function symbol() public view virtual returns (string memory) {</span>
 573 |     | <span class='unexecuted'>        return _symbol;</span>
 574 |     | <span class='neutral'>    }</span>
 575 |     | <span class='neutral'></span>
 576 |     | <span class='neutral'>    /**</span>
 577 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
 578 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
 579 |     | <span class='neutral'>     * be displayed to a user as `5,05` (`505 / 10 ** 2`).</span>
 580 |     | <span class='neutral'>     *</span>
 581 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
 582 |     | <span class='neutral'>     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is</span>
 583 |     | <span class='neutral'>     * called.</span>
 584 |     | <span class='neutral'>     *</span>
 585 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
 586 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
 587 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
 588 |     | <span class='neutral'>     */</span>
 589 |     | <span class='unexecuted'>    function decimals() public view virtual returns (uint8) {</span>
 590 |     | <span class='unexecuted'>        return _decimals;</span>
 591 |     | <span class='neutral'>    }</span>
 592 |     | <span class='neutral'></span>
 593 |     | <span class='neutral'>    /**</span>
 594 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
 595 |     | <span class='neutral'>     */</span>
 596 |     | <span class='unexecuted'>    function totalSupply() public view virtual override returns (uint256) {</span>
 597 |     | <span class='unexecuted'>        return _totalSupply;</span>
 598 |     | <span class='neutral'>    }</span>
 599 |     | <span class='neutral'></span>
 600 |     | <span class='neutral'>    /**</span>
 601 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 602 |     | <span class='neutral'>     */</span>
 603 |     | <span class='unexecuted'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 604 |     | <span class='unexecuted'>        return _balances[account];</span>
 605 |     | <span class='neutral'>    }</span>
 606 |     | <span class='neutral'></span>
 607 |     | <span class='neutral'>    /**</span>
 608 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 609 |     | <span class='neutral'>     *</span>
 610 |     | <span class='neutral'>     * Requirements:</span>
 611 |     | <span class='neutral'>     *</span>
 612 |     | <span class='neutral'>     * - `recipient` cannot be the zero address.</span>
 613 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 614 |     | <span class='neutral'>     */</span>
 615 |     | <span class='unexecuted'>    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {</span>
 616 |     | <span class='unexecuted'>        _transfer(_msgSender(), recipient, amount);</span>
 617 |     | <span class='unexecuted'>        return true;</span>
 618 |     | <span class='neutral'>    }</span>
 619 |     | <span class='neutral'></span>
 620 |     | <span class='neutral'>    /**</span>
 621 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 622 |     | <span class='neutral'>     */</span>
 623 |     | <span class='unexecuted'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 624 |     | <span class='unexecuted'>        return _allowances[owner][spender];</span>
 625 |     | <span class='neutral'>    }</span>
 626 |     | <span class='neutral'></span>
 627 |     | <span class='neutral'>    /**</span>
 628 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 629 |     | <span class='neutral'>     *</span>
 630 |     | <span class='neutral'>     * Requirements:</span>
 631 |     | <span class='neutral'>     *</span>
 632 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 633 |     | <span class='neutral'>     */</span>
 634 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 635 |     | <span class='unexecuted'>        _approve(_msgSender(), spender, amount);</span>
 636 |     | <span class='unexecuted'>        return true;</span>
 637 |     | <span class='neutral'>    }</span>
 638 |     | <span class='neutral'></span>
 639 |     | <span class='neutral'>    /**</span>
 640 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 641 |     | <span class='neutral'>     *</span>
 642 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 643 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 644 |     | <span class='neutral'>     *</span>
 645 |     | <span class='neutral'>     * Requirements:</span>
 646 |     | <span class='neutral'>     *</span>
 647 |     | <span class='neutral'>     * - `sender` and `recipient` cannot be the zero address.</span>
 648 |     | <span class='neutral'>     * - `sender` must have a balance of at least `amount`.</span>
 649 |     | <span class='neutral'>     * - the caller must have allowance for ``sender``&#39;s tokens of at least</span>
 650 |     | <span class='neutral'>     * `amount`.</span>
 651 |     | <span class='neutral'>     */</span>
 652 |     | <span class='unexecuted'>    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {</span>
 653 |     | <span class='unexecuted'>        _transfer(sender, recipient, amount);</span>
 654 |     | <span class='unexecuted'>        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, &quot;ERC20: transfer amount exceeds allowance&quot;));</span>
 655 |     | <span class='unexecuted'>        return true;</span>
 656 |     | <span class='neutral'>    }</span>
 657 |     | <span class='neutral'></span>
 658 |     | <span class='neutral'>    /**</span>
 659 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 660 |     | <span class='neutral'>     *</span>
 661 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 662 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 663 |     | <span class='neutral'>     *</span>
 664 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 665 |     | <span class='neutral'>     *</span>
 666 |     | <span class='neutral'>     * Requirements:</span>
 667 |     | <span class='neutral'>     *</span>
 668 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 669 |     | <span class='neutral'>     */</span>
 670 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 671 |     | <span class='unexecuted'>        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));</span>
 672 |     | <span class='unexecuted'>        return true;</span>
 673 |     | <span class='neutral'>    }</span>
 674 |     | <span class='neutral'></span>
 675 |     | <span class='neutral'>    /**</span>
 676 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 677 |     | <span class='neutral'>     *</span>
 678 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 679 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 680 |     | <span class='neutral'>     *</span>
 681 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 682 |     | <span class='neutral'>     *</span>
 683 |     | <span class='neutral'>     * Requirements:</span>
 684 |     | <span class='neutral'>     *</span>
 685 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 686 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 687 |     | <span class='neutral'>     * `subtractedValue`.</span>
 688 |     | <span class='neutral'>     */</span>
 689 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 690 |     | <span class='unexecuted'>        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, &quot;ERC20: decreased allowance below zero&quot;));</span>
 691 |     | <span class='unexecuted'>        return true;</span>
 692 |     | <span class='neutral'>    }</span>
 693 |     | <span class='neutral'></span>
 694 |     | <span class='neutral'>    /**</span>
 695 |     | <span class='neutral'>     * @dev Moves tokens `amount` from `sender` to `recipient`.</span>
 696 |     | <span class='neutral'>     *</span>
 697 |     | <span class='neutral'>     * This is internal function is equivalent to {transfer}, and can be used to</span>
 698 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 699 |     | <span class='neutral'>     *</span>
 700 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 701 |     | <span class='neutral'>     *</span>
 702 |     | <span class='neutral'>     * Requirements:</span>
 703 |     | <span class='neutral'>     *</span>
 704 |     | <span class='neutral'>     * - `sender` cannot be the zero address.</span>
 705 |     | <span class='neutral'>     * - `recipient` cannot be the zero address.</span>
 706 |     | <span class='neutral'>     * - `sender` must have a balance of at least `amount`.</span>
 707 |     | <span class='neutral'>     */</span>
 708 |     | <span class='unexecuted'>    function _transfer(address sender, address recipient, uint256 amount) internal virtual {</span>
 709 |     | <span class='unexecuted'>        require(sender != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 710 |     | <span class='unexecuted'>        require(recipient != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 711 |     | <span class='neutral'></span>
 712 |     | <span class='unexecuted'>        _beforeTokenTransfer(sender, recipient, amount);</span>
 713 |     | <span class='neutral'></span>
 714 |     | <span class='unexecuted'>        _balances[sender] = _balances[sender].sub(amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 715 |     | <span class='unexecuted'>        _balances[recipient] = _balances[recipient].add(amount);</span>
 716 |     | <span class='unexecuted'>        emit Transfer(sender, recipient, amount);</span>
 717 |     | <span class='neutral'>    }</span>
 718 |     | <span class='neutral'></span>
 719 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 720 |     | <span class='neutral'>     * the total supply.</span>
 721 |     | <span class='neutral'>     *</span>
 722 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 723 |     | <span class='neutral'>     *</span>
 724 |     | <span class='neutral'>     * Requirements:</span>
 725 |     | <span class='neutral'>     *</span>
 726 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 727 |     | <span class='neutral'>     */</span>
 728 |     | <span class='unexecuted'>    function _mint(address account, uint256 amount) internal virtual {</span>
 729 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 730 |     | <span class='neutral'></span>
 731 |     | <span class='unexecuted'>        _beforeTokenTransfer(address(0), account, amount);</span>
 732 |     | <span class='neutral'></span>
 733 |     | <span class='unexecuted'>        _totalSupply = _totalSupply.add(amount);</span>
 734 |     | <span class='unexecuted'>        _balances[account] = _balances[account].add(amount);</span>
 735 |     | <span class='unexecuted'>        emit Transfer(address(0), account, amount);</span>
 736 |     | <span class='neutral'>    }</span>
 737 |     | <span class='neutral'></span>
 738 |     | <span class='neutral'>    /**</span>
 739 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 740 |     | <span class='neutral'>     * total supply.</span>
 741 |     | <span class='neutral'>     *</span>
 742 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 743 |     | <span class='neutral'>     *</span>
 744 |     | <span class='neutral'>     * Requirements:</span>
 745 |     | <span class='neutral'>     *</span>
 746 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 747 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 748 |     | <span class='neutral'>     */</span>
 749 |     | <span class='unexecuted'>    function _burn(address account, uint256 amount) internal virtual {</span>
 750 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 751 |     | <span class='neutral'></span>
 752 |     | <span class='unexecuted'>        _beforeTokenTransfer(account, address(0), amount);</span>
 753 |     | <span class='neutral'></span>
 754 |     | <span class='unexecuted'>        _balances[account] = _balances[account].sub(amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 755 |     | <span class='unexecuted'>        _totalSupply = _totalSupply.sub(amount);</span>
 756 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 757 |     | <span class='neutral'>    }</span>
 758 |     | <span class='neutral'></span>
 759 |     | <span class='neutral'>    /**</span>
 760 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 761 |     | <span class='neutral'>     *</span>
 762 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 763 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 764 |     | <span class='neutral'>     *</span>
 765 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 766 |     | <span class='neutral'>     *</span>
 767 |     | <span class='neutral'>     * Requirements:</span>
 768 |     | <span class='neutral'>     *</span>
 769 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 770 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 771 |     | <span class='neutral'>     */</span>
 772 |     | <span class='unexecuted'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 773 |     | <span class='unexecuted'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 774 |     | <span class='unexecuted'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 775 |     | <span class='neutral'></span>
 776 |     | <span class='unexecuted'>        _allowances[owner][spender] = amount;</span>
 777 |     | <span class='unexecuted'>        emit Approval(owner, spender, amount);</span>
 778 |     | <span class='neutral'>    }</span>
 779 |     | <span class='neutral'></span>
 780 |     | <span class='neutral'>    /**</span>
 781 |     | <span class='neutral'>     * @dev Sets {decimals} to a value other than the default one of 18.</span>
 782 |     | <span class='neutral'>     *</span>
 783 |     | <span class='neutral'>     * WARNING: This function should only be called from the constructor. Most</span>
 784 |     | <span class='neutral'>     * applications that interact with token contracts will not expect</span>
 785 |     | <span class='neutral'>     * {decimals} to ever change, and may work incorrectly if it does.</span>
 786 |     | <span class='neutral'>     */</span>
 787 |     | <span class='neutral'>    function _setupDecimals(uint8 decimals_) internal virtual {</span>
 788 |     | <span class='neutral'>        _decimals = decimals_;</span>
 789 |     | <span class='neutral'>    }</span>
 790 |     | <span class='neutral'></span>
 791 |     | <span class='neutral'>    /**</span>
 792 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 793 |     | <span class='neutral'>     * minting and burning.</span>
 794 |     | <span class='neutral'>     *</span>
 795 |     | <span class='neutral'>     * Calling conditions:</span>
 796 |     | <span class='neutral'>     *</span>
 797 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 798 |     | <span class='neutral'>     * will be to transferred to `to`.</span>
 799 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 800 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 801 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 802 |     | <span class='neutral'>     *</span>
 803 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 804 |     | <span class='neutral'>     */</span>
 805 |     | <span class='unexecuted'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }</span>
 806 |     | <span class='neutral'>}</span>
 807 |     | <span class='neutral'></span>
 808 |     | <span class='neutral'>abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {</span>
 809 |     | <span class='neutral'>    using Counters for Counters.Counter;</span>
 810 |     | <span class='neutral'></span>
 811 |     | <span class='neutral'>    mapping (address =&gt; Counters.Counter) private _nonces;</span>
 812 |     | <span class='neutral'></span>
 813 |     | <span class='neutral'>    // solhint-disable-next-line var-name-mixedcase</span>
 814 |     | <span class='unexecuted'>    bytes32 private immutable _PERMIT_TYPEHASH = keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span>
 815 |     | <span class='neutral'></span>
 816 |     | <span class='neutral'>    /**</span>
 817 |     | <span class='neutral'>     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `&quot;1&quot;`.</span>
 818 |     | <span class='neutral'>     *</span>
 819 |     | <span class='neutral'>     * It&#39;s a good idea to use the same `name` that is defined as the ERC20 token name.</span>
 820 |     | <span class='neutral'>     */</span>
 821 |     | <span class='unexecuted'>    constructor(string memory name) EIP712(name, &quot;1&quot;) {</span>
 822 |     | <span class='neutral'>    }</span>
 823 |     | <span class='neutral'></span>
 824 |     | <span class='neutral'>    /**</span>
 825 |     | <span class='neutral'>     * @dev See {IERC20Permit-permit}.</span>
 826 |     | <span class='neutral'>     */</span>
 827 |     | <span class='unexecuted'>    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {</span>
 828 |     | <span class='neutral'>        // solhint-disable-next-line not-rely-on-time</span>
 829 |     | <span class='unexecuted'>        require(block.timestamp &lt;= deadline, &quot;ERC20Permit: expired deadline&quot;);</span>
 830 |     | <span class='neutral'></span>
 831 |     | <span class='unexecuted'>        bytes32 structHash = keccak256(</span>
 832 |     | <span class='unexecuted'>            abi.encode(</span>
 833 |     | <span class='unexecuted'>                _PERMIT_TYPEHASH,</span>
 834 |     | <span class='unexecuted'>                owner,</span>
 835 |     | <span class='unexecuted'>                spender,</span>
 836 |     | <span class='unexecuted'>                value,</span>
 837 |     | <span class='unexecuted'>                _nonces[owner].current(),</span>
 838 |     | <span class='unexecuted'>                deadline</span>
 839 |     | <span class='neutral'>            )</span>
 840 |     | <span class='neutral'>        );</span>
 841 |     | <span class='neutral'></span>
 842 |     | <span class='unexecuted'>        bytes32 hash = _hashTypedDataV4(structHash);</span>
 843 |     | <span class='neutral'></span>
 844 |     | <span class='unexecuted'>        address signer = ECDSA.recover(hash, v, r, s);</span>
 845 |     | <span class='unexecuted'>        require(signer == owner, &quot;ERC20Permit: invalid signature&quot;);</span>
 846 |     | <span class='neutral'></span>
 847 |     | <span class='unexecuted'>        _nonces[owner].increment();</span>
 848 |     | <span class='unexecuted'>        _approve(owner, spender, value);</span>
 849 |     | <span class='neutral'>    }</span>
 850 |     | <span class='neutral'></span>
 851 |     | <span class='neutral'>    /**</span>
 852 |     | <span class='neutral'>     * @dev See {IERC20Permit-nonces}.</span>
 853 |     | <span class='neutral'>     */</span>
 854 |     | <span class='unexecuted'>    function nonces(address owner) public view override returns (uint256) {</span>
 855 |     | <span class='unexecuted'>        return _nonces[owner].current();</span>
 856 |     | <span class='neutral'>    }</span>
 857 |     | <span class='neutral'></span>
 858 |     | <span class='neutral'>    /**</span>
 859 |     | <span class='neutral'>     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.</span>
 860 |     | <span class='neutral'>     */</span>
 861 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 862 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() external view override returns (bytes32) {</span>
 863 |     | <span class='unexecuted'>        return _domainSeparatorV4();</span>
 864 |     | <span class='neutral'>    }</span>
 865 |     | <span class='neutral'>}</span>
 866 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/LiquidityAmounts.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./libraries/FullMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./libraries/FixedPoint96.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @title Liquidity amount functions</span>
   8 |     | <span class='unexecuted'>/// @notice Provides functions for computing liquidity amounts from token amounts and prices</span>
   9 |     | <span class='neutral'>library LiquidityAmounts {</span>
  10 |     | <span class='neutral'>    /// @notice Downcasts uint256 to uint128</span>
  11 |     | <span class='neutral'>    /// @param x The uint258 to be downcasted</span>
  12 |     | <span class='neutral'>    /// @return y The passed value, downcasted to uint128</span>
  13 |     | <span class='unexecuted'>    function toUint128(uint256 x) private pure returns (uint128 y) {</span>
  14 |     | <span class='unexecuted'>        require((y = uint128(x)) == x);</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range</span>
  18 |     | <span class='neutral'>    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))</span>
  19 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
  20 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
  21 |     | <span class='neutral'>    /// @param amount0 The amount0 being sent in</span>
  22 |     | <span class='neutral'>    /// @return liquidity The amount of returned liquidity</span>
  23 |     | <span class='unexecuted'>    function getLiquidityForAmount0(</span>
  24 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  25 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  26 |     | <span class='neutral'>        uint256 amount0</span>
  27 |     | <span class='unexecuted'>    ) internal pure returns (uint128 liquidity) {</span>
  28 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  29 |     | <span class='unexecuted'>        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);</span>
  30 |     | <span class='unexecuted'>        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range</span>
  34 |     | <span class='neutral'>    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).</span>
  35 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
  36 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
  37 |     | <span class='neutral'>    /// @param amount1 The amount1 being sent in</span>
  38 |     | <span class='neutral'>    /// @return liquidity The amount of returned liquidity</span>
  39 |     | <span class='unexecuted'>    function getLiquidityForAmount1(</span>
  40 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  41 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  42 |     | <span class='neutral'>        uint256 amount1</span>
  43 |     | <span class='unexecuted'>    ) internal pure returns (uint128 liquidity) {</span>
  44 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  45 |     | <span class='unexecuted'>        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current</span>
  49 |     | <span class='neutral'>    /// pool prices and the prices at the tick boundaries</span>
  50 |     | <span class='neutral'>    /// @param sqrtRatioX96 A sqrt price representing the current pool prices</span>
  51 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
  52 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
  53 |     | <span class='neutral'>    /// @param amount0 The amount of token0 being sent in</span>
  54 |     | <span class='neutral'>    /// @param amount1 The amount of token1 being sent in</span>
  55 |     | <span class='neutral'>    /// @return liquidity The maximum amount of liquidity received</span>
  56 |     | <span class='unexecuted'>    function getLiquidityForAmounts(</span>
  57 |     | <span class='neutral'>        uint160 sqrtRatioX96,</span>
  58 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  59 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  60 |     | <span class='neutral'>        uint256 amount0,</span>
  61 |     | <span class='neutral'>        uint256 amount1</span>
  62 |     | <span class='unexecuted'>    ) internal pure returns (uint128 liquidity) {</span>
  63 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        if (sqrtRatioX96 &lt;= sqrtRatioAX96) {</span>
  66 |     | <span class='unexecuted'>            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);</span>
  67 |     | <span class='unexecuted'>        } else if (sqrtRatioX96 &lt; sqrtRatioBX96) {</span>
  68 |     | <span class='unexecuted'>            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);</span>
  69 |     | <span class='unexecuted'>            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>            liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;</span>
  72 |     | <span class='neutral'>        } else {</span>
  73 |     | <span class='unexecuted'>            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range</span>
  78 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
  79 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
  80 |     | <span class='neutral'>    /// @param liquidity The liquidity being valued</span>
  81 |     | <span class='neutral'>    /// @return amount0 The amount of token0</span>
  82 |     | <span class='unexecuted'>    function getAmount0ForLiquidity(</span>
  83 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  84 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  85 |     | <span class='neutral'>        uint128 liquidity</span>
  86 |     | <span class='unexecuted'>    ) internal pure returns (uint256 amount0) {</span>
  87 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        return</span>
  90 |     | <span class='unexecuted'>            FullMath.mulDiv(</span>
  91 |     | <span class='unexecuted'>                uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION,</span>
  92 |     | <span class='unexecuted'>                sqrtRatioBX96 - sqrtRatioAX96,</span>
  93 |     | <span class='unexecuted'>                sqrtRatioBX96</span>
  94 |     | <span class='unexecuted'>            ) / sqrtRatioAX96;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range</span>
  98 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
  99 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
 100 |     | <span class='neutral'>    /// @param liquidity The liquidity being valued</span>
 101 |     | <span class='neutral'>    /// @return amount1 The amount of token1</span>
 102 |     | <span class='unexecuted'>    function getAmount1ForLiquidity(</span>
 103 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 104 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 105 |     | <span class='neutral'>        uint128 liquidity</span>
 106 |     | <span class='unexecuted'>    ) internal pure returns (uint256 amount1) {</span>
 107 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current</span>
 113 |     | <span class='neutral'>    /// pool prices and the prices at the tick boundaries</span>
 114 |     | <span class='neutral'>    /// @param sqrtRatioX96 A sqrt price representing the current pool prices</span>
 115 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
 116 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
 117 |     | <span class='neutral'>    /// @param liquidity The liquidity being valued</span>
 118 |     | <span class='neutral'>    /// @return amount0 The amount of token0</span>
 119 |     | <span class='neutral'>    /// @return amount1 The amount of token1</span>
 120 |     | <span class='unexecuted'>    function getAmountsForLiquidity(</span>
 121 |     | <span class='neutral'>        uint160 sqrtRatioX96,</span>
 122 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 123 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 124 |     | <span class='neutral'>        uint128 liquidity</span>
 125 |     | <span class='unexecuted'>    ) internal pure returns (uint256 amount0, uint256 amount1) {</span>
 126 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        if (sqrtRatioX96 &lt;= sqrtRatioAX96) {</span>
 129 |     | <span class='unexecuted'>            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);</span>
 130 |     | <span class='unexecuted'>        } else if (sqrtRatioX96 &lt; sqrtRatioBX96) {</span>
 131 |     | <span class='unexecuted'>            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);</span>
 132 |     | <span class='unexecuted'>            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);</span>
 133 |     | <span class='neutral'>        } else {</span>
 134 |     | <span class='unexecuted'>            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);</span>
 135 |     | <span class='neutral'>        }</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'>}</span>
 138 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/NoDelegateCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Prevents delegatecall to a contract</span>
  5 |     | <span class='neutral'>/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract</span>
  6 |     | <span class='neutral'>abstract contract NoDelegateCall {</span>
  7 |     | <span class='neutral'>    /// @dev The original address of this contract</span>
  8 |     | <span class='neutral'>    address private immutable original;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    constructor() {</span>
 11 |     | <span class='neutral'>        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.</span>
 12 |     | <span class='neutral'>        // In other words, this variable won&#39;t change when it&#39;s checked at runtime.</span>
 13 |     | <span class='unexecuted'>        original = address(this);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,</span>
 17 |     | <span class='neutral'>    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.</span>
 18 | *r  | <span class='executed'>    function checkNotDelegateCall() private view {</span>
 19 | *r  | <span class='executed'>        require(address(this) == original);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /// @notice Prevents delegatecall into the modified method</span>
 23 |     | <span class='neutral'>    modifier noDelegateCall() {</span>
 24 | *r  | <span class='executed'>        checkNotDelegateCall();</span>
 25 | *   | <span class='executed'>        _;</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/PositionKey.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='unexecuted'></span>
  4 |     | <span class='neutral'>library PositionKey {</span>
  5 |     | <span class='neutral'>    /// @dev Returns the key of the position in the core library</span>
  6 |     | <span class='unexecuted'>    function compute(</span>
  7 |     | <span class='neutral'>        address owner,</span>
  8 |     | <span class='neutral'>        int24 tickLower,</span>
  9 |     | <span class='neutral'>        int24 tickUpper</span>
 10 |     | <span class='unexecuted'>    ) internal pure returns (bytes32) {</span>
 11 |     | <span class='unexecuted'>        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/UniswapV3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV3Factory.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./UniswapV3PoolDeployer.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./NoDelegateCall.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>import &quot;./UniswapV3Pool.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/// @title Canonical Uniswap V3 factory</span>
 12 | *r  | <span class='executed'>/// @notice Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees</span>
 13 |     | <span class='neutral'>contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall {</span>
 14 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 15 | *   | <span class='executed'>    address public override owner;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 18 | *   | <span class='executed'>    mapping(uint24 =&gt; int24) public override feeAmountTickSpacing;</span>
 19 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 20 | *r  | <span class='executed'>    mapping(address =&gt; mapping(address =&gt; mapping(uint24 =&gt; address))) public override getPool;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    constructor() {</span>
 23 |     | <span class='unexecuted'>        owner = msg.sender;</span>
 24 |     | <span class='unexecuted'>        emit OwnerChanged(address(0), msg.sender);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        feeAmountTickSpacing[500] = 10;</span>
 27 |     | <span class='unexecuted'>        emit FeeAmountEnabled(500, 10);</span>
 28 |     | <span class='unexecuted'>        feeAmountTickSpacing[3000] = 60;</span>
 29 |     | <span class='unexecuted'>        emit FeeAmountEnabled(3000, 60);</span>
 30 |     | <span class='unexecuted'>        feeAmountTickSpacing[10000] = 200;</span>
 31 |     | <span class='unexecuted'>        emit FeeAmountEnabled(10000, 200);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 35 | *r  | <span class='executed'>    function createPool(</span>
 36 |     | <span class='neutral'>        address tokenA,</span>
 37 |     | <span class='neutral'>        address tokenB,</span>
 38 |     | <span class='neutral'>        uint24 fee</span>
 39 | *r  | <span class='executed'>    ) external override noDelegateCall returns (address pool) {</span>
 40 | *r  | <span class='executed'>        require(tokenA != tokenB);</span>
 41 | *r  | <span class='executed'>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span>
 42 | *r  | <span class='executed'>        require(token0 != address(0));</span>
 43 | *r  | <span class='executed'>        int24 tickSpacing = feeAmountTickSpacing[fee];</span>
 44 | *r  | <span class='executed'>        require(tickSpacing != 0);</span>
 45 | *   | <span class='executed'>        require(getPool[token0][token1][fee] == address(0));</span>
 46 | *   | <span class='executed'>        pool = deploy(address(this), token0, token1, fee, tickSpacing);</span>
 47 | *   | <span class='executed'>        getPool[token0][token1][fee] = pool;</span>
 48 |     | <span class='neutral'>        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses</span>
 49 | *   | <span class='executed'>        getPool[token1][token0][fee] = pool;</span>
 50 | *   | <span class='executed'>        emit PoolCreated(token0, token1, fee, tickSpacing, pool);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 54 | r   | <span class='reverted'>    function setOwner(address _owner) external override {</span>
 55 | r   | <span class='reverted'>        require(msg.sender == owner);</span>
 56 |     | <span class='unexecuted'>        emit OwnerChanged(owner, _owner);</span>
 57 |     | <span class='unexecuted'>        owner = _owner;</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 61 | r   | <span class='reverted'>    function enableFeeAmount(uint24 fee, int24 tickSpacing) public override {</span>
 62 | r   | <span class='reverted'>        require(msg.sender == owner);</span>
 63 |     | <span class='unexecuted'>        require(fee &lt; 1000000);</span>
 64 |     | <span class='neutral'>        // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that</span>
 65 |     | <span class='neutral'>        // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick</span>
 66 |     | <span class='neutral'>        // 16384 ticks represents a &gt;5x price change with ticks of 1 bips</span>
 67 |     | <span class='unexecuted'>        require(tickSpacing &gt; 0 &amp;&amp; tickSpacing &lt; 16384);</span>
 68 |     | <span class='unexecuted'>        require(feeAmountTickSpacing[fee] == 0);</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='unexecuted'>        feeAmountTickSpacing[fee] = tickSpacing;</span>
 71 |     | <span class='unexecuted'>        emit FeeAmountEnabled(fee, tickSpacing);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'>}</span>
 74 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/UniswapV3Pool.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
    2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV3Pool.sol&quot;;</span>
    5 |     | <span class='neutral'></span>
    6 |     | <span class='neutral'>import &quot;./NoDelegateCall.sol&quot;;</span>
    7 |     | <span class='neutral'></span>
    8 |     | <span class='neutral'>import &quot;./libraries/LowGasSafeMath.sol&quot;;</span>
    9 |     | <span class='neutral'>import &quot;./libraries/SafeCast.sol&quot;;</span>
   10 |     | <span class='neutral'>import &quot;./libraries/Tick.sol&quot;;</span>
   11 |     | <span class='neutral'>import &quot;./libraries/TickBitmap.sol&quot;;</span>
   12 |     | <span class='neutral'>import &quot;./libraries/Position.sol&quot;;</span>
   13 |     | <span class='neutral'>import &quot;./libraries/Oracle.sol&quot;;</span>
   14 |     | <span class='neutral'></span>
   15 |     | <span class='neutral'>import &quot;./libraries/FullMath.sol&quot;;</span>
   16 |     | <span class='neutral'>import &quot;./libraries/FixedPoint128.sol&quot;;</span>
   17 |     | <span class='neutral'>import &quot;./libraries/TransferHelper.sol&quot;;</span>
   18 |     | <span class='neutral'>import &quot;./libraries/TickMath.sol&quot;;</span>
   19 |     | <span class='neutral'>import &quot;./libraries/LiquidityMath.sol&quot;;</span>
   20 |     | <span class='neutral'>import &quot;./libraries/SqrtPriceMath.sol&quot;;</span>
   21 |     | <span class='neutral'>import &quot;./libraries/SwapMath.sol&quot;;</span>
   22 |     | <span class='neutral'></span>
   23 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV3PoolDeployer.sol&quot;;</span>
   24 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV3Factory.sol&quot;;</span>
   25 |     | <span class='neutral'>import &quot;./interfaces/IERC20Minimal.sol&quot;;</span>
   26 |     | <span class='neutral'>import &quot;./interfaces/callback/IUniswapV3MintCallback.sol&quot;;</span>
   27 |     | <span class='neutral'>import &quot;./interfaces/callback/IUniswapV3SwapCallback.sol&quot;;</span>
   28 |     | <span class='neutral'>import &quot;./interfaces/callback/IUniswapV3FlashCallback.sol&quot;;</span>
   29 |     | <span class='unexecuted'></span>
   30 |     | <span class='neutral'>contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall {</span>
   31 |     | <span class='neutral'>    using LowGasSafeMath for uint256;</span>
   32 |     | <span class='neutral'>    using LowGasSafeMath for int256;</span>
   33 |     | <span class='neutral'>    using SafeCast for uint256;</span>
   34 |     | <span class='neutral'>    using SafeCast for int256;</span>
   35 |     | <span class='neutral'>    using Tick for mapping(int24 =&gt; Tick.Info);</span>
   36 |     | <span class='neutral'>    using TickBitmap for mapping(int16 =&gt; uint256);</span>
   37 |     | <span class='neutral'>    using Position for mapping(bytes32 =&gt; Position.Info);</span>
   38 |     | <span class='neutral'>    using Position for Position.Info;</span>
   39 |     | <span class='neutral'>    using Oracle for Oracle.Observation[65535];</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
   42 |     | <span class='unexecuted'>    address public immutable override factory;</span>
   43 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
   44 |     | <span class='unexecuted'>    address public immutable override token0;</span>
   45 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
   46 |     | <span class='unexecuted'>    address public immutable override token1;</span>
   47 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
   48 |     | <span class='unexecuted'>    uint24 public immutable override fee;</span>
   49 |     | <span class='neutral'></span>
   50 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
   51 |     | <span class='unexecuted'>    int24 public immutable override tickSpacing;</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
   54 |     | <span class='unexecuted'>    uint128 public immutable override maxLiquidityPerTick;</span>
   55 |     | <span class='neutral'></span>
   56 |     | <span class='neutral'>    struct Slot0 {</span>
   57 |     | <span class='neutral'>        // the current price</span>
   58 |     | <span class='neutral'>        uint160 sqrtPriceX96;</span>
   59 |     | <span class='neutral'>        // the current tick</span>
   60 |     | <span class='neutral'>        int24 tick;</span>
   61 |     | <span class='neutral'>        // the most-recently updated index of the observations array</span>
   62 |     | <span class='neutral'>        uint16 observationIndex;</span>
   63 |     | <span class='neutral'>        // the current maximum number of observations that are being stored</span>
   64 |     | <span class='neutral'>        uint16 observationCardinality;</span>
   65 |     | <span class='neutral'>        // the next maximum number of observations to store, triggered in observations.write</span>
   66 |     | <span class='neutral'>        uint16 observationCardinalityNext;</span>
   67 |     | <span class='neutral'>        // the current protocol fee as a percentage of the swap fee taken on withdrawal</span>
   68 |     | <span class='neutral'>        // represented as an integer denominator (1/x)%</span>
   69 |     | <span class='neutral'>        uint8 feeProtocol;</span>
   70 |     | <span class='neutral'>        // whether the pool is locked</span>
   71 |     | <span class='neutral'>        bool unlocked;</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
   74 |     | <span class='unexecuted'>    Slot0 public override slot0;</span>
   75 |     | <span class='neutral'></span>
   76 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
   77 |     | <span class='unexecuted'>    uint256 public override feeGrowthGlobal0X128;</span>
   78 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
   79 |     | <span class='unexecuted'>    uint256 public override feeGrowthGlobal1X128;</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    // accumulated protocol fees in token0/token1 units</span>
   82 |     | <span class='neutral'>    struct ProtocolFees {</span>
   83 |     | <span class='neutral'>        uint128 token0;</span>
   84 |     | <span class='neutral'>        uint128 token1;</span>
   85 |     | <span class='neutral'>    }</span>
   86 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
   87 |     | <span class='unexecuted'>    ProtocolFees public override protocolFees;</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
   90 |     | <span class='unexecuted'>    uint128 public override liquidity;</span>
   91 |     | <span class='neutral'></span>
   92 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
   93 |     | <span class='unexecuted'>    mapping(int24 =&gt; Tick.Info) public override ticks;</span>
   94 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
   95 |     | <span class='unexecuted'>    mapping(int16 =&gt; uint256) public override tickBitmap;</span>
   96 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
   97 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; Position.Info) public override positions;</span>
   98 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
   99 |     | <span class='unexecuted'>    Oracle.Observation[65535] public override observations;</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance</span>
  102 |     | <span class='neutral'>    /// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because</span>
  103 |     | <span class='neutral'>    /// we use balance checks to determine the payment status of interactions such as mint, swap and flash.</span>
  104 |     | <span class='neutral'>    modifier lock() {</span>
  105 |     | <span class='unexecuted'>        require(slot0.unlocked, &quot;LOK&quot;);</span>
  106 |     | <span class='unexecuted'>        slot0.unlocked = false;</span>
  107 |     | <span class='unexecuted'>        _;</span>
  108 |     | <span class='unexecuted'>        slot0.unlocked = true;</span>
  109 |     | <span class='neutral'>    }</span>
  110 |     | <span class='neutral'></span>
  111 |     | <span class='neutral'>    /// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()</span>
  112 |     | <span class='neutral'>    modifier onlyFactoryOwner() {</span>
  113 |     | <span class='unexecuted'>        require(msg.sender == IUniswapV3Factory(factory).owner());</span>
  114 |     | <span class='unexecuted'>        _;</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='unexecuted'>    constructor() {</span>
  118 |     | <span class='unexecuted'>        int24 _tickSpacing;</span>
  119 |     | <span class='unexecuted'>        (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(</span>
  120 |     | <span class='unexecuted'>            msg.sender</span>
  121 |     | <span class='neutral'>        ).parameters();</span>
  122 |     | <span class='unexecuted'>        tickSpacing = _tickSpacing;</span>
  123 |     | <span class='neutral'></span>
  124 |     | <span class='unexecuted'>        maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(</span>
  125 |     | <span class='unexecuted'>            _tickSpacing</span>
  126 |     | <span class='neutral'>        );</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    /// @dev Common checks for valid tick inputs.</span>
  130 |     | <span class='unexecuted'>    function checkTicks(int24 tickLower, int24 tickUpper) private pure {</span>
  131 |     | <span class='unexecuted'>        require(tickLower &lt; tickUpper, &quot;TLU&quot;);</span>
  132 |     | <span class='unexecuted'>        require(tickLower &gt;= TickMath.MIN_TICK, &quot;TLM&quot;);</span>
  133 |     | <span class='unexecuted'>        require(tickUpper &lt;= TickMath.MAX_TICK, &quot;TUM&quot;);</span>
  134 |     | <span class='neutral'>    }</span>
  135 |     | <span class='neutral'></span>
  136 |     | <span class='neutral'>    /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.</span>
  137 |     | <span class='unexecuted'>    function _blockTimestamp() internal view virtual returns (uint32) {</span>
  138 |     | <span class='unexecuted'>        return uint32(block.timestamp); // truncation is desired</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    /// @dev Get the pool&quot;s balance of token0</span>
  142 |     | <span class='neutral'>    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize</span>
  143 |     | <span class='neutral'>    /// check</span>
  144 |     | <span class='unexecuted'>    function balance0() private view returns (uint256) {</span>
  145 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token0.staticcall(</span>
  146 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  147 |     | <span class='unexecuted'>                IERC20Minimal.balanceOf.selector,</span>
  148 |     | <span class='unexecuted'>                address(this)</span>
  149 |     | <span class='neutral'>            )</span>
  150 |     | <span class='neutral'>        );</span>
  151 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
  152 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
  153 |     | <span class='neutral'>    }</span>
  154 |     | <span class='neutral'></span>
  155 |     | <span class='neutral'>    /// @dev Get the pool&quot;s balance of token1</span>
  156 |     | <span class='neutral'>    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize</span>
  157 |     | <span class='neutral'>    /// check</span>
  158 |     | <span class='unexecuted'>    function balance1() private view returns (uint256) {</span>
  159 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token1.staticcall(</span>
  160 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  161 |     | <span class='unexecuted'>                IERC20Minimal.balanceOf.selector,</span>
  162 |     | <span class='unexecuted'>                address(this)</span>
  163 |     | <span class='neutral'>            )</span>
  164 |     | <span class='neutral'>        );</span>
  165 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
  166 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolDerivedState</span>
  170 |     | <span class='unexecuted'>    function snapshotCumulativesInside(</span>
  171 |     | <span class='neutral'>        int24 tickLower,</span>
  172 |     | <span class='neutral'>        int24 tickUpper</span>
  173 |     | <span class='neutral'>    )</span>
  174 |     | <span class='neutral'>        external</span>
  175 |     | <span class='neutral'>        view</span>
  176 |     | <span class='neutral'>        override</span>
  177 |     | <span class='neutral'>        noDelegateCall</span>
  178 |     | <span class='neutral'>        returns (</span>
  179 |     | <span class='unexecuted'>            int56 tickCumulativeInside,</span>
  180 |     | <span class='unexecuted'>            uint160 secondsPerLiquidityInsideX128,</span>
  181 |     | <span class='unexecuted'>            uint32 secondsInside</span>
  182 |     | <span class='neutral'>        )</span>
  183 |     | <span class='neutral'>    {</span>
  184 |     | <span class='unexecuted'>        checkTicks(tickLower, tickUpper);</span>
  185 |     | <span class='neutral'></span>
  186 |     | <span class='unexecuted'>        int56 tickCumulativeLower;</span>
  187 |     | <span class='unexecuted'>        int56 tickCumulativeUpper;</span>
  188 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityOutsideLowerX128;</span>
  189 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityOutsideUpperX128;</span>
  190 |     | <span class='unexecuted'>        uint32 secondsOutsideLower;</span>
  191 |     | <span class='unexecuted'>        uint32 secondsOutsideUpper;</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>        {</span>
  194 |     | <span class='unexecuted'>            Tick.Info storage lower = ticks[tickLower];</span>
  195 |     | <span class='unexecuted'>            Tick.Info storage upper = ticks[tickUpper];</span>
  196 |     | <span class='unexecuted'>            bool initializedLower;</span>
  197 |     | <span class='unexecuted'>            (</span>
  198 |     | <span class='neutral'>                tickCumulativeLower,</span>
  199 |     | <span class='neutral'>                secondsPerLiquidityOutsideLowerX128,</span>
  200 |     | <span class='neutral'>                secondsOutsideLower,</span>
  201 |     | <span class='neutral'>                initializedLower</span>
  202 |     | <span class='neutral'>            ) = (</span>
  203 |     | <span class='unexecuted'>                lower.tickCumulativeOutside,</span>
  204 |     | <span class='unexecuted'>                lower.secondsPerLiquidityOutsideX128,</span>
  205 |     | <span class='unexecuted'>                lower.secondsOutside,</span>
  206 |     | <span class='unexecuted'>                lower.initialized</span>
  207 |     | <span class='neutral'>            );</span>
  208 |     | <span class='unexecuted'>            require(initializedLower);</span>
  209 |     | <span class='neutral'></span>
  210 |     | <span class='unexecuted'>            bool initializedUpper;</span>
  211 |     | <span class='unexecuted'>            (</span>
  212 |     | <span class='neutral'>                tickCumulativeUpper,</span>
  213 |     | <span class='neutral'>                secondsPerLiquidityOutsideUpperX128,</span>
  214 |     | <span class='neutral'>                secondsOutsideUpper,</span>
  215 |     | <span class='neutral'>                initializedUpper</span>
  216 |     | <span class='neutral'>            ) = (</span>
  217 |     | <span class='unexecuted'>                upper.tickCumulativeOutside,</span>
  218 |     | <span class='unexecuted'>                upper.secondsPerLiquidityOutsideX128,</span>
  219 |     | <span class='unexecuted'>                upper.secondsOutside,</span>
  220 |     | <span class='unexecuted'>                upper.initialized</span>
  221 |     | <span class='neutral'>            );</span>
  222 |     | <span class='unexecuted'>            require(initializedUpper);</span>
  223 |     | <span class='neutral'>        }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='unexecuted'>        Slot0 memory _slot0 = slot0;</span>
  226 |     | <span class='neutral'></span>
  227 |     | <span class='unexecuted'>        if (_slot0.tick &lt; tickLower) {</span>
  228 |     | <span class='unexecuted'>            return (</span>
  229 |     | <span class='unexecuted'>                tickCumulativeLower - tickCumulativeUpper,</span>
  230 |     | <span class='unexecuted'>                secondsPerLiquidityOutsideLowerX128 -</span>
  231 |     | <span class='unexecuted'>                    secondsPerLiquidityOutsideUpperX128,</span>
  232 |     | <span class='unexecuted'>                secondsOutsideLower - secondsOutsideUpper</span>
  233 |     | <span class='neutral'>            );</span>
  234 |     | <span class='unexecuted'>        } else if (_slot0.tick &lt; tickUpper) {</span>
  235 |     | <span class='unexecuted'>            uint32 time = _blockTimestamp();</span>
  236 |     | <span class='unexecuted'>            (</span>
  237 |     | <span class='unexecuted'>                int56 tickCumulative,</span>
  238 |     | <span class='unexecuted'>                uint160 secondsPerLiquidityCumulativeX128</span>
  239 |     | <span class='unexecuted'>            ) = observations.observeSingle(</span>
  240 |     | <span class='unexecuted'>                    time,</span>
  241 |     | <span class='unexecuted'>                    0,</span>
  242 |     | <span class='unexecuted'>                    _slot0.tick,</span>
  243 |     | <span class='unexecuted'>                    _slot0.observationIndex,</span>
  244 |     | <span class='unexecuted'>                    liquidity,</span>
  245 |     | <span class='unexecuted'>                    _slot0.observationCardinality</span>
  246 |     | <span class='neutral'>                );</span>
  247 |     | <span class='unexecuted'>            return (</span>
  248 |     | <span class='unexecuted'>                tickCumulative - tickCumulativeLower - tickCumulativeUpper,</span>
  249 |     | <span class='unexecuted'>                secondsPerLiquidityCumulativeX128 -</span>
  250 |     | <span class='unexecuted'>                    secondsPerLiquidityOutsideLowerX128 -</span>
  251 |     | <span class='unexecuted'>                    secondsPerLiquidityOutsideUpperX128,</span>
  252 |     | <span class='unexecuted'>                time - secondsOutsideLower - secondsOutsideUpper</span>
  253 |     | <span class='neutral'>            );</span>
  254 |     | <span class='neutral'>        } else {</span>
  255 |     | <span class='unexecuted'>            return (</span>
  256 |     | <span class='unexecuted'>                tickCumulativeUpper - tickCumulativeLower,</span>
  257 |     | <span class='unexecuted'>                secondsPerLiquidityOutsideUpperX128 -</span>
  258 |     | <span class='unexecuted'>                    secondsPerLiquidityOutsideLowerX128,</span>
  259 |     | <span class='unexecuted'>                secondsOutsideUpper - secondsOutsideLower</span>
  260 |     | <span class='neutral'>            );</span>
  261 |     | <span class='neutral'>        }</span>
  262 |     | <span class='neutral'>    }</span>
  263 |     | <span class='neutral'></span>
  264 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolDerivedState</span>
  265 |     | <span class='unexecuted'>    function observe(</span>
  266 |     | <span class='neutral'>        uint32[] calldata secondsAgos</span>
  267 |     | <span class='neutral'>    )</span>
  268 |     | <span class='neutral'>        external</span>
  269 |     | <span class='neutral'>        view</span>
  270 |     | <span class='neutral'>        override</span>
  271 |     | <span class='neutral'>        noDelegateCall</span>
  272 |     | <span class='neutral'>        returns (</span>
  273 |     | <span class='unexecuted'>            int56[] memory tickCumulatives,</span>
  274 |     | <span class='unexecuted'>            uint160[] memory secondsPerLiquidityCumulativeX128s</span>
  275 |     | <span class='neutral'>        )</span>
  276 |     | <span class='neutral'>    {</span>
  277 |     | <span class='unexecuted'>        return</span>
  278 |     | <span class='unexecuted'>            observations.observe(</span>
  279 |     | <span class='unexecuted'>                _blockTimestamp(),</span>
  280 |     | <span class='unexecuted'>                secondsAgos,</span>
  281 |     | <span class='unexecuted'>                slot0.tick,</span>
  282 |     | <span class='unexecuted'>                slot0.observationIndex,</span>
  283 |     | <span class='unexecuted'>                liquidity,</span>
  284 |     | <span class='unexecuted'>                slot0.observationCardinality</span>
  285 |     | <span class='neutral'>            );</span>
  286 |     | <span class='neutral'>    }</span>
  287 |     | <span class='neutral'></span>
  288 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
  289 |     | <span class='unexecuted'>    function increaseObservationCardinalityNext(</span>
  290 |     | <span class='neutral'>        uint16 observationCardinalityNext</span>
  291 |     | <span class='neutral'>    ) external override lock noDelegateCall {</span>
  292 |     | <span class='unexecuted'>        uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event</span>
  293 |     | <span class='unexecuted'>        uint16 observationCardinalityNextNew = observations.grow(</span>
  294 |     | <span class='unexecuted'>            observationCardinalityNextOld,</span>
  295 |     | <span class='unexecuted'>            observationCardinalityNext</span>
  296 |     | <span class='neutral'>        );</span>
  297 |     | <span class='unexecuted'>        slot0.observationCardinalityNext = observationCardinalityNextNew;</span>
  298 |     | <span class='unexecuted'>        if (observationCardinalityNextOld != observationCardinalityNextNew)</span>
  299 |     | <span class='unexecuted'>            emit IncreaseObservationCardinalityNext(</span>
  300 |     | <span class='unexecuted'>                observationCardinalityNextOld,</span>
  301 |     | <span class='unexecuted'>                observationCardinalityNextNew</span>
  302 |     | <span class='neutral'>            );</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
  306 |     | <span class='neutral'>    /// @dev not locked because it initializes unlocked</span>
  307 |     | <span class='unexecuted'>    function initialize(uint160 sqrtPriceX96) external override {</span>
  308 |     | <span class='unexecuted'>        require(slot0.sqrtPriceX96 == 0, &quot;AI&quot;);</span>
  309 |     | <span class='neutral'></span>
  310 |     | <span class='unexecuted'>        int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);</span>
  311 |     | <span class='neutral'></span>
  312 |     | <span class='unexecuted'>        (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(</span>
  313 |     | <span class='unexecuted'>            _blockTimestamp()</span>
  314 |     | <span class='neutral'>        );</span>
  315 |     | <span class='neutral'></span>
  316 |     | <span class='unexecuted'>        slot0 = Slot0({</span>
  317 |     | <span class='unexecuted'>            sqrtPriceX96: sqrtPriceX96,</span>
  318 |     | <span class='unexecuted'>            tick: tick,</span>
  319 |     | <span class='unexecuted'>            observationIndex: 0,</span>
  320 |     | <span class='unexecuted'>            observationCardinality: cardinality,</span>
  321 |     | <span class='unexecuted'>            observationCardinalityNext: cardinalityNext,</span>
  322 |     | <span class='unexecuted'>            feeProtocol: 0,</span>
  323 |     | <span class='unexecuted'>            unlocked: true</span>
  324 |     | <span class='neutral'>        });</span>
  325 |     | <span class='neutral'></span>
  326 |     | <span class='unexecuted'>        emit Initialize(sqrtPriceX96, tick);</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    struct ModifyPositionParams {</span>
  330 |     | <span class='neutral'>        // the address that owns the position</span>
  331 |     | <span class='neutral'>        address owner;</span>
  332 |     | <span class='neutral'>        // the lower and upper tick of the position</span>
  333 |     | <span class='neutral'>        int24 tickLower;</span>
  334 |     | <span class='neutral'>        int24 tickUpper;</span>
  335 |     | <span class='neutral'>        // any change in liquidity</span>
  336 |     | <span class='neutral'>        int128 liquidityDelta;</span>
  337 |     | <span class='neutral'>    }</span>
  338 |     | <span class='neutral'></span>
  339 |     | <span class='neutral'>    /// @dev Effect some changes to a position</span>
  340 |     | <span class='neutral'>    /// @param params the position details and the change to the position&quot;s liquidity to effect</span>
  341 |     | <span class='neutral'>    /// @return position a storage pointer referencing the position with the given owner and tick range</span>
  342 |     | <span class='neutral'>    /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient</span>
  343 |     | <span class='neutral'>    /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient</span>
  344 |     | <span class='unexecuted'>    function _modifyPosition(</span>
  345 |     | <span class='neutral'>        ModifyPositionParams memory params</span>
  346 |     | <span class='neutral'>    )</span>
  347 |     | <span class='neutral'>        private</span>
  348 |     | <span class='neutral'>        noDelegateCall</span>
  349 |     | <span class='unexecuted'>        returns (Position.Info storage position, int256 amount0, int256 amount1)</span>
  350 |     | <span class='neutral'>    {</span>
  351 |     | <span class='unexecuted'>        checkTicks(params.tickLower, params.tickUpper);</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='unexecuted'>        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization</span>
  354 |     | <span class='neutral'></span>
  355 |     | <span class='unexecuted'>        position = _updatePosition(</span>
  356 |     | <span class='unexecuted'>            params.owner,</span>
  357 |     | <span class='unexecuted'>            params.tickLower,</span>
  358 |     | <span class='unexecuted'>            params.tickUpper,</span>
  359 |     | <span class='unexecuted'>            params.liquidityDelta,</span>
  360 |     | <span class='unexecuted'>            _slot0.tick</span>
  361 |     | <span class='neutral'>        );</span>
  362 |     | <span class='neutral'></span>
  363 |     | <span class='unexecuted'>        if (params.liquidityDelta != 0) {</span>
  364 |     | <span class='unexecuted'>            if (_slot0.tick &lt; params.tickLower) {</span>
  365 |     | <span class='neutral'>                // current tick is below the passed range; liquidity can only become in range by crossing from left to</span>
  366 |     | <span class='neutral'>                // right, when we&quot;ll need _more_ token0 (it&quot;s becoming more valuable) so user must provide it</span>
  367 |     | <span class='unexecuted'>                amount0 = SqrtPriceMath.getAmount0Delta(</span>
  368 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickLower),</span>
  369 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span>
  370 |     | <span class='unexecuted'>                    params.liquidityDelta</span>
  371 |     | <span class='neutral'>                );</span>
  372 |     | <span class='unexecuted'>            } else if (_slot0.tick &lt; params.tickUpper) {</span>
  373 |     | <span class='neutral'>                // current tick is inside the passed range</span>
  374 |     | <span class='unexecuted'>                uint128 liquidityBefore = liquidity; // SLOAD for gas optimization</span>
  375 |     | <span class='neutral'></span>
  376 |     | <span class='neutral'>                // write an oracle entry</span>
  377 |     | <span class='unexecuted'>                (</span>
  378 |     | <span class='unexecuted'>                    slot0.observationIndex,</span>
  379 |     | <span class='unexecuted'>                    slot0.observationCardinality</span>
  380 |     | <span class='unexecuted'>                ) = observations.write(</span>
  381 |     | <span class='unexecuted'>                    _slot0.observationIndex,</span>
  382 |     | <span class='unexecuted'>                    _blockTimestamp(),</span>
  383 |     | <span class='unexecuted'>                    _slot0.tick,</span>
  384 |     | <span class='unexecuted'>                    liquidityBefore,</span>
  385 |     | <span class='unexecuted'>                    _slot0.observationCardinality,</span>
  386 |     | <span class='unexecuted'>                    _slot0.observationCardinalityNext</span>
  387 |     | <span class='neutral'>                );</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='unexecuted'>                amount0 = SqrtPriceMath.getAmount0Delta(</span>
  390 |     | <span class='unexecuted'>                    _slot0.sqrtPriceX96,</span>
  391 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span>
  392 |     | <span class='unexecuted'>                    params.liquidityDelta</span>
  393 |     | <span class='neutral'>                );</span>
  394 |     | <span class='unexecuted'>                amount1 = SqrtPriceMath.getAmount1Delta(</span>
  395 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickLower),</span>
  396 |     | <span class='unexecuted'>                    _slot0.sqrtPriceX96,</span>
  397 |     | <span class='unexecuted'>                    params.liquidityDelta</span>
  398 |     | <span class='neutral'>                );</span>
  399 |     | <span class='neutral'></span>
  400 |     | <span class='unexecuted'>                liquidity = LiquidityMath.addDelta(</span>
  401 |     | <span class='unexecuted'>                    liquidityBefore,</span>
  402 |     | <span class='unexecuted'>                    params.liquidityDelta</span>
  403 |     | <span class='neutral'>                );</span>
  404 |     | <span class='neutral'>            } else {</span>
  405 |     | <span class='neutral'>                // current tick is above the passed range; liquidity can only become in range by crossing from right to</span>
  406 |     | <span class='neutral'>                // left, when we&quot;ll need _more_ token1 (it&quot;s becoming more valuable) so user must provide it</span>
  407 |     | <span class='unexecuted'>                amount1 = SqrtPriceMath.getAmount1Delta(</span>
  408 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickLower),</span>
  409 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span>
  410 |     | <span class='unexecuted'>                    params.liquidityDelta</span>
  411 |     | <span class='neutral'>                );</span>
  412 |     | <span class='neutral'>            }</span>
  413 |     | <span class='neutral'>        }</span>
  414 |     | <span class='neutral'>    }</span>
  415 |     | <span class='neutral'></span>
  416 |     | <span class='neutral'>    /// @dev Gets and updates a position with the given liquidity delta</span>
  417 |     | <span class='neutral'>    /// @param owner the owner of the position</span>
  418 |     | <span class='neutral'>    /// @param tickLower the lower tick of the position&quot;s tick range</span>
  419 |     | <span class='neutral'>    /// @param tickUpper the upper tick of the position&quot;s tick range</span>
  420 |     | <span class='neutral'>    /// @param tick the current tick, passed to avoid sloads</span>
  421 |     | <span class='unexecuted'>    function _updatePosition(</span>
  422 |     | <span class='neutral'>        address owner,</span>
  423 |     | <span class='neutral'>        int24 tickLower,</span>
  424 |     | <span class='neutral'>        int24 tickUpper,</span>
  425 |     | <span class='neutral'>        int128 liquidityDelta,</span>
  426 |     | <span class='neutral'>        int24 tick</span>
  427 |     | <span class='unexecuted'>    ) private returns (Position.Info storage position) {</span>
  428 |     | <span class='unexecuted'>        position = positions.get(owner, tickLower, tickUpper);</span>
  429 |     | <span class='neutral'></span>
  430 |     | <span class='unexecuted'>        uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization</span>
  431 |     | <span class='unexecuted'>        uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>        // if we need to update the ticks, do it</span>
  434 |     | <span class='unexecuted'>        bool flippedLower;</span>
  435 |     | <span class='unexecuted'>        bool flippedUpper;</span>
  436 |     | <span class='unexecuted'>        if (liquidityDelta != 0) {</span>
  437 |     | <span class='unexecuted'>            uint32 time = _blockTimestamp();</span>
  438 |     | <span class='unexecuted'>            (</span>
  439 |     | <span class='unexecuted'>                int56 tickCumulative,</span>
  440 |     | <span class='unexecuted'>                uint160 secondsPerLiquidityCumulativeX128</span>
  441 |     | <span class='unexecuted'>            ) = observations.observeSingle(</span>
  442 |     | <span class='unexecuted'>                    time,</span>
  443 |     | <span class='unexecuted'>                    0,</span>
  444 |     | <span class='unexecuted'>                    slot0.tick,</span>
  445 |     | <span class='unexecuted'>                    slot0.observationIndex,</span>
  446 |     | <span class='unexecuted'>                    liquidity,</span>
  447 |     | <span class='unexecuted'>                    slot0.observationCardinality</span>
  448 |     | <span class='neutral'>                );</span>
  449 |     | <span class='neutral'></span>
  450 |     | <span class='unexecuted'>            flippedLower = ticks.update(</span>
  451 |     | <span class='unexecuted'>                tickLower,</span>
  452 |     | <span class='unexecuted'>                tick,</span>
  453 |     | <span class='unexecuted'>                liquidityDelta,</span>
  454 |     | <span class='unexecuted'>                _feeGrowthGlobal0X128,</span>
  455 |     | <span class='unexecuted'>                _feeGrowthGlobal1X128,</span>
  456 |     | <span class='unexecuted'>                secondsPerLiquidityCumulativeX128,</span>
  457 |     | <span class='unexecuted'>                tickCumulative,</span>
  458 |     | <span class='unexecuted'>                time,</span>
  459 |     | <span class='unexecuted'>                false,</span>
  460 |     | <span class='unexecuted'>                maxLiquidityPerTick</span>
  461 |     | <span class='neutral'>            );</span>
  462 |     | <span class='unexecuted'>            flippedUpper = ticks.update(</span>
  463 |     | <span class='unexecuted'>                tickUpper,</span>
  464 |     | <span class='unexecuted'>                tick,</span>
  465 |     | <span class='unexecuted'>                liquidityDelta,</span>
  466 |     | <span class='unexecuted'>                _feeGrowthGlobal0X128,</span>
  467 |     | <span class='unexecuted'>                _feeGrowthGlobal1X128,</span>
  468 |     | <span class='unexecuted'>                secondsPerLiquidityCumulativeX128,</span>
  469 |     | <span class='unexecuted'>                tickCumulative,</span>
  470 |     | <span class='unexecuted'>                time,</span>
  471 |     | <span class='unexecuted'>                true,</span>
  472 |     | <span class='unexecuted'>                maxLiquidityPerTick</span>
  473 |     | <span class='neutral'>            );</span>
  474 |     | <span class='neutral'></span>
  475 |     | <span class='unexecuted'>            if (flippedLower) {</span>
  476 |     | <span class='unexecuted'>                tickBitmap.flipTick(tickLower, tickSpacing);</span>
  477 |     | <span class='neutral'>            }</span>
  478 |     | <span class='unexecuted'>            if (flippedUpper) {</span>
  479 |     | <span class='unexecuted'>                tickBitmap.flipTick(tickUpper, tickSpacing);</span>
  480 |     | <span class='neutral'>            }</span>
  481 |     | <span class='neutral'>        }</span>
  482 |     | <span class='neutral'></span>
  483 |     | <span class='unexecuted'>        (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks</span>
  484 |     | <span class='neutral'>            .getFeeGrowthInside(</span>
  485 |     | <span class='unexecuted'>                tickLower,</span>
  486 |     | <span class='unexecuted'>                tickUpper,</span>
  487 |     | <span class='unexecuted'>                tick,</span>
  488 |     | <span class='unexecuted'>                _feeGrowthGlobal0X128,</span>
  489 |     | <span class='unexecuted'>                _feeGrowthGlobal1X128</span>
  490 |     | <span class='neutral'>            );</span>
  491 |     | <span class='neutral'></span>
  492 |     | <span class='unexecuted'>        position.update(</span>
  493 |     | <span class='unexecuted'>            liquidityDelta,</span>
  494 |     | <span class='unexecuted'>            feeGrowthInside0X128,</span>
  495 |     | <span class='unexecuted'>            feeGrowthInside1X128</span>
  496 |     | <span class='neutral'>        );</span>
  497 |     | <span class='neutral'></span>
  498 |     | <span class='neutral'>        // clear any tick data that is no longer needed</span>
  499 |     | <span class='unexecuted'>        if (liquidityDelta &lt; 0) {</span>
  500 |     | <span class='unexecuted'>            if (flippedLower) {</span>
  501 |     | <span class='unexecuted'>                ticks.clear(tickLower);</span>
  502 |     | <span class='neutral'>            }</span>
  503 |     | <span class='unexecuted'>            if (flippedUpper) {</span>
  504 |     | <span class='unexecuted'>                ticks.clear(tickUpper);</span>
  505 |     | <span class='neutral'>            }</span>
  506 |     | <span class='neutral'>        }</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
  510 |     | <span class='neutral'>    /// @dev noDelegateCall is applied indirectly via _modifyPosition</span>
  511 |     | <span class='unexecuted'>    function mint(</span>
  512 |     | <span class='neutral'>        address recipient,</span>
  513 |     | <span class='neutral'>        int24 tickLower,</span>
  514 |     | <span class='neutral'>        int24 tickUpper,</span>
  515 |     | <span class='neutral'>        uint128 amount,</span>
  516 |     | <span class='neutral'>        bytes calldata data</span>
  517 |     | <span class='unexecuted'>    ) external override lock returns (uint256 amount0, uint256 amount1) {</span>
  518 |     | <span class='unexecuted'>        require(amount &gt; 0);</span>
  519 |     | <span class='unexecuted'>        (, int256 amount0Int, int256 amount1Int) = _modifyPosition(</span>
  520 |     | <span class='unexecuted'>            ModifyPositionParams({</span>
  521 |     | <span class='unexecuted'>                owner: recipient,</span>
  522 |     | <span class='unexecuted'>                tickLower: tickLower,</span>
  523 |     | <span class='unexecuted'>                tickUpper: tickUpper,</span>
  524 |     | <span class='unexecuted'>                liquidityDelta: int256(amount).toInt128()</span>
  525 |     | <span class='neutral'>            })</span>
  526 |     | <span class='neutral'>        );</span>
  527 |     | <span class='neutral'></span>
  528 |     | <span class='unexecuted'>        amount0 = uint256(amount0Int);</span>
  529 |     | <span class='unexecuted'>        amount1 = uint256(amount1Int);</span>
  530 |     | <span class='neutral'></span>
  531 |     | <span class='unexecuted'>        uint256 balance0Before;</span>
  532 |     | <span class='unexecuted'>        uint256 balance1Before;</span>
  533 |     | <span class='unexecuted'>        if (amount0 &gt; 0) balance0Before = balance0();</span>
  534 |     | <span class='unexecuted'>        if (amount1 &gt; 0) balance1Before = balance1();</span>
  535 |     | <span class='unexecuted'>        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(</span>
  536 |     | <span class='unexecuted'>            amount0,</span>
  537 |     | <span class='unexecuted'>            amount1,</span>
  538 |     | <span class='unexecuted'>            data</span>
  539 |     | <span class='neutral'>        );</span>
  540 |     | <span class='unexecuted'>        if (amount0 &gt; 0)</span>
  541 |     | <span class='unexecuted'>            require(balance0Before.add(amount0) &lt;= balance0(), &quot;M0&quot;);</span>
  542 |     | <span class='unexecuted'>        if (amount1 &gt; 0)</span>
  543 |     | <span class='unexecuted'>            require(balance1Before.add(amount1) &lt;= balance1(), &quot;M1&quot;);</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='unexecuted'>        emit Mint(</span>
  546 |     | <span class='unexecuted'>            msg.sender,</span>
  547 |     | <span class='unexecuted'>            recipient,</span>
  548 |     | <span class='unexecuted'>            tickLower,</span>
  549 |     | <span class='unexecuted'>            tickUpper,</span>
  550 |     | <span class='unexecuted'>            amount,</span>
  551 |     | <span class='unexecuted'>            amount0,</span>
  552 |     | <span class='unexecuted'>            amount1</span>
  553 |     | <span class='neutral'>        );</span>
  554 |     | <span class='neutral'>    }</span>
  555 |     | <span class='neutral'></span>
  556 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
  557 |     | <span class='unexecuted'>    function collect(</span>
  558 |     | <span class='neutral'>        address recipient,</span>
  559 |     | <span class='neutral'>        int24 tickLower,</span>
  560 |     | <span class='neutral'>        int24 tickUpper,</span>
  561 |     | <span class='neutral'>        uint128 amount0Requested,</span>
  562 |     | <span class='neutral'>        uint128 amount1Requested</span>
  563 |     | <span class='unexecuted'>    ) external override lock returns (uint128 amount0, uint128 amount1) {</span>
  564 |     | <span class='neutral'>        // we don&quot;t need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}</span>
  565 |     | <span class='unexecuted'>        Position.Info storage position = positions.get(</span>
  566 |     | <span class='unexecuted'>            msg.sender,</span>
  567 |     | <span class='unexecuted'>            tickLower,</span>
  568 |     | <span class='unexecuted'>            tickUpper</span>
  569 |     | <span class='neutral'>        );</span>
  570 |     | <span class='neutral'></span>
  571 |     | <span class='unexecuted'>        amount0 = amount0Requested &gt; position.tokensOwed0</span>
  572 |     | <span class='unexecuted'>            ? position.tokensOwed0</span>
  573 |     | <span class='unexecuted'>            : amount0Requested;</span>
  574 |     | <span class='unexecuted'>        amount1 = amount1Requested &gt; position.tokensOwed1</span>
  575 |     | <span class='unexecuted'>            ? position.tokensOwed1</span>
  576 |     | <span class='unexecuted'>            : amount1Requested;</span>
  577 |     | <span class='neutral'></span>
  578 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
  579 |     | <span class='unexecuted'>            position.tokensOwed0 -= amount0;</span>
  580 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token0, recipient, amount0);</span>
  581 |     | <span class='neutral'>        }</span>
  582 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
  583 |     | <span class='unexecuted'>            position.tokensOwed1 -= amount1;</span>
  584 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token1, recipient, amount1);</span>
  585 |     | <span class='neutral'>        }</span>
  586 |     | <span class='neutral'></span>
  587 |     | <span class='unexecuted'>        emit Collect(</span>
  588 |     | <span class='unexecuted'>            msg.sender,</span>
  589 |     | <span class='unexecuted'>            recipient,</span>
  590 |     | <span class='unexecuted'>            tickLower,</span>
  591 |     | <span class='unexecuted'>            tickUpper,</span>
  592 |     | <span class='unexecuted'>            amount0,</span>
  593 |     | <span class='unexecuted'>            amount1</span>
  594 |     | <span class='neutral'>        );</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
  598 |     | <span class='neutral'>    /// @dev noDelegateCall is applied indirectly via _modifyPosition</span>
  599 |     | <span class='unexecuted'>    function burn(</span>
  600 |     | <span class='neutral'>        int24 tickLower,</span>
  601 |     | <span class='neutral'>        int24 tickUpper,</span>
  602 |     | <span class='neutral'>        uint128 amount</span>
  603 |     | <span class='unexecuted'>    ) external override lock returns (uint256 amount0, uint256 amount1) {</span>
  604 |     | <span class='unexecuted'>        (</span>
  605 |     | <span class='unexecuted'>            Position.Info storage position,</span>
  606 |     | <span class='unexecuted'>            int256 amount0Int,</span>
  607 |     | <span class='unexecuted'>            int256 amount1Int</span>
  608 |     | <span class='unexecuted'>        ) = _modifyPosition(</span>
  609 |     | <span class='unexecuted'>                ModifyPositionParams({</span>
  610 |     | <span class='unexecuted'>                    owner: msg.sender,</span>
  611 |     | <span class='unexecuted'>                    tickLower: tickLower,</span>
  612 |     | <span class='unexecuted'>                    tickUpper: tickUpper,</span>
  613 |     | <span class='unexecuted'>                    liquidityDelta: -int256(amount).toInt128()</span>
  614 |     | <span class='neutral'>                })</span>
  615 |     | <span class='neutral'>            );</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='unexecuted'>        amount0 = uint256(-amount0Int);</span>
  618 |     | <span class='unexecuted'>        amount1 = uint256(-amount1Int);</span>
  619 |     | <span class='neutral'></span>
  620 |     | <span class='unexecuted'>        if (amount0 &gt; 0 || amount1 &gt; 0) {</span>
  621 |     | <span class='unexecuted'>            (position.tokensOwed0, position.tokensOwed1) = (</span>
  622 |     | <span class='unexecuted'>                position.tokensOwed0 + uint128(amount0),</span>
  623 |     | <span class='unexecuted'>                position.tokensOwed1 + uint128(amount1)</span>
  624 |     | <span class='neutral'>            );</span>
  625 |     | <span class='neutral'>        }</span>
  626 |     | <span class='neutral'></span>
  627 |     | <span class='unexecuted'>        emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);</span>
  628 |     | <span class='neutral'>    }</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>    struct SwapCache {</span>
  631 |     | <span class='neutral'>        // the protocol fee for the input token</span>
  632 |     | <span class='neutral'>        uint8 feeProtocol;</span>
  633 |     | <span class='neutral'>        // liquidity at the beginning of the swap</span>
  634 |     | <span class='neutral'>        uint128 liquidityStart;</span>
  635 |     | <span class='neutral'>        // the timestamp of the current block</span>
  636 |     | <span class='neutral'>        uint32 blockTimestamp;</span>
  637 |     | <span class='neutral'>        // the current value of the tick accumulator, computed only if we cross an initialized tick</span>
  638 |     | <span class='neutral'>        int56 tickCumulative;</span>
  639 |     | <span class='neutral'>        // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick</span>
  640 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128;</span>
  641 |     | <span class='neutral'>        // whether we&quot;ve computed and cached the above two accumulators</span>
  642 |     | <span class='neutral'>        bool computedLatestObservation;</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    // the top level state of the swap, the results of which are recorded in storage at the end</span>
  646 |     | <span class='neutral'>    struct SwapState {</span>
  647 |     | <span class='neutral'>        // the amount remaining to be swapped in/out of the input/output asset</span>
  648 |     | <span class='neutral'>        int256 amountSpecifiedRemaining;</span>
  649 |     | <span class='neutral'>        // the amount already swapped out/in of the output/input asset</span>
  650 |     | <span class='neutral'>        int256 amountCalculated;</span>
  651 |     | <span class='neutral'>        // current sqrt(price)</span>
  652 |     | <span class='neutral'>        uint160 sqrtPriceX96;</span>
  653 |     | <span class='neutral'>        // the tick associated with the current price</span>
  654 |     | <span class='neutral'>        int24 tick;</span>
  655 |     | <span class='neutral'>        // the global fee growth of the input token</span>
  656 |     | <span class='neutral'>        uint256 feeGrowthGlobalX128;</span>
  657 |     | <span class='neutral'>        // amount of input token paid as protocol fee</span>
  658 |     | <span class='neutral'>        uint128 protocolFee;</span>
  659 |     | <span class='neutral'>        // the current liquidity in range</span>
  660 |     | <span class='neutral'>        uint128 liquidity;</span>
  661 |     | <span class='neutral'>    }</span>
  662 |     | <span class='neutral'></span>
  663 |     | <span class='neutral'>    struct StepComputations {</span>
  664 |     | <span class='neutral'>        // the price at the beginning of the step</span>
  665 |     | <span class='neutral'>        uint160 sqrtPriceStartX96;</span>
  666 |     | <span class='neutral'>        // the next tick to swap to from the current tick in the swap direction</span>
  667 |     | <span class='neutral'>        int24 tickNext;</span>
  668 |     | <span class='neutral'>        // whether tickNext is initialized or not</span>
  669 |     | <span class='neutral'>        bool initialized;</span>
  670 |     | <span class='neutral'>        // sqrt(price) for the next tick (1/0)</span>
  671 |     | <span class='neutral'>        uint160 sqrtPriceNextX96;</span>
  672 |     | <span class='neutral'>        // how much is being swapped in in this step</span>
  673 |     | <span class='neutral'>        uint256 amountIn;</span>
  674 |     | <span class='neutral'>        // how much is being swapped out</span>
  675 |     | <span class='neutral'>        uint256 amountOut;</span>
  676 |     | <span class='neutral'>        // how much fee is being paid in</span>
  677 |     | <span class='neutral'>        uint256 feeAmount;</span>
  678 |     | <span class='neutral'>    }</span>
  679 |     | <span class='neutral'></span>
  680 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
  681 |     | <span class='unexecuted'>    function swap(</span>
  682 |     | <span class='neutral'>        address recipient,</span>
  683 |     | <span class='neutral'>        bool zeroForOne,</span>
  684 |     | <span class='neutral'>        int256 amountSpecified,</span>
  685 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96,</span>
  686 |     | <span class='neutral'>        bytes calldata data</span>
  687 |     | <span class='neutral'>    )</span>
  688 |     | <span class='neutral'>        external</span>
  689 |     | <span class='neutral'>        override</span>
  690 |     | <span class='neutral'>        noDelegateCall</span>
  691 |     | <span class='unexecuted'>        returns (int256 amount0, int256 amount1)</span>
  692 |     | <span class='neutral'>    {</span>
  693 |     | <span class='unexecuted'>        require(amountSpecified != 0, &quot;AS&quot;);</span>
  694 |     | <span class='neutral'></span>
  695 |     | <span class='unexecuted'>        Slot0 memory slot0Start = slot0;</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='unexecuted'>        require(slot0Start.unlocked, &quot;LOK&quot;);</span>
  698 |     | <span class='unexecuted'>        require(</span>
  699 |     | <span class='unexecuted'>            zeroForOne</span>
  700 |     | <span class='unexecuted'>                ? sqrtPriceLimitX96 &lt; slot0Start.sqrtPriceX96 &amp;&amp;</span>
  701 |     | <span class='unexecuted'>                    sqrtPriceLimitX96 &gt; TickMath.MIN_SQRT_RATIO</span>
  702 |     | <span class='unexecuted'>                : sqrtPriceLimitX96 &gt; slot0Start.sqrtPriceX96 &amp;&amp;</span>
  703 |     | <span class='unexecuted'>                    sqrtPriceLimitX96 &lt; TickMath.MAX_SQRT_RATIO,</span>
  704 |     | <span class='neutral'>            &quot;SPL&quot;</span>
  705 |     | <span class='neutral'>        );</span>
  706 |     | <span class='neutral'></span>
  707 |     | <span class='unexecuted'>        slot0.unlocked = false;</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='unexecuted'>        SwapCache memory cache = SwapCache({</span>
  710 |     | <span class='unexecuted'>            liquidityStart: liquidity,</span>
  711 |     | <span class='unexecuted'>            blockTimestamp: _blockTimestamp(),</span>
  712 |     | <span class='unexecuted'>            feeProtocol: zeroForOne</span>
  713 |     | <span class='unexecuted'>                ? (slot0Start.feeProtocol % 16)</span>
  714 |     | <span class='unexecuted'>                : (slot0Start.feeProtocol &gt;&gt; 4),</span>
  715 |     | <span class='unexecuted'>            secondsPerLiquidityCumulativeX128: 0,</span>
  716 |     | <span class='unexecuted'>            tickCumulative: 0,</span>
  717 |     | <span class='unexecuted'>            computedLatestObservation: false</span>
  718 |     | <span class='neutral'>        });</span>
  719 |     | <span class='neutral'></span>
  720 |     | <span class='unexecuted'>        bool exactInput = amountSpecified &gt; 0;</span>
  721 |     | <span class='neutral'></span>
  722 |     | <span class='unexecuted'>        SwapState memory state = SwapState({</span>
  723 |     | <span class='unexecuted'>            amountSpecifiedRemaining: amountSpecified,</span>
  724 |     | <span class='unexecuted'>            amountCalculated: 0,</span>
  725 |     | <span class='unexecuted'>            sqrtPriceX96: slot0Start.sqrtPriceX96,</span>
  726 |     | <span class='unexecuted'>            tick: slot0Start.tick,</span>
  727 |     | <span class='unexecuted'>            feeGrowthGlobalX128: zeroForOne</span>
  728 |     | <span class='unexecuted'>                ? feeGrowthGlobal0X128</span>
  729 |     | <span class='unexecuted'>                : feeGrowthGlobal1X128,</span>
  730 |     | <span class='unexecuted'>            protocolFee: 0,</span>
  731 |     | <span class='unexecuted'>            liquidity: cache.liquidityStart</span>
  732 |     | <span class='neutral'>        });</span>
  733 |     | <span class='neutral'></span>
  734 |     | <span class='neutral'>        // continue swapping as long as we haven&quot;t used the entire input/output and haven&quot;t reached the price limit</span>
  735 |     | <span class='unexecuted'>        while (</span>
  736 |     | <span class='unexecuted'>            state.amountSpecifiedRemaining != 0 &amp;&amp;</span>
  737 |     | <span class='unexecuted'>            state.sqrtPriceX96 != sqrtPriceLimitX96</span>
  738 |     | <span class='neutral'>        ) {</span>
  739 |     | <span class='unexecuted'>            StepComputations memory step;</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='unexecuted'>            step.sqrtPriceStartX96 = state.sqrtPriceX96;</span>
  742 |     | <span class='neutral'></span>
  743 |     | <span class='unexecuted'>            (step.tickNext, step.initialized) = tickBitmap</span>
  744 |     | <span class='neutral'>                .nextInitializedTickWithinOneWord(</span>
  745 |     | <span class='unexecuted'>                    state.tick,</span>
  746 |     | <span class='unexecuted'>                    tickSpacing,</span>
  747 |     | <span class='unexecuted'>                    zeroForOne</span>
  748 |     | <span class='neutral'>                );</span>
  749 |     | <span class='neutral'></span>
  750 |     | <span class='neutral'>            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds</span>
  751 |     | <span class='unexecuted'>            if (step.tickNext &lt; TickMath.MIN_TICK) {</span>
  752 |     | <span class='unexecuted'>                step.tickNext = TickMath.MIN_TICK;</span>
  753 |     | <span class='unexecuted'>            } else if (step.tickNext &gt; TickMath.MAX_TICK) {</span>
  754 |     | <span class='unexecuted'>                step.tickNext = TickMath.MAX_TICK;</span>
  755 |     | <span class='neutral'>            }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>            // get the price for the next tick</span>
  758 |     | <span class='unexecuted'>            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);</span>
  759 |     | <span class='neutral'></span>
  760 |     | <span class='neutral'>            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted</span>
  761 |     | <span class='unexecuted'>            (</span>
  762 |     | <span class='unexecuted'>                state.sqrtPriceX96,</span>
  763 |     | <span class='unexecuted'>                step.amountIn,</span>
  764 |     | <span class='unexecuted'>                step.amountOut,</span>
  765 |     | <span class='unexecuted'>                step.feeAmount</span>
  766 |     | <span class='unexecuted'>            ) = SwapMath.computeSwapStep(</span>
  767 |     | <span class='unexecuted'>                state.sqrtPriceX96,</span>
  768 |     | <span class='unexecuted'>                (</span>
  769 |     | <span class='unexecuted'>                    zeroForOne</span>
  770 |     | <span class='unexecuted'>                        ? step.sqrtPriceNextX96 &lt; sqrtPriceLimitX96</span>
  771 |     | <span class='unexecuted'>                        : step.sqrtPriceNextX96 &gt; sqrtPriceLimitX96</span>
  772 |     | <span class='neutral'>                )</span>
  773 |     | <span class='unexecuted'>                    ? sqrtPriceLimitX96</span>
  774 |     | <span class='unexecuted'>                    : step.sqrtPriceNextX96,</span>
  775 |     | <span class='unexecuted'>                state.liquidity,</span>
  776 |     | <span class='unexecuted'>                state.amountSpecifiedRemaining,</span>
  777 |     | <span class='unexecuted'>                fee</span>
  778 |     | <span class='neutral'>            );</span>
  779 |     | <span class='neutral'></span>
  780 |     | <span class='unexecuted'>            if (exactInput) {</span>
  781 |     | <span class='unexecuted'>                state.amountSpecifiedRemaining -= (step.amountIn +</span>
  782 |     | <span class='unexecuted'>                    step.feeAmount).toInt256();</span>
  783 |     | <span class='unexecuted'>                state.amountCalculated = state.amountCalculated.sub(</span>
  784 |     | <span class='unexecuted'>                    step.amountOut.toInt256()</span>
  785 |     | <span class='neutral'>                );</span>
  786 |     | <span class='neutral'>            } else {</span>
  787 |     | <span class='unexecuted'>                state.amountSpecifiedRemaining += step.amountOut.toInt256();</span>
  788 |     | <span class='unexecuted'>                state.amountCalculated = state.amountCalculated.add(</span>
  789 |     | <span class='unexecuted'>                    (step.amountIn + step.feeAmount).toInt256()</span>
  790 |     | <span class='neutral'>                );</span>
  791 |     | <span class='neutral'>            }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee</span>
  794 |     | <span class='unexecuted'>            if (cache.feeProtocol &gt; 0) {</span>
  795 |     | <span class='unexecuted'>                uint256 delta = step.feeAmount / cache.feeProtocol;</span>
  796 |     | <span class='unexecuted'>                step.feeAmount -= delta;</span>
  797 |     | <span class='unexecuted'>                state.protocolFee += uint128(delta);</span>
  798 |     | <span class='neutral'>            }</span>
  799 |     | <span class='neutral'></span>
  800 |     | <span class='neutral'>            // update global fee tracker</span>
  801 |     | <span class='unexecuted'>            if (state.liquidity &gt; 0)</span>
  802 |     | <span class='unexecuted'>                state.feeGrowthGlobalX128 += FullMath.mulDiv(</span>
  803 |     | <span class='unexecuted'>                    step.feeAmount,</span>
  804 |     | <span class='neutral'>                    FixedPoint128.Q128,</span>
  805 |     | <span class='unexecuted'>                    state.liquidity</span>
  806 |     | <span class='neutral'>                );</span>
  807 |     | <span class='neutral'></span>
  808 |     | <span class='neutral'>            // shift tick if we reached the next price</span>
  809 |     | <span class='unexecuted'>            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {</span>
  810 |     | <span class='neutral'>                // if the tick is initialized, run the tick transition</span>
  811 |     | <span class='unexecuted'>                if (step.initialized) {</span>
  812 |     | <span class='neutral'>                    // check for the placeholder value, which we replace with the actual value the first time the swap</span>
  813 |     | <span class='neutral'>                    // crosses an initialized tick</span>
  814 |     | <span class='unexecuted'>                    if (!cache.computedLatestObservation) {</span>
  815 |     | <span class='unexecuted'>                        (</span>
  816 |     | <span class='unexecuted'>                            cache.tickCumulative,</span>
  817 |     | <span class='unexecuted'>                            cache.secondsPerLiquidityCumulativeX128</span>
  818 |     | <span class='unexecuted'>                        ) = observations.observeSingle(</span>
  819 |     | <span class='unexecuted'>                            cache.blockTimestamp,</span>
  820 |     | <span class='unexecuted'>                            0,</span>
  821 |     | <span class='unexecuted'>                            slot0Start.tick,</span>
  822 |     | <span class='unexecuted'>                            slot0Start.observationIndex,</span>
  823 |     | <span class='unexecuted'>                            cache.liquidityStart,</span>
  824 |     | <span class='unexecuted'>                            slot0Start.observationCardinality</span>
  825 |     | <span class='neutral'>                        );</span>
  826 |     | <span class='unexecuted'>                        cache.computedLatestObservation = true;</span>
  827 |     | <span class='neutral'>                    }</span>
  828 |     | <span class='unexecuted'>                    int128 liquidityNet = ticks.cross(</span>
  829 |     | <span class='unexecuted'>                        step.tickNext,</span>
  830 |     | <span class='neutral'>                        (</span>
  831 |     | <span class='unexecuted'>                            zeroForOne</span>
  832 |     | <span class='unexecuted'>                                ? state.feeGrowthGlobalX128</span>
  833 |     | <span class='unexecuted'>                                : feeGrowthGlobal0X128</span>
  834 |     | <span class='neutral'>                        ),</span>
  835 |     | <span class='neutral'>                        (</span>
  836 |     | <span class='unexecuted'>                            zeroForOne</span>
  837 |     | <span class='unexecuted'>                                ? feeGrowthGlobal1X128</span>
  838 |     | <span class='unexecuted'>                                : state.feeGrowthGlobalX128</span>
  839 |     | <span class='neutral'>                        ),</span>
  840 |     | <span class='unexecuted'>                        cache.secondsPerLiquidityCumulativeX128,</span>
  841 |     | <span class='unexecuted'>                        cache.tickCumulative,</span>
  842 |     | <span class='unexecuted'>                        cache.blockTimestamp</span>
  843 |     | <span class='neutral'>                    );</span>
  844 |     | <span class='neutral'>                    // if we&quot;re moving leftward, we interpret liquidityNet as the opposite sign</span>
  845 |     | <span class='neutral'>                    // safe because liquidityNet cannot be type(int128).min</span>
  846 |     | <span class='unexecuted'>                    if (zeroForOne) liquidityNet = -liquidityNet;</span>
  847 |     | <span class='neutral'></span>
  848 |     | <span class='unexecuted'>                    state.liquidity = LiquidityMath.addDelta(</span>
  849 |     | <span class='unexecuted'>                        state.liquidity,</span>
  850 |     | <span class='unexecuted'>                        liquidityNet</span>
  851 |     | <span class='neutral'>                    );</span>
  852 |     | <span class='neutral'>                }</span>
  853 |     | <span class='neutral'></span>
  854 |     | <span class='unexecuted'>                state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;</span>
  855 |     | <span class='unexecuted'>            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {</span>
  856 |     | <span class='neutral'>                // recompute unless we&quot;re on a lower tick boundary (i.e. already transitioned ticks), and haven&quot;t moved</span>
  857 |     | <span class='unexecuted'>                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);</span>
  858 |     | <span class='neutral'>            }</span>
  859 |     | <span class='neutral'>        }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>        // update tick and write an oracle entry if the tick change</span>
  862 |     | <span class='unexecuted'>        if (state.tick != slot0Start.tick) {</span>
  863 |     | <span class='unexecuted'>            (</span>
  864 |     | <span class='unexecuted'>                uint16 observationIndex,</span>
  865 |     | <span class='unexecuted'>                uint16 observationCardinality</span>
  866 |     | <span class='unexecuted'>            ) = observations.write(</span>
  867 |     | <span class='unexecuted'>                    slot0Start.observationIndex,</span>
  868 |     | <span class='unexecuted'>                    cache.blockTimestamp,</span>
  869 |     | <span class='unexecuted'>                    slot0Start.tick,</span>
  870 |     | <span class='unexecuted'>                    cache.liquidityStart,</span>
  871 |     | <span class='unexecuted'>                    slot0Start.observationCardinality,</span>
  872 |     | <span class='unexecuted'>                    slot0Start.observationCardinalityNext</span>
  873 |     | <span class='neutral'>                );</span>
  874 |     | <span class='unexecuted'>            (</span>
  875 |     | <span class='unexecuted'>                slot0.sqrtPriceX96,</span>
  876 |     | <span class='unexecuted'>                slot0.tick,</span>
  877 |     | <span class='unexecuted'>                slot0.observationIndex,</span>
  878 |     | <span class='unexecuted'>                slot0.observationCardinality</span>
  879 |     | <span class='neutral'>            ) = (</span>
  880 |     | <span class='unexecuted'>                state.sqrtPriceX96,</span>
  881 |     | <span class='unexecuted'>                state.tick,</span>
  882 |     | <span class='unexecuted'>                observationIndex,</span>
  883 |     | <span class='unexecuted'>                observationCardinality</span>
  884 |     | <span class='neutral'>            );</span>
  885 |     | <span class='neutral'>        } else {</span>
  886 |     | <span class='neutral'>            // otherwise just update the price</span>
  887 |     | <span class='unexecuted'>            slot0.sqrtPriceX96 = state.sqrtPriceX96;</span>
  888 |     | <span class='neutral'>        }</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='neutral'>        // update liquidity if it changed</span>
  891 |     | <span class='unexecuted'>        if (cache.liquidityStart != state.liquidity)</span>
  892 |     | <span class='unexecuted'>            liquidity = state.liquidity;</span>
  893 |     | <span class='neutral'></span>
  894 |     | <span class='neutral'>        // update fee growth global and, if necessary, protocol fees</span>
  895 |     | <span class='neutral'>        // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees</span>
  896 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
  897 |     | <span class='unexecuted'>            feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;</span>
  898 |     | <span class='unexecuted'>            if (state.protocolFee &gt; 0) protocolFees.token0 += state.protocolFee;</span>
  899 |     | <span class='neutral'>        } else {</span>
  900 |     | <span class='unexecuted'>            feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;</span>
  901 |     | <span class='unexecuted'>            if (state.protocolFee &gt; 0) protocolFees.token1 += state.protocolFee;</span>
  902 |     | <span class='neutral'>        }</span>
  903 |     | <span class='neutral'></span>
  904 |     | <span class='unexecuted'>        (amount0, amount1) = zeroForOne == exactInput</span>
  905 |     | <span class='neutral'>            ? (</span>
  906 |     | <span class='unexecuted'>                amountSpecified - state.amountSpecifiedRemaining,</span>
  907 |     | <span class='unexecuted'>                state.amountCalculated</span>
  908 |     | <span class='neutral'>            )</span>
  909 |     | <span class='neutral'>            : (</span>
  910 |     | <span class='unexecuted'>                state.amountCalculated,</span>
  911 |     | <span class='unexecuted'>                amountSpecified - state.amountSpecifiedRemaining</span>
  912 |     | <span class='neutral'>            );</span>
  913 |     | <span class='neutral'></span>
  914 |     | <span class='neutral'>        // do the transfers and collect payment</span>
  915 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
  916 |     | <span class='unexecuted'>            if (amount1 &lt; 0)</span>
  917 |     | <span class='unexecuted'>                TransferHelper.safeTransfer(</span>
  918 |     | <span class='unexecuted'>                    token1,</span>
  919 |     | <span class='unexecuted'>                    recipient,</span>
  920 |     | <span class='unexecuted'>                    uint256(-amount1)</span>
  921 |     | <span class='neutral'>                );</span>
  922 |     | <span class='neutral'></span>
  923 |     | <span class='unexecuted'>            uint256 balance0Before = balance0();</span>
  924 |     | <span class='unexecuted'>            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(</span>
  925 |     | <span class='unexecuted'>                amount0,</span>
  926 |     | <span class='unexecuted'>                amount1,</span>
  927 |     | <span class='unexecuted'>                data</span>
  928 |     | <span class='neutral'>            );</span>
  929 |     | <span class='unexecuted'>            require(balance0Before.add(uint256(amount0)) &lt;= balance0(), &quot;IIA&quot;);</span>
  930 |     | <span class='neutral'>        } else {</span>
  931 |     | <span class='unexecuted'>            if (amount0 &lt; 0)</span>
  932 |     | <span class='unexecuted'>                TransferHelper.safeTransfer(</span>
  933 |     | <span class='unexecuted'>                    token0,</span>
  934 |     | <span class='unexecuted'>                    recipient,</span>
  935 |     | <span class='unexecuted'>                    uint256(-amount0)</span>
  936 |     | <span class='neutral'>                );</span>
  937 |     | <span class='neutral'></span>
  938 |     | <span class='unexecuted'>            uint256 balance1Before = balance1();</span>
  939 |     | <span class='unexecuted'>            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(</span>
  940 |     | <span class='unexecuted'>                amount0,</span>
  941 |     | <span class='unexecuted'>                amount1,</span>
  942 |     | <span class='unexecuted'>                data</span>
  943 |     | <span class='neutral'>            );</span>
  944 |     | <span class='unexecuted'>            require(balance1Before.add(uint256(amount1)) &lt;= balance1(), &quot;IIA&quot;);</span>
  945 |     | <span class='neutral'>        }</span>
  946 |     | <span class='neutral'></span>
  947 |     | <span class='unexecuted'>        emit Swap(</span>
  948 |     | <span class='unexecuted'>            msg.sender,</span>
  949 |     | <span class='unexecuted'>            recipient,</span>
  950 |     | <span class='unexecuted'>            amount0,</span>
  951 |     | <span class='unexecuted'>            amount1,</span>
  952 |     | <span class='unexecuted'>            state.sqrtPriceX96,</span>
  953 |     | <span class='unexecuted'>            state.liquidity,</span>
  954 |     | <span class='unexecuted'>            state.tick</span>
  955 |     | <span class='neutral'>        );</span>
  956 |     | <span class='unexecuted'>        slot0.unlocked = true;</span>
  957 |     | <span class='neutral'>    }</span>
  958 |     | <span class='neutral'></span>
  959 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
  960 |     | <span class='unexecuted'>    function flash(</span>
  961 |     | <span class='neutral'>        address recipient,</span>
  962 |     | <span class='neutral'>        uint256 amount0,</span>
  963 |     | <span class='neutral'>        uint256 amount1,</span>
  964 |     | <span class='neutral'>        bytes calldata data</span>
  965 |     | <span class='neutral'>    ) external override lock noDelegateCall {</span>
  966 |     | <span class='unexecuted'>        uint128 _liquidity = liquidity;</span>
  967 |     | <span class='unexecuted'>        require(_liquidity &gt; 0, &quot;L&quot;);</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='unexecuted'>        uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);</span>
  970 |     | <span class='unexecuted'>        uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);</span>
  971 |     | <span class='unexecuted'>        uint256 balance0Before = balance0();</span>
  972 |     | <span class='unexecuted'>        uint256 balance1Before = balance1();</span>
  973 |     | <span class='neutral'></span>
  974 |     | <span class='unexecuted'>        if (amount0 &gt; 0)</span>
  975 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token0, recipient, amount0);</span>
  976 |     | <span class='unexecuted'>        if (amount1 &gt; 0)</span>
  977 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token1, recipient, amount1);</span>
  978 |     | <span class='neutral'></span>
  979 |     | <span class='unexecuted'>        IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(</span>
  980 |     | <span class='unexecuted'>            fee0,</span>
  981 |     | <span class='unexecuted'>            fee1,</span>
  982 |     | <span class='unexecuted'>            data</span>
  983 |     | <span class='neutral'>        );</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='unexecuted'>        uint256 balance0After = balance0();</span>
  986 |     | <span class='unexecuted'>        uint256 balance1After = balance1();</span>
  987 |     | <span class='neutral'></span>
  988 |     | <span class='unexecuted'>        require(balance0Before.add(fee0) &lt;= balance0After, &quot;F0&quot;);</span>
  989 |     | <span class='unexecuted'>        require(balance1Before.add(fee1) &lt;= balance1After, &quot;F1&quot;);</span>
  990 |     | <span class='neutral'></span>
  991 |     | <span class='neutral'>        // sub is safe because we know balanceAfter is gt balanceBefore by at least fee</span>
  992 |     | <span class='unexecuted'>        uint256 paid0 = balance0After - balance0Before;</span>
  993 |     | <span class='unexecuted'>        uint256 paid1 = balance1After - balance1Before;</span>
  994 |     | <span class='neutral'></span>
  995 |     | <span class='unexecuted'>        if (paid0 &gt; 0) {</span>
  996 |     | <span class='unexecuted'>            uint8 feeProtocol0 = slot0.feeProtocol % 16;</span>
  997 |     | <span class='unexecuted'>            uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;</span>
  998 |     | <span class='unexecuted'>            if (uint128(fees0) &gt; 0) protocolFees.token0 += uint128(fees0);</span>
  999 |     | <span class='unexecuted'>            feeGrowthGlobal0X128 += FullMath.mulDiv(</span>
 1000 |     | <span class='unexecuted'>                paid0 - fees0,</span>
 1001 |     | <span class='neutral'>                FixedPoint128.Q128,</span>
 1002 |     | <span class='unexecuted'>                _liquidity</span>
 1003 |     | <span class='neutral'>            );</span>
 1004 |     | <span class='neutral'>        }</span>
 1005 |     | <span class='unexecuted'>        if (paid1 &gt; 0) {</span>
 1006 |     | <span class='unexecuted'>            uint8 feeProtocol1 = slot0.feeProtocol &gt;&gt; 4;</span>
 1007 |     | <span class='unexecuted'>            uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;</span>
 1008 |     | <span class='unexecuted'>            if (uint128(fees1) &gt; 0) protocolFees.token1 += uint128(fees1);</span>
 1009 |     | <span class='unexecuted'>            feeGrowthGlobal1X128 += FullMath.mulDiv(</span>
 1010 |     | <span class='unexecuted'>                paid1 - fees1,</span>
 1011 |     | <span class='neutral'>                FixedPoint128.Q128,</span>
 1012 |     | <span class='unexecuted'>                _liquidity</span>
 1013 |     | <span class='neutral'>            );</span>
 1014 |     | <span class='neutral'>        }</span>
 1015 |     | <span class='neutral'></span>
 1016 |     | <span class='unexecuted'>        emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);</span>
 1017 |     | <span class='neutral'>    }</span>
 1018 |     | <span class='neutral'></span>
 1019 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolOwnerActions</span>
 1020 |     | <span class='unexecuted'>    function setFeeProtocol(</span>
 1021 |     | <span class='neutral'>        uint8 feeProtocol0,</span>
 1022 |     | <span class='neutral'>        uint8 feeProtocol1</span>
 1023 |     | <span class='neutral'>    ) external override lock onlyFactoryOwner {</span>
 1024 |     | <span class='unexecuted'>        require(</span>
 1025 |     | <span class='unexecuted'>            (feeProtocol0 == 0 || (feeProtocol0 &gt;= 4 &amp;&amp; feeProtocol0 &lt;= 10)) &amp;&amp;</span>
 1026 |     | <span class='unexecuted'>                (feeProtocol1 == 0 || (feeProtocol1 &gt;= 4 &amp;&amp; feeProtocol1 &lt;= 10))</span>
 1027 |     | <span class='neutral'>        );</span>
 1028 |     | <span class='unexecuted'>        uint8 feeProtocolOld = slot0.feeProtocol;</span>
 1029 |     | <span class='unexecuted'>        slot0.feeProtocol = feeProtocol0 + (feeProtocol1 &lt;&lt; 4);</span>
 1030 |     | <span class='unexecuted'>        emit SetFeeProtocol(</span>
 1031 |     | <span class='unexecuted'>            feeProtocolOld % 16,</span>
 1032 |     | <span class='unexecuted'>            feeProtocolOld &gt;&gt; 4,</span>
 1033 |     | <span class='unexecuted'>            feeProtocol0,</span>
 1034 |     | <span class='unexecuted'>            feeProtocol1</span>
 1035 |     | <span class='neutral'>        );</span>
 1036 |     | <span class='neutral'>    }</span>
 1037 |     | <span class='neutral'></span>
 1038 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolOwnerActions</span>
 1039 |     | <span class='unexecuted'>    function collectProtocol(</span>
 1040 |     | <span class='neutral'>        address recipient,</span>
 1041 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 1042 |     | <span class='neutral'>        uint128 amount1Requested</span>
 1043 |     | <span class='neutral'>    )</span>
 1044 |     | <span class='neutral'>        external</span>
 1045 |     | <span class='neutral'>        override</span>
 1046 |     | <span class='neutral'>        lock</span>
 1047 |     | <span class='neutral'>        onlyFactoryOwner</span>
 1048 |     | <span class='unexecuted'>        returns (uint128 amount0, uint128 amount1)</span>
 1049 |     | <span class='neutral'>    {</span>
 1050 |     | <span class='unexecuted'>        amount0 = amount0Requested &gt; protocolFees.token0</span>
 1051 |     | <span class='unexecuted'>            ? protocolFees.token0</span>
 1052 |     | <span class='unexecuted'>            : amount0Requested;</span>
 1053 |     | <span class='unexecuted'>        amount1 = amount1Requested &gt; protocolFees.token1</span>
 1054 |     | <span class='unexecuted'>            ? protocolFees.token1</span>
 1055 |     | <span class='unexecuted'>            : amount1Requested;</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
 1058 |     | <span class='unexecuted'>            if (amount0 == protocolFees.token0) amount0--; // ensure that the slot is not cleared, for gas savings</span>
 1059 |     | <span class='unexecuted'>            protocolFees.token0 -= amount0;</span>
 1060 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token0, recipient, amount0);</span>
 1061 |     | <span class='neutral'>        }</span>
 1062 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
 1063 |     | <span class='unexecuted'>            if (amount1 == protocolFees.token1) amount1--; // ensure that the slot is not cleared, for gas savings</span>
 1064 |     | <span class='unexecuted'>            protocolFees.token1 -= amount1;</span>
 1065 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token1, recipient, amount1);</span>
 1066 |     | <span class='neutral'>        }</span>
 1067 |     | <span class='neutral'></span>
 1068 |     | <span class='unexecuted'>        emit CollectProtocol(msg.sender, recipient, amount0, amount1);</span>
 1069 |     | <span class='neutral'>    }</span>
 1070 |     | <span class='neutral'>}</span>
 1071 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/UniswapV3PoolDeployer.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV3PoolDeployer.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./UniswapV3Pool.sol&quot;;</span>
  7 |     | <span class='unexecuted'></span>
  8 |     | <span class='neutral'>contract UniswapV3PoolDeployer is IUniswapV3PoolDeployer {</span>
  9 |     | <span class='neutral'>    struct Parameters {</span>
 10 |     | <span class='neutral'>        address factory;</span>
 11 |     | <span class='neutral'>        address token0;</span>
 12 |     | <span class='neutral'>        address token1;</span>
 13 |     | <span class='neutral'>        uint24 fee;</span>
 14 |     | <span class='neutral'>        int24 tickSpacing;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolDeployer</span>
 18 | *   | <span class='executed'>    Parameters public override parameters;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then</span>
 21 |     | <span class='neutral'>    /// clearing it after deploying the pool.</span>
 22 |     | <span class='neutral'>    /// @param factory The contract address of the Uniswap V3 factory</span>
 23 |     | <span class='neutral'>    /// @param token0 The first token of the pool by address sort order</span>
 24 |     | <span class='neutral'>    /// @param token1 The second token of the pool by address sort order</span>
 25 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 26 |     | <span class='neutral'>    /// @param tickSpacing The spacing between usable ticks</span>
 27 | *   | <span class='executed'>    function deploy(</span>
 28 |     | <span class='neutral'>        address factory,</span>
 29 |     | <span class='neutral'>        address token0,</span>
 30 |     | <span class='neutral'>        address token1,</span>
 31 |     | <span class='neutral'>        uint24 fee,</span>
 32 |     | <span class='neutral'>        int24 tickSpacing</span>
 33 | *   | <span class='executed'>    ) internal returns (address pool) {</span>
 34 | *   | <span class='executed'>        parameters = Parameters({factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing});</span>
 35 | *   | <span class='executed'>        pool = address(new UniswapV3Pool{salt: keccak256(abi.encode(token0, token1, fee))}());</span>
 36 | *   | <span class='executed'>        delete parameters;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>}</span>
 39 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/WETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.4.0 &lt;0.8.0;</span>
  3 | *r  | <span class='executed'></span>
  4 |     | <span class='neutral'>contract WETH9 {</span>
  5 | *r  | <span class='executed'>    string public name     = &quot;Wrapped Ether&quot;;</span>
  6 | *   | <span class='executed'>    string public symbol   = &quot;WETH&quot;;</span>
  7 | *r  | <span class='executed'>    uint8  public decimals = 18;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    event  Approval(address indexed src, address indexed guy, uint wad);</span>
 10 |     | <span class='neutral'>    event  Transfer(address indexed src, address indexed dst, uint wad);</span>
 11 |     | <span class='neutral'>    event  Deposit(address indexed dst, uint wad);</span>
 12 |     | <span class='neutral'>    event  Withdrawal(address indexed src, uint wad);</span>
 13 |     | <span class='neutral'></span>
 14 | *r  | <span class='executed'>    mapping (address =&gt; uint)                       public  balanceOf;</span>
 15 | *r  | <span class='executed'>    mapping (address =&gt; mapping (address =&gt; uint))  public  allowance;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // function() public payable {</span>
 18 |     | <span class='neutral'>    //     deposit();</span>
 19 |     | <span class='neutral'>    // }</span>
 20 | *   | <span class='executed'>    function deposit() public payable {</span>
 21 | *   | <span class='executed'>        balanceOf[msg.sender] += msg.value;</span>
 22 | *   | <span class='executed'>        Deposit(msg.sender, msg.value);</span>
 23 |     | <span class='neutral'>    }</span>
 24 | *r  | <span class='executed'>    function withdraw(uint wad) public {</span>
 25 | *r  | <span class='executed'>        require(balanceOf[msg.sender] &gt;= wad);</span>
 26 | *   | <span class='executed'>        balanceOf[msg.sender] -= wad;</span>
 27 | *   | <span class='executed'>        msg.sender.transfer(wad);</span>
 28 | *   | <span class='executed'>        Withdrawal(msg.sender, wad);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 | *r  | <span class='executed'>    function totalSupply() public view returns (uint) {</span>
 32 | *   | <span class='executed'>        return address(this).balance;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 | *   | <span class='executed'>    function approve(address guy, uint wad) public returns (bool) {</span>
 36 | *   | <span class='executed'>        allowance[msg.sender][guy] = wad;</span>
 37 | *   | <span class='executed'>        Approval(msg.sender, guy, wad);</span>
 38 | *   | <span class='executed'>        return true;</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 | *r  | <span class='executed'>    function transfer(address dst, uint wad) public returns (bool) {</span>
 42 | *r  | <span class='executed'>        return transferFrom(msg.sender, dst, wad);</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 | *r  | <span class='executed'>    function transferFrom(address src, address dst, uint wad)</span>
 46 |     | <span class='neutral'>        public</span>
 47 | *r  | <span class='executed'>        returns (bool)</span>
 48 |     | <span class='neutral'>    {</span>
 49 | *r  | <span class='executed'>        require(balanceOf[src] &gt;= wad);</span>
 50 |     | <span class='neutral'></span>
 51 | *r  | <span class='executed'>        if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != uint(-1)) {</span>
 52 | *r  | <span class='executed'>            require(allowance[src][msg.sender] &gt;= wad);</span>
 53 | *   | <span class='executed'>            allowance[src][msg.sender] -= wad;</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'></span>
 56 | *   | <span class='executed'>        balanceOf[src] -= wad;</span>
 57 | *   | <span class='executed'>        balanceOf[dst] += wad;</span>
 58 |     | <span class='neutral'></span>
 59 | *   | <span class='executed'>        Transfer(src, dst, wad);</span>
 60 |     | <span class='neutral'></span>
 61 | *   | <span class='executed'>        return true;</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'>}</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/IERC20Minimal.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Minimal ERC20 interface for Uniswap</span>
  5 |     | <span class='neutral'>/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3</span>
  6 |     | <span class='neutral'>interface IERC20Minimal {</span>
  7 |     | <span class='neutral'>    /// @notice Returns the balance of a token</span>
  8 |     | <span class='neutral'>    /// @param account The account for which to look up the number of tokens it has, i.e. its balance</span>
  9 |     | <span class='neutral'>    /// @return The number of tokens held by the account</span>
 10 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice Transfers the amount of token from the `msg.sender` to the recipient</span>
 13 |     | <span class='neutral'>    /// @param recipient The account that will receive the amount transferred</span>
 14 |     | <span class='neutral'>    /// @param amount The number of tokens to send from the sender to the recipient</span>
 15 |     | <span class='neutral'>    /// @return Returns true for a successful transfer, false for an unsuccessful transfer</span>
 16 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @notice Returns the current allowance given to a spender by an owner</span>
 19 |     | <span class='neutral'>    /// @param owner The account of the token owner</span>
 20 |     | <span class='neutral'>    /// @param spender The account of the token spender</span>
 21 |     | <span class='neutral'>    /// @return The current allowance granted by `owner` to `spender`</span>
 22 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`</span>
 25 |     | <span class='neutral'>    /// @param spender The account which will be allowed to spend a given amount of the owners tokens</span>
 26 |     | <span class='neutral'>    /// @param amount The amount of tokens allowed to be used by `spender`</span>
 27 |     | <span class='neutral'>    /// @return Returns true for a successful approval, false for unsuccessful</span>
 28 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`</span>
 31 |     | <span class='neutral'>    /// @param sender The account from which the transfer will be initiated</span>
 32 |     | <span class='neutral'>    /// @param recipient The recipient of the transfer</span>
 33 |     | <span class='neutral'>    /// @param amount The amount of the transfer</span>
 34 |     | <span class='neutral'>    /// @return Returns true for a successful transfer, false for unsuccessful</span>
 35 |     | <span class='neutral'>    function transferFrom(</span>
 36 |     | <span class='neutral'>        address sender,</span>
 37 |     | <span class='neutral'>        address recipient,</span>
 38 |     | <span class='neutral'>        uint256 amount</span>
 39 |     | <span class='neutral'>    ) external returns (bool);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.</span>
 42 |     | <span class='neutral'>    /// @param from The account from which the tokens were sent, i.e. the balance decreased</span>
 43 |     | <span class='neutral'>    /// @param to The account to which the tokens were sent, i.e. the balance increased</span>
 44 |     | <span class='neutral'>    /// @param value The amount of tokens that were transferred</span>
 45 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /// @notice Event emitted when the approval amount for the spender of a given owner&#39;s tokens changes.</span>
 48 |     | <span class='neutral'>    /// @param owner The account that approved spending of its tokens</span>
 49 |     | <span class='neutral'>    /// @param spender The account for which the spending allowance was modified</span>
 50 |     | <span class='neutral'>    /// @param value The new allowance from the owner to the spender</span>
 51 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/IUniswapV3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title The interface for the Uniswap V3 Factory</span>
  5 |     | <span class='neutral'>/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees</span>
  6 |     | <span class='neutral'>interface IUniswapV3Factory {</span>
  7 |     | <span class='neutral'>    /// @notice Emitted when the owner of the factory is changed</span>
  8 |     | <span class='neutral'>    /// @param oldOwner The owner before the owner was changed</span>
  9 |     | <span class='neutral'>    /// @param newOwner The owner after the owner was changed</span>
 10 |     | <span class='neutral'>    event OwnerChanged(address indexed oldOwner, address indexed newOwner);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice Emitted when a pool is created</span>
 13 |     | <span class='neutral'>    /// @param token0 The first token of the pool by address sort order</span>
 14 |     | <span class='neutral'>    /// @param token1 The second token of the pool by address sort order</span>
 15 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 16 |     | <span class='neutral'>    /// @param tickSpacing The minimum number of ticks between initialized ticks</span>
 17 |     | <span class='neutral'>    /// @param pool The address of the created pool</span>
 18 |     | <span class='neutral'>    event PoolCreated(</span>
 19 |     | <span class='neutral'>        address indexed token0,</span>
 20 |     | <span class='neutral'>        address indexed token1,</span>
 21 |     | <span class='neutral'>        uint24 indexed fee,</span>
 22 |     | <span class='neutral'>        int24 tickSpacing,</span>
 23 |     | <span class='neutral'>        address pool</span>
 24 |     | <span class='neutral'>    );</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory</span>
 27 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip</span>
 28 |     | <span class='neutral'>    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee</span>
 29 |     | <span class='neutral'>    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Returns the current owner of the factory</span>
 32 |     | <span class='neutral'>    /// @dev Can be changed by the current owner via setOwner</span>
 33 |     | <span class='neutral'>    /// @return The address of the factory owner</span>
 34 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled</span>
 37 |     | <span class='neutral'>    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context</span>
 38 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee</span>
 39 |     | <span class='neutral'>    /// @return The tick spacing</span>
 40 |     | <span class='neutral'>    function feeAmountTickSpacing(uint24 fee) external view returns (int24);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist</span>
 43 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order</span>
 44 |     | <span class='neutral'>    /// @param tokenA The contract address of either token0 or token1</span>
 45 |     | <span class='neutral'>    /// @param tokenB The contract address of the other token</span>
 46 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 47 |     | <span class='neutral'>    /// @return pool The pool address</span>
 48 |     | <span class='neutral'>    function getPool(</span>
 49 |     | <span class='neutral'>        address tokenA,</span>
 50 |     | <span class='neutral'>        address tokenB,</span>
 51 |     | <span class='neutral'>        uint24 fee</span>
 52 |     | <span class='neutral'>    ) external view returns (address pool);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /// @notice Creates a pool for the given two tokens and fee</span>
 55 |     | <span class='neutral'>    /// @param tokenA One of the two tokens in the desired pool</span>
 56 |     | <span class='neutral'>    /// @param tokenB The other of the two tokens in the desired pool</span>
 57 |     | <span class='neutral'>    /// @param fee The desired fee for the pool</span>
 58 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved</span>
 59 |     | <span class='neutral'>    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments</span>
 60 |     | <span class='neutral'>    /// are invalid.</span>
 61 |     | <span class='neutral'>    /// @return pool The address of the newly created pool</span>
 62 |     | <span class='neutral'>    function createPool(</span>
 63 |     | <span class='neutral'>        address tokenA,</span>
 64 |     | <span class='neutral'>        address tokenB,</span>
 65 |     | <span class='neutral'>        uint24 fee</span>
 66 |     | <span class='neutral'>    ) external returns (address pool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /// @notice Updates the owner of the factory</span>
 69 |     | <span class='neutral'>    /// @dev Must be called by the current owner</span>
 70 |     | <span class='neutral'>    /// @param _owner The new owner of the factory</span>
 71 |     | <span class='neutral'>    function setOwner(address _owner) external;</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    /// @notice Enables a fee amount with the given tickSpacing</span>
 74 |     | <span class='neutral'>    /// @dev Fee amounts may never be removed once enabled</span>
 75 |     | <span class='neutral'>    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)</span>
 76 |     | <span class='neutral'>    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount</span>
 77 |     | <span class='neutral'>    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/IUniswapV3Pool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./pool/IUniswapV3PoolImmutables.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;./pool/IUniswapV3PoolState.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./pool/IUniswapV3PoolDerivedState.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./pool/IUniswapV3PoolActions.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./pool/IUniswapV3PoolOwnerActions.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;./pool/IUniswapV3PoolEvents.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/// @title The interface for a Uniswap V3 Pool</span>
 12 |     | <span class='neutral'>/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform</span>
 13 |     | <span class='neutral'>/// to the ERC20 specification</span>
 14 |     | <span class='neutral'>/// @dev The pool interface is broken up into many smaller pieces</span>
 15 |     | <span class='neutral'>interface IUniswapV3Pool is</span>
 16 |     | <span class='neutral'>    IUniswapV3PoolImmutables,</span>
 17 |     | <span class='neutral'>    IUniswapV3PoolState,</span>
 18 |     | <span class='neutral'>    IUniswapV3PoolDerivedState,</span>
 19 |     | <span class='neutral'>    IUniswapV3PoolActions,</span>
 20 |     | <span class='neutral'>    IUniswapV3PoolOwnerActions,</span>
 21 |     | <span class='neutral'>    IUniswapV3PoolEvents</span>
 22 |     | <span class='neutral'>{</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/IUniswapV3PoolDeployer.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title An interface for a contract that is capable of deploying Uniswap V3 Pools</span>
  5 |     | <span class='neutral'>/// @notice A contract that constructs a pool must implement this to pass arguments to the pool</span>
  6 |     | <span class='neutral'>/// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash</span>
  7 |     | <span class='neutral'>/// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain</span>
  8 |     | <span class='neutral'>interface IUniswapV3PoolDeployer {</span>
  9 |     | <span class='neutral'>    /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.</span>
 10 |     | <span class='neutral'>    /// @dev Called by the pool constructor to fetch the parameters of the pool</span>
 11 |     | <span class='neutral'>    /// Returns factory The factory address</span>
 12 |     | <span class='neutral'>    /// Returns token0 The first token of the pool by address sort order</span>
 13 |     | <span class='neutral'>    /// Returns token1 The second token of the pool by address sort order</span>
 14 |     | <span class='neutral'>    /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 15 |     | <span class='neutral'>    /// Returns tickSpacing The minimum number of ticks between initialized ticks</span>
 16 |     | <span class='neutral'>    function parameters()</span>
 17 |     | <span class='neutral'>        external</span>
 18 |     | <span class='neutral'>        view</span>
 19 |     | <span class='neutral'>        returns (</span>
 20 |     | <span class='neutral'>            address factory,</span>
 21 |     | <span class='neutral'>            address token0,</span>
 22 |     | <span class='neutral'>            address token1,</span>
 23 |     | <span class='neutral'>            uint24 fee,</span>
 24 |     | <span class='neutral'>            int24 tickSpacing</span>
 25 |     | <span class='neutral'>        );</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/callback/IUniswapV3FlashCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#flash</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface</span>
  6 |     | <span class='neutral'>interface IUniswapV3FlashCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.</span>
  9 |     | <span class='neutral'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// @param fee0 The fee amount in token0 due to the pool by the end of the flash</span>
 11 |     | <span class='neutral'>    /// @param fee1 The fee amount in token1 due to the pool by the end of the flash</span>
 12 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call</span>
 13 |     | <span class='neutral'>    function uniswapV3FlashCallback(</span>
 14 |     | <span class='neutral'>        uint256 fee0,</span>
 15 |     | <span class='neutral'>        uint256 fee1,</span>
 16 |     | <span class='neutral'>        bytes calldata data</span>
 17 |     | <span class='neutral'>    ) external;</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/callback/IUniswapV3MintCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#mint</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface</span>
  6 |     | <span class='neutral'>interface IUniswapV3MintCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.</span>
  9 |     | <span class='neutral'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity</span>
 11 |     | <span class='neutral'>    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity</span>
 12 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call</span>
 13 |     | <span class='neutral'>    function uniswapV3MintCallback(</span>
 14 |     | <span class='neutral'>        uint256 amount0Owed,</span>
 15 |     | <span class='neutral'>        uint256 amount1Owed,</span>
 16 |     | <span class='neutral'>        bytes calldata data</span>
 17 |     | <span class='neutral'>    ) external;</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/callback/IUniswapV3SwapCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#swap</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface</span>
  6 |     | <span class='neutral'>interface IUniswapV3SwapCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
  9 |     | <span class='neutral'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 11 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by</span>
 12 |     | <span class='neutral'>    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.</span>
 13 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by</span>
 14 |     | <span class='neutral'>    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.</span>
 15 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call</span>
 16 |     | <span class='neutral'>    function uniswapV3SwapCallback(</span>
 17 |     | <span class='neutral'>        int256 amount0Delta,</span>
 18 |     | <span class='neutral'>        int256 amount1Delta,</span>
 19 |     | <span class='neutral'>        bytes calldata data</span>
 20 |     | <span class='neutral'>    ) external;</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolActions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Permissionless pool actions</span>
   5 |     | <span class='neutral'>/// @notice Contains pool methods that can be called by anyone</span>
   6 |     | <span class='neutral'>interface IUniswapV3PoolActions {</span>
   7 |     | <span class='neutral'>    /// @notice Sets the initial price for the pool</span>
   8 |     | <span class='neutral'>    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value</span>
   9 |     | <span class='neutral'>    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96</span>
  10 |     | <span class='neutral'>    function initialize(uint160 sqrtPriceX96) external;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position</span>
  13 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback</span>
  14 |     | <span class='neutral'>    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends</span>
  15 |     | <span class='neutral'>    /// on tickLower, tickUpper, the amount of liquidity, and the current price.</span>
  16 |     | <span class='neutral'>    /// @param recipient The address for which the liquidity will be created</span>
  17 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position in which to add liquidity</span>
  18 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position in which to add liquidity</span>
  19 |     | <span class='neutral'>    /// @param amount The amount of liquidity to mint</span>
  20 |     | <span class='neutral'>    /// @param data Any data that should be passed through to the callback</span>
  21 |     | <span class='neutral'>    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
  22 |     | <span class='neutral'>    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
  23 |     | <span class='neutral'>    function mint(</span>
  24 |     | <span class='neutral'>        address recipient,</span>
  25 |     | <span class='neutral'>        int24 tickLower,</span>
  26 |     | <span class='neutral'>        int24 tickUpper,</span>
  27 |     | <span class='neutral'>        uint128 amount,</span>
  28 |     | <span class='neutral'>        bytes calldata data</span>
  29 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /// @notice Collects tokens owed to a position</span>
  32 |     | <span class='neutral'>    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.</span>
  33 |     | <span class='neutral'>    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or</span>
  34 |     | <span class='neutral'>    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the</span>
  35 |     | <span class='neutral'>    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.</span>
  36 |     | <span class='neutral'>    /// @param recipient The address which should receive the fees collected</span>
  37 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to collect fees</span>
  38 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to collect fees</span>
  39 |     | <span class='neutral'>    /// @param amount0Requested How much token0 should be withdrawn from the fees owed</span>
  40 |     | <span class='neutral'>    /// @param amount1Requested How much token1 should be withdrawn from the fees owed</span>
  41 |     | <span class='neutral'>    /// @return amount0 The amount of fees collected in token0</span>
  42 |     | <span class='neutral'>    /// @return amount1 The amount of fees collected in token1</span>
  43 |     | <span class='neutral'>    function collect(</span>
  44 |     | <span class='neutral'>        address recipient,</span>
  45 |     | <span class='neutral'>        int24 tickLower,</span>
  46 |     | <span class='neutral'>        int24 tickUpper,</span>
  47 |     | <span class='neutral'>        uint128 amount0Requested,</span>
  48 |     | <span class='neutral'>        uint128 amount1Requested</span>
  49 |     | <span class='neutral'>    ) external returns (uint128 amount0, uint128 amount1);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position</span>
  52 |     | <span class='neutral'>    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0</span>
  53 |     | <span class='neutral'>    /// @dev Fees must be collected separately via a call to #collect</span>
  54 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to burn liquidity</span>
  55 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to burn liquidity</span>
  56 |     | <span class='neutral'>    /// @param amount How much liquidity to burn</span>
  57 |     | <span class='neutral'>    /// @return amount0 The amount of token0 sent to the recipient</span>
  58 |     | <span class='neutral'>    /// @return amount1 The amount of token1 sent to the recipient</span>
  59 |     | <span class='neutral'>    function burn(</span>
  60 |     | <span class='neutral'>        int24 tickLower,</span>
  61 |     | <span class='neutral'>        int24 tickUpper,</span>
  62 |     | <span class='neutral'>        uint128 amount</span>
  63 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice Swap token0 for token1, or token1 for token0</span>
  66 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback</span>
  67 |     | <span class='neutral'>    /// @param recipient The address to receive the output of the swap</span>
  68 |     | <span class='neutral'>    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0</span>
  69 |     | <span class='neutral'>    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)</span>
  70 |     | <span class='neutral'>    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this</span>
  71 |     | <span class='neutral'>    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap</span>
  72 |     | <span class='neutral'>    /// @param data Any data to be passed through to the callback</span>
  73 |     | <span class='neutral'>    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive</span>
  74 |     | <span class='neutral'>    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive</span>
  75 |     | <span class='neutral'>    function swap(</span>
  76 |     | <span class='neutral'>        address recipient,</span>
  77 |     | <span class='neutral'>        bool zeroForOne,</span>
  78 |     | <span class='neutral'>        int256 amountSpecified,</span>
  79 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96,</span>
  80 |     | <span class='neutral'>        bytes calldata data</span>
  81 |     | <span class='neutral'>    ) external returns (int256 amount0, int256 amount1);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback</span>
  84 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback</span>
  85 |     | <span class='neutral'>    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling</span>
  86 |     | <span class='neutral'>    /// with 0 amount{0,1} and sending the donation amount(s) from the callback</span>
  87 |     | <span class='neutral'>    /// @param recipient The address which will receive the token0 and token1 amounts</span>
  88 |     | <span class='neutral'>    /// @param amount0 The amount of token0 to send</span>
  89 |     | <span class='neutral'>    /// @param amount1 The amount of token1 to send</span>
  90 |     | <span class='neutral'>    /// @param data Any data to be passed through to the callback</span>
  91 |     | <span class='neutral'>    function flash(</span>
  92 |     | <span class='neutral'>        address recipient,</span>
  93 |     | <span class='neutral'>        uint256 amount0,</span>
  94 |     | <span class='neutral'>        uint256 amount1,</span>
  95 |     | <span class='neutral'>        bytes calldata data</span>
  96 |     | <span class='neutral'>    ) external;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice Increase the maximum number of price and liquidity observations that this pool will store</span>
  99 |     | <span class='neutral'>    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to</span>
 100 |     | <span class='neutral'>    /// the input observationCardinalityNext.</span>
 101 |     | <span class='neutral'>    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store</span>
 102 |     | <span class='neutral'>    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;</span>
 103 |     | <span class='neutral'>}</span>
 104 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolDerivedState.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Pool state that is not stored</span>
  5 |     | <span class='neutral'>/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the</span>
  6 |     | <span class='neutral'>/// blockchain. The functions here may have variable gas costs.</span>
  7 |     | <span class='neutral'>interface IUniswapV3PoolDerivedState {</span>
  8 |     | <span class='neutral'>    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp</span>
  9 |     | <span class='neutral'>    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing</span>
 10 |     | <span class='neutral'>    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,</span>
 11 |     | <span class='neutral'>    /// you must call it with secondsAgos = [3600, 0].</span>
 12 |     | <span class='neutral'>    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in</span>
 13 |     | <span class='neutral'>    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.</span>
 14 |     | <span class='neutral'>    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned</span>
 15 |     | <span class='neutral'>    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp</span>
 16 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block</span>
 17 |     | <span class='neutral'>    /// timestamp</span>
 18 |     | <span class='neutral'>    function observe(uint32[] calldata secondsAgos)</span>
 19 |     | <span class='neutral'>        external</span>
 20 |     | <span class='neutral'>        view</span>
 21 |     | <span class='neutral'>        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range</span>
 24 |     | <span class='neutral'>    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.</span>
 25 |     | <span class='neutral'>    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first</span>
 26 |     | <span class='neutral'>    /// snapshot is taken and the second snapshot is taken.</span>
 27 |     | <span class='neutral'>    /// @param tickLower The lower tick of the range</span>
 28 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the range</span>
 29 |     | <span class='neutral'>    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range</span>
 30 |     | <span class='neutral'>    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range</span>
 31 |     | <span class='neutral'>    /// @return secondsInside The snapshot of seconds per liquidity for the range</span>
 32 |     | <span class='neutral'>    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)</span>
 33 |     | <span class='neutral'>        external</span>
 34 |     | <span class='neutral'>        view</span>
 35 |     | <span class='neutral'>        returns (</span>
 36 |     | <span class='neutral'>            int56 tickCumulativeInside,</span>
 37 |     | <span class='neutral'>            uint160 secondsPerLiquidityInsideX128,</span>
 38 |     | <span class='neutral'>            uint32 secondsInside</span>
 39 |     | <span class='neutral'>        );</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolEvents.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Events emitted by a pool</span>
   5 |     | <span class='neutral'>/// @notice Contains all events emitted by the pool</span>
   6 |     | <span class='neutral'>interface IUniswapV3PoolEvents {</span>
   7 |     | <span class='neutral'>    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool</span>
   8 |     | <span class='neutral'>    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize</span>
   9 |     | <span class='neutral'>    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96</span>
  10 |     | <span class='neutral'>    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool</span>
  11 |     | <span class='neutral'>    event Initialize(uint160 sqrtPriceX96, int24 tick);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /// @notice Emitted when liquidity is minted for a given position</span>
  14 |     | <span class='neutral'>    /// @param sender The address that minted the liquidity</span>
  15 |     | <span class='neutral'>    /// @param owner The owner of the position and recipient of any minted liquidity</span>
  16 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  17 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position</span>
  18 |     | <span class='neutral'>    /// @param amount The amount of liquidity minted to the position range</span>
  19 |     | <span class='neutral'>    /// @param amount0 How much token0 was required for the minted liquidity</span>
  20 |     | <span class='neutral'>    /// @param amount1 How much token1 was required for the minted liquidity</span>
  21 |     | <span class='neutral'>    event Mint(</span>
  22 |     | <span class='neutral'>        address sender,</span>
  23 |     | <span class='neutral'>        address indexed owner,</span>
  24 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  25 |     | <span class='neutral'>        int24 indexed tickUpper,</span>
  26 |     | <span class='neutral'>        uint128 amount,</span>
  27 |     | <span class='neutral'>        uint256 amount0,</span>
  28 |     | <span class='neutral'>        uint256 amount1</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /// @notice Emitted when fees are collected by the owner of a position</span>
  32 |     | <span class='neutral'>    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees</span>
  33 |     | <span class='neutral'>    /// @param owner The owner of the position for which fees are collected</span>
  34 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  35 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position</span>
  36 |     | <span class='neutral'>    /// @param amount0 The amount of token0 fees collected</span>
  37 |     | <span class='neutral'>    /// @param amount1 The amount of token1 fees collected</span>
  38 |     | <span class='neutral'>    event Collect(</span>
  39 |     | <span class='neutral'>        address indexed owner,</span>
  40 |     | <span class='neutral'>        address recipient,</span>
  41 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  42 |     | <span class='neutral'>        int24 indexed tickUpper,</span>
  43 |     | <span class='neutral'>        uint128 amount0,</span>
  44 |     | <span class='neutral'>        uint128 amount1</span>
  45 |     | <span class='neutral'>    );</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Emitted when a position&#39;s liquidity is removed</span>
  48 |     | <span class='neutral'>    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect</span>
  49 |     | <span class='neutral'>    /// @param owner The owner of the position for which liquidity is removed</span>
  50 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  51 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position</span>
  52 |     | <span class='neutral'>    /// @param amount The amount of liquidity to remove</span>
  53 |     | <span class='neutral'>    /// @param amount0 The amount of token0 withdrawn</span>
  54 |     | <span class='neutral'>    /// @param amount1 The amount of token1 withdrawn</span>
  55 |     | <span class='neutral'>    event Burn(</span>
  56 |     | <span class='neutral'>        address indexed owner,</span>
  57 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  58 |     | <span class='neutral'>        int24 indexed tickUpper,</span>
  59 |     | <span class='neutral'>        uint128 amount,</span>
  60 |     | <span class='neutral'>        uint256 amount0,</span>
  61 |     | <span class='neutral'>        uint256 amount1</span>
  62 |     | <span class='neutral'>    );</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /// @notice Emitted by the pool for any swaps between token0 and token1</span>
  65 |     | <span class='neutral'>    /// @param sender The address that initiated the swap call, and that received the callback</span>
  66 |     | <span class='neutral'>    /// @param recipient The address that received the output of the swap</span>
  67 |     | <span class='neutral'>    /// @param amount0 The delta of the token0 balance of the pool</span>
  68 |     | <span class='neutral'>    /// @param amount1 The delta of the token1 balance of the pool</span>
  69 |     | <span class='neutral'>    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96</span>
  70 |     | <span class='neutral'>    /// @param liquidity The liquidity of the pool after the swap</span>
  71 |     | <span class='neutral'>    /// @param tick The log base 1.0001 of price of the pool after the swap</span>
  72 |     | <span class='neutral'>    event Swap(</span>
  73 |     | <span class='neutral'>        address indexed sender,</span>
  74 |     | <span class='neutral'>        address indexed recipient,</span>
  75 |     | <span class='neutral'>        int256 amount0,</span>
  76 |     | <span class='neutral'>        int256 amount1,</span>
  77 |     | <span class='neutral'>        uint160 sqrtPriceX96,</span>
  78 |     | <span class='neutral'>        uint128 liquidity,</span>
  79 |     | <span class='neutral'>        int24 tick</span>
  80 |     | <span class='neutral'>    );</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /// @notice Emitted by the pool for any flashes of token0/token1</span>
  83 |     | <span class='neutral'>    /// @param sender The address that initiated the swap call, and that received the callback</span>
  84 |     | <span class='neutral'>    /// @param recipient The address that received the tokens from flash</span>
  85 |     | <span class='neutral'>    /// @param amount0 The amount of token0 that was flashed</span>
  86 |     | <span class='neutral'>    /// @param amount1 The amount of token1 that was flashed</span>
  87 |     | <span class='neutral'>    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee</span>
  88 |     | <span class='neutral'>    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee</span>
  89 |     | <span class='neutral'>    event Flash(</span>
  90 |     | <span class='neutral'>        address indexed sender,</span>
  91 |     | <span class='neutral'>        address indexed recipient,</span>
  92 |     | <span class='neutral'>        uint256 amount0,</span>
  93 |     | <span class='neutral'>        uint256 amount1,</span>
  94 |     | <span class='neutral'>        uint256 paid0,</span>
  95 |     | <span class='neutral'>        uint256 paid1</span>
  96 |     | <span class='neutral'>    );</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice Emitted by the pool for increases to the number of observations that can be stored</span>
  99 |     | <span class='neutral'>    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index</span>
 100 |     | <span class='neutral'>    /// just before a mint/swap/burn.</span>
 101 |     | <span class='neutral'>    /// @param observationCardinalityNextOld The previous value of the next observation cardinality</span>
 102 |     | <span class='neutral'>    /// @param observationCardinalityNextNew The updated value of the next observation cardinality</span>
 103 |     | <span class='neutral'>    event IncreaseObservationCardinalityNext(</span>
 104 |     | <span class='neutral'>        uint16 observationCardinalityNextOld,</span>
 105 |     | <span class='neutral'>        uint16 observationCardinalityNextNew</span>
 106 |     | <span class='neutral'>    );</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Emitted when the protocol fee is changed by the pool</span>
 109 |     | <span class='neutral'>    /// @param feeProtocol0Old The previous value of the token0 protocol fee</span>
 110 |     | <span class='neutral'>    /// @param feeProtocol1Old The previous value of the token1 protocol fee</span>
 111 |     | <span class='neutral'>    /// @param feeProtocol0New The updated value of the token0 protocol fee</span>
 112 |     | <span class='neutral'>    /// @param feeProtocol1New The updated value of the token1 protocol fee</span>
 113 |     | <span class='neutral'>    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner</span>
 116 |     | <span class='neutral'>    /// @param sender The address that collects the protocol fees</span>
 117 |     | <span class='neutral'>    /// @param recipient The address that receives the collected protocol fees</span>
 118 |     | <span class='neutral'>    /// @param amount0 The amount of token0 protocol fees that is withdrawn</span>
 119 |     | <span class='neutral'>    /// @param amount0 The amount of token1 protocol fees that is withdrawn</span>
 120 |     | <span class='neutral'>    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolImmutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Pool state that never changes</span>
  5 |     | <span class='neutral'>/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values</span>
  6 |     | <span class='neutral'>interface IUniswapV3PoolImmutables {</span>
  7 |     | <span class='neutral'>    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface</span>
  8 |     | <span class='neutral'>    /// @return The contract address</span>
  9 |     | <span class='neutral'>    function factory() external view returns (address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    /// @notice The first of the two tokens of the pool, sorted by address</span>
 12 |     | <span class='neutral'>    /// @return The token contract address</span>
 13 |     | <span class='neutral'>    function token0() external view returns (address);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @notice The second of the two tokens of the pool, sorted by address</span>
 16 |     | <span class='neutral'>    /// @return The token contract address</span>
 17 |     | <span class='neutral'>    function token1() external view returns (address);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice The pool&#39;s fee in hundredths of a bip, i.e. 1e-6</span>
 20 |     | <span class='neutral'>    /// @return The fee</span>
 21 |     | <span class='neutral'>    function fee() external view returns (uint24);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice The pool tick spacing</span>
 24 |     | <span class='neutral'>    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive</span>
 25 |     | <span class='neutral'>    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...</span>
 26 |     | <span class='neutral'>    /// This value is an int24 to avoid casting even though it is always positive.</span>
 27 |     | <span class='neutral'>    /// @return The tick spacing</span>
 28 |     | <span class='neutral'>    function tickSpacing() external view returns (int24);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice The maximum amount of position liquidity that can use any tick in the range</span>
 31 |     | <span class='neutral'>    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and</span>
 32 |     | <span class='neutral'>    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool</span>
 33 |     | <span class='neutral'>    /// @return The max amount of liquidity per tick</span>
 34 |     | <span class='neutral'>    function maxLiquidityPerTick() external view returns (uint128);</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolOwnerActions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Permissioned pool actions</span>
  5 |     | <span class='neutral'>/// @notice Contains pool methods that may only be called by the factory owner</span>
  6 |     | <span class='neutral'>interface IUniswapV3PoolOwnerActions {</span>
  7 |     | <span class='neutral'>    /// @notice Set the denominator of the protocol&#39;s % share of the fees</span>
  8 |     | <span class='neutral'>    /// @param feeProtocol0 new protocol fee for token0 of the pool</span>
  9 |     | <span class='neutral'>    /// @param feeProtocol1 new protocol fee for token1 of the pool</span>
 10 |     | <span class='neutral'>    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice Collect the protocol fee accrued to the pool</span>
 13 |     | <span class='neutral'>    /// @param recipient The address to which collected protocol fees should be sent</span>
 14 |     | <span class='neutral'>    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1</span>
 15 |     | <span class='neutral'>    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0</span>
 16 |     | <span class='neutral'>    /// @return amount0 The protocol fee collected in token0</span>
 17 |     | <span class='neutral'>    /// @return amount1 The protocol fee collected in token1</span>
 18 |     | <span class='neutral'>    function collectProtocol(</span>
 19 |     | <span class='neutral'>        address recipient,</span>
 20 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 21 |     | <span class='neutral'>        uint128 amount1Requested</span>
 22 |     | <span class='neutral'>    ) external returns (uint128 amount0, uint128 amount1);</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolState.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Pool state that can change</span>
   5 |     | <span class='neutral'>/// @notice These methods compose the pool&#39;s state, and can change with any frequency including multiple times</span>
   6 |     | <span class='neutral'>/// per transaction</span>
   7 |     | <span class='neutral'>interface IUniswapV3PoolState {</span>
   8 |     | <span class='neutral'>    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas</span>
   9 |     | <span class='neutral'>    /// when accessed externally.</span>
  10 |     | <span class='neutral'>    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value</span>
  11 |     | <span class='neutral'>    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.</span>
  12 |     | <span class='neutral'>    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick</span>
  13 |     | <span class='neutral'>    /// boundary.</span>
  14 |     | <span class='neutral'>    /// observationIndex The index of the last oracle observation that was written,</span>
  15 |     | <span class='neutral'>    /// observationCardinality The current maximum number of observations stored in the pool,</span>
  16 |     | <span class='neutral'>    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.</span>
  17 |     | <span class='neutral'>    /// feeProtocol The protocol fee for both tokens of the pool.</span>
  18 |     | <span class='neutral'>    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0</span>
  19 |     | <span class='neutral'>    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.</span>
  20 |     | <span class='neutral'>    /// unlocked Whether the pool is currently locked to reentrancy</span>
  21 |     | <span class='neutral'>    function slot0()</span>
  22 |     | <span class='neutral'>        external</span>
  23 |     | <span class='neutral'>        view</span>
  24 |     | <span class='neutral'>        returns (</span>
  25 |     | <span class='neutral'>            uint160 sqrtPriceX96,</span>
  26 |     | <span class='neutral'>            int24 tick,</span>
  27 |     | <span class='neutral'>            uint16 observationIndex,</span>
  28 |     | <span class='neutral'>            uint16 observationCardinality,</span>
  29 |     | <span class='neutral'>            uint16 observationCardinalityNext,</span>
  30 |     | <span class='neutral'>            uint8 feeProtocol,</span>
  31 |     | <span class='neutral'>            bool unlocked</span>
  32 |     | <span class='neutral'>        );</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool</span>
  35 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  36 |     | <span class='neutral'>    function feeGrowthGlobal0X128() external view returns (uint256);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool</span>
  39 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  40 |     | <span class='neutral'>    function feeGrowthGlobal1X128() external view returns (uint256);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice The amounts of token0 and token1 that are owed to the protocol</span>
  43 |     | <span class='neutral'>    /// @dev Protocol fees will never exceed uint128 max in either token</span>
  44 |     | <span class='neutral'>    function protocolFees() external view returns (uint128 token0, uint128 token1);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    /// @notice The currently in range liquidity available to the pool</span>
  47 |     | <span class='neutral'>    /// @dev This value has no relationship to the total liquidity across all ticks</span>
  48 |     | <span class='neutral'>    function liquidity() external view returns (uint128);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice Look up information about a specific tick in the pool</span>
  51 |     | <span class='neutral'>    /// @param tick The tick to look up</span>
  52 |     | <span class='neutral'>    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or</span>
  53 |     | <span class='neutral'>    /// tick upper,</span>
  54 |     | <span class='neutral'>    /// liquidityNet how much liquidity changes when the pool price crosses the tick,</span>
  55 |     | <span class='neutral'>    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,</span>
  56 |     | <span class='neutral'>    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,</span>
  57 |     | <span class='neutral'>    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick</span>
  58 |     | <span class='neutral'>    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,</span>
  59 |     | <span class='neutral'>    /// secondsOutside the seconds spent on the other side of the tick from the current tick,</span>
  60 |     | <span class='neutral'>    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.</span>
  61 |     | <span class='neutral'>    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.</span>
  62 |     | <span class='neutral'>    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for</span>
  63 |     | <span class='neutral'>    /// a specific position.</span>
  64 |     | <span class='neutral'>    function ticks(int24 tick)</span>
  65 |     | <span class='neutral'>        external</span>
  66 |     | <span class='neutral'>        view</span>
  67 |     | <span class='neutral'>        returns (</span>
  68 |     | <span class='neutral'>            uint128 liquidityGross,</span>
  69 |     | <span class='neutral'>            int128 liquidityNet,</span>
  70 |     | <span class='neutral'>            uint256 feeGrowthOutside0X128,</span>
  71 |     | <span class='neutral'>            uint256 feeGrowthOutside1X128,</span>
  72 |     | <span class='neutral'>            int56 tickCumulativeOutside,</span>
  73 |     | <span class='neutral'>            uint160 secondsPerLiquidityOutsideX128,</span>
  74 |     | <span class='neutral'>            uint32 secondsOutside,</span>
  75 |     | <span class='neutral'>            bool initialized</span>
  76 |     | <span class='neutral'>        );</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information</span>
  79 |     | <span class='neutral'>    function tickBitmap(int16 wordPosition) external view returns (uint256);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /// @notice Returns the information about a position by the position&#39;s key</span>
  82 |     | <span class='neutral'>    /// @param key The position&#39;s key is a hash of a preimage composed by the owner, tickLower and tickUpper</span>
  83 |     | <span class='neutral'>    /// @return _liquidity The amount of liquidity in the position,</span>
  84 |     | <span class='neutral'>    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,</span>
  85 |     | <span class='neutral'>    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,</span>
  86 |     | <span class='neutral'>    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,</span>
  87 |     | <span class='neutral'>    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke</span>
  88 |     | <span class='neutral'>    function positions(bytes32 key)</span>
  89 |     | <span class='neutral'>        external</span>
  90 |     | <span class='neutral'>        view</span>
  91 |     | <span class='neutral'>        returns (</span>
  92 |     | <span class='neutral'>            uint128 _liquidity,</span>
  93 |     | <span class='neutral'>            uint256 feeGrowthInside0LastX128,</span>
  94 |     | <span class='neutral'>            uint256 feeGrowthInside1LastX128,</span>
  95 |     | <span class='neutral'>            uint128 tokensOwed0,</span>
  96 |     | <span class='neutral'>            uint128 tokensOwed1</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @notice Returns data about a specific observation index</span>
 100 |     | <span class='neutral'>    /// @param index The element of the observations array to fetch</span>
 101 |     | <span class='neutral'>    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time</span>
 102 |     | <span class='neutral'>    /// ago, rather than at a specific index in the array.</span>
 103 |     | <span class='neutral'>    /// @return blockTimestamp The timestamp of the observation,</span>
 104 |     | <span class='neutral'>    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,</span>
 105 |     | <span class='neutral'>    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,</span>
 106 |     | <span class='neutral'>    /// Returns initialized whether the observation has been initialized and the values are safe to use</span>
 107 |     | <span class='neutral'>    function observations(uint256 index)</span>
 108 |     | <span class='neutral'>        external</span>
 109 |     | <span class='neutral'>        view</span>
 110 |     | <span class='neutral'>        returns (</span>
 111 |     | <span class='neutral'>            uint32 blockTimestamp,</span>
 112 |     | <span class='neutral'>            int56 tickCumulative,</span>
 113 |     | <span class='neutral'>            uint160 secondsPerLiquidityCumulativeX128,</span>
 114 |     | <span class='neutral'>            bool initialized</span>
 115 |     | <span class='neutral'>        );</span>
 116 |     | <span class='neutral'>}</span>
 117 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/BitMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title BitMath</span>
  5 |     | <span class='unexecuted'>/// @dev This library provides functionality for computing bit properties of an unsigned integer</span>
  6 |     | <span class='neutral'>library BitMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns the index of the most significant bit of the number,</span>
  8 |     | <span class='neutral'>    ///     where the least significant bit is at index 0 and the most significant bit is at index 255</span>
  9 |     | <span class='neutral'>    /// @dev The function satisfies the property:</span>
 10 |     | <span class='neutral'>    ///     x &gt;= 2**mostSignificantBit(x) and x &lt; 2**(mostSignificantBit(x)+1)</span>
 11 |     | <span class='neutral'>    /// @param x the value for which to compute the most significant bit, must be greater than 0</span>
 12 |     | <span class='neutral'>    /// @return r the index of the most significant bit</span>
 13 |     | <span class='unexecuted'>    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {</span>
 14 |     | <span class='unexecuted'>        require(x &gt; 0);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>        if (x &gt;= 0x100000000000000000000000000000000) {</span>
 17 |     | <span class='unexecuted'>            x &gt;&gt;= 128;</span>
 18 |     | <span class='unexecuted'>            r += 128;</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='unexecuted'>        if (x &gt;= 0x10000000000000000) {</span>
 21 |     | <span class='unexecuted'>            x &gt;&gt;= 64;</span>
 22 |     | <span class='unexecuted'>            r += 64;</span>
 23 |     | <span class='neutral'>        }</span>
 24 |     | <span class='unexecuted'>        if (x &gt;= 0x100000000) {</span>
 25 |     | <span class='unexecuted'>            x &gt;&gt;= 32;</span>
 26 |     | <span class='unexecuted'>            r += 32;</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='unexecuted'>        if (x &gt;= 0x10000) {</span>
 29 |     | <span class='unexecuted'>            x &gt;&gt;= 16;</span>
 30 |     | <span class='unexecuted'>            r += 16;</span>
 31 |     | <span class='neutral'>        }</span>
 32 |     | <span class='unexecuted'>        if (x &gt;= 0x100) {</span>
 33 |     | <span class='unexecuted'>            x &gt;&gt;= 8;</span>
 34 |     | <span class='unexecuted'>            r += 8;</span>
 35 |     | <span class='neutral'>        }</span>
 36 |     | <span class='unexecuted'>        if (x &gt;= 0x10) {</span>
 37 |     | <span class='unexecuted'>            x &gt;&gt;= 4;</span>
 38 |     | <span class='unexecuted'>            r += 4;</span>
 39 |     | <span class='neutral'>        }</span>
 40 |     | <span class='unexecuted'>        if (x &gt;= 0x4) {</span>
 41 |     | <span class='unexecuted'>            x &gt;&gt;= 2;</span>
 42 |     | <span class='unexecuted'>            r += 2;</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='unexecuted'>        if (x &gt;= 0x2) r += 1;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /// @notice Returns the index of the least significant bit of the number,</span>
 48 |     | <span class='neutral'>    ///     where the least significant bit is at index 0 and the most significant bit is at index 255</span>
 49 |     | <span class='neutral'>    /// @dev The function satisfies the property:</span>
 50 |     | <span class='neutral'>    ///     (x &amp; 2**leastSignificantBit(x)) != 0 and (x &amp; (2**(leastSignificantBit(x)) - 1)) == 0)</span>
 51 |     | <span class='neutral'>    /// @param x the value for which to compute the least significant bit, must be greater than 0</span>
 52 |     | <span class='neutral'>    /// @return r the index of the least significant bit</span>
 53 |     | <span class='unexecuted'>    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {</span>
 54 |     | <span class='unexecuted'>        require(x &gt; 0);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>        r = 255;</span>
 57 |     | <span class='unexecuted'>        if (x &amp; type(uint128).max &gt; 0) {</span>
 58 |     | <span class='unexecuted'>            r -= 128;</span>
 59 |     | <span class='neutral'>        } else {</span>
 60 |     | <span class='unexecuted'>            x &gt;&gt;= 128;</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='unexecuted'>        if (x &amp; type(uint64).max &gt; 0) {</span>
 63 |     | <span class='unexecuted'>            r -= 64;</span>
 64 |     | <span class='neutral'>        } else {</span>
 65 |     | <span class='unexecuted'>            x &gt;&gt;= 64;</span>
 66 |     | <span class='neutral'>        }</span>
 67 |     | <span class='unexecuted'>        if (x &amp; type(uint32).max &gt; 0) {</span>
 68 |     | <span class='unexecuted'>            r -= 32;</span>
 69 |     | <span class='neutral'>        } else {</span>
 70 |     | <span class='unexecuted'>            x &gt;&gt;= 32;</span>
 71 |     | <span class='neutral'>        }</span>
 72 |     | <span class='unexecuted'>        if (x &amp; type(uint16).max &gt; 0) {</span>
 73 |     | <span class='unexecuted'>            r -= 16;</span>
 74 |     | <span class='neutral'>        } else {</span>
 75 |     | <span class='unexecuted'>            x &gt;&gt;= 16;</span>
 76 |     | <span class='neutral'>        }</span>
 77 |     | <span class='unexecuted'>        if (x &amp; type(uint8).max &gt; 0) {</span>
 78 |     | <span class='unexecuted'>            r -= 8;</span>
 79 |     | <span class='neutral'>        } else {</span>
 80 |     | <span class='unexecuted'>            x &gt;&gt;= 8;</span>
 81 |     | <span class='neutral'>        }</span>
 82 |     | <span class='unexecuted'>        if (x &amp; 0xf &gt; 0) {</span>
 83 |     | <span class='unexecuted'>            r -= 4;</span>
 84 |     | <span class='neutral'>        } else {</span>
 85 |     | <span class='unexecuted'>            x &gt;&gt;= 4;</span>
 86 |     | <span class='neutral'>        }</span>
 87 |     | <span class='unexecuted'>        if (x &amp; 0x3 &gt; 0) {</span>
 88 |     | <span class='unexecuted'>            r -= 2;</span>
 89 |     | <span class='neutral'>        } else {</span>
 90 |     | <span class='unexecuted'>            x &gt;&gt;= 2;</span>
 91 |     | <span class='neutral'>        }</span>
 92 |     | <span class='unexecuted'>        if (x &amp; 0x1 &gt; 0) r -= 1;</span>
 93 |     | <span class='neutral'>    }</span>
 94 |     | <span class='neutral'>}</span>
 95 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/FixedPoint128.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.4.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title FixedPoint128</span>
  5 |     | <span class='unexecuted'>/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)</span>
  6 |     | <span class='neutral'>library FixedPoint128 {</span>
  7 |     | <span class='unexecuted'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/FixedPoint96.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.4.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title FixedPoint96</span>
  5 |     | <span class='neutral'>/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)</span>
  6 |     | <span class='unexecuted'>/// @dev Used in SqrtPriceMath.sol</span>
  7 |     | <span class='neutral'>library FixedPoint96 {</span>
  8 |     | <span class='unexecuted'>    uint8 internal constant RESOLUTION = 96;</span>
  9 |     | <span class='unexecuted'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/FullMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.4.0 &lt;0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Contains 512-bit math functions</span>
   5 |     | <span class='neutral'>/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision</span>
   6 |     | <span class='unexecuted'>/// @dev Handles &quot;phantom overflow&quot; i.e., allows multiplication and division where an intermediate value overflows 256 bits</span>
   7 |     | <span class='neutral'>library FullMath {</span>
   8 |     | <span class='neutral'>    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
   9 |     | <span class='neutral'>    /// @param a The multiplicand</span>
  10 |     | <span class='neutral'>    /// @param b The multiplier</span>
  11 |     | <span class='neutral'>    /// @param denominator The divisor</span>
  12 |     | <span class='neutral'>    /// @return result The 256-bit result</span>
  13 |     | <span class='neutral'>    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv</span>
  14 |     | <span class='unexecuted'>    function mulDiv(</span>
  15 |     | <span class='neutral'>        uint256 a,</span>
  16 |     | <span class='neutral'>        uint256 b,</span>
  17 |     | <span class='neutral'>        uint256 denominator</span>
  18 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
  19 |     | <span class='neutral'>        // 512-bit multiply [prod1 prod0] = a * b</span>
  20 |     | <span class='neutral'>        // Compute the product mod 2**256 and mod 2**256 - 1</span>
  21 |     | <span class='neutral'>        // then use the Chinese Remainder Theorem to reconstruct</span>
  22 |     | <span class='neutral'>        // the 512 bit result. The result is stored in two 256</span>
  23 |     | <span class='neutral'>        // variables such that product = prod1 * 2**256 + prod0</span>
  24 |     | <span class='unexecuted'>        uint256 prod0; // Least significant 256 bits of the product</span>
  25 |     | <span class='unexecuted'>        uint256 prod1; // Most significant 256 bits of the product</span>
  26 |     | <span class='unexecuted'>        assembly {</span>
  27 |     | <span class='unexecuted'>            let mm := mulmod(a, b, not(0))</span>
  28 |     | <span class='unexecuted'>            prod0 := mul(a, b)</span>
  29 |     | <span class='unexecuted'>            prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>        // Handle non-overflow cases, 256 by 256 division</span>
  33 |     | <span class='unexecuted'>        if (prod1 == 0) {</span>
  34 |     | <span class='unexecuted'>            require(denominator &gt; 0);</span>
  35 |     | <span class='neutral'>            assembly {</span>
  36 |     | <span class='unexecuted'>                result := div(prod0, denominator)</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='unexecuted'>            return result;</span>
  39 |     | <span class='neutral'>        }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>        // Make sure the result is less than 2**256.</span>
  42 |     | <span class='neutral'>        // Also prevents denominator == 0</span>
  43 |     | <span class='unexecuted'>        require(denominator &gt; prod1);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        ///////////////////////////////////////////////</span>
  46 |     | <span class='neutral'>        // 512 by 256 division.</span>
  47 |     | <span class='neutral'>        ///////////////////////////////////////////////</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        // Make division exact by subtracting the remainder from [prod1 prod0]</span>
  50 |     | <span class='neutral'>        // Compute remainder using mulmod</span>
  51 |     | <span class='unexecuted'>        uint256 remainder;</span>
  52 |     | <span class='neutral'>        assembly {</span>
  53 |     | <span class='unexecuted'>            remainder := mulmod(a, b, denominator)</span>
  54 |     | <span class='neutral'>        }</span>
  55 |     | <span class='neutral'>        // Subtract 256 bit number from 512 bit number</span>
  56 |     | <span class='neutral'>        assembly {</span>
  57 |     | <span class='unexecuted'>            prod1 := sub(prod1, gt(remainder, prod0))</span>
  58 |     | <span class='unexecuted'>            prod0 := sub(prod0, remainder)</span>
  59 |     | <span class='neutral'>        }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // Factor powers of two out of denominator</span>
  62 |     | <span class='neutral'>        // Compute largest power of two divisor of denominator.</span>
  63 |     | <span class='neutral'>        // Always &gt;= 1.</span>
  64 |     | <span class='unexecuted'>        uint256 twos = -denominator &amp; denominator;</span>
  65 |     | <span class='neutral'>        // Divide denominator by power of two</span>
  66 |     | <span class='neutral'>        assembly {</span>
  67 |     | <span class='unexecuted'>            denominator := div(denominator, twos)</span>
  68 |     | <span class='neutral'>        }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>        // Divide [prod1 prod0] by the factors of two</span>
  71 |     | <span class='neutral'>        assembly {</span>
  72 |     | <span class='unexecuted'>            prod0 := div(prod0, twos)</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'>        // Shift in bits from prod1 into prod0. For this we need</span>
  75 |     | <span class='neutral'>        // to flip `twos` such that it is 2**256 / twos.</span>
  76 |     | <span class='neutral'>        // If twos is zero, then it becomes one</span>
  77 |     | <span class='neutral'>        assembly {</span>
  78 |     | <span class='unexecuted'>            twos := add(div(sub(0, twos), twos), 1)</span>
  79 |     | <span class='neutral'>        }</span>
  80 |     | <span class='unexecuted'>        prod0 |= prod1 * twos;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        // Invert denominator mod 2**256</span>
  83 |     | <span class='neutral'>        // Now that denominator is an odd number, it has an inverse</span>
  84 |     | <span class='neutral'>        // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  85 |     | <span class='neutral'>        // Compute the inverse by starting with a seed that is correct</span>
  86 |     | <span class='neutral'>        // correct for four bits. That is, denominator * inv = 1 mod 2**4</span>
  87 |     | <span class='unexecuted'>        uint256 inv = (3 * denominator) ^ 2;</span>
  88 |     | <span class='neutral'>        // Now use Newton-Raphson iteration to improve the precision.</span>
  89 |     | <span class='neutral'>        // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  90 |     | <span class='neutral'>        // arithmetic, doubling the correct bits in each step.</span>
  91 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**8</span>
  92 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**16</span>
  93 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**32</span>
  94 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**64</span>
  95 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**128</span>
  96 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**256</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>        // Because the division is now exact we can divide by multiplying</span>
  99 |     | <span class='neutral'>        // with the modular inverse of denominator. This will give us the</span>
 100 |     | <span class='neutral'>        // correct result modulo 2**256. Since the precoditions guarantee</span>
 101 |     | <span class='neutral'>        // that the outcome is less than 2**256, this is the final result.</span>
 102 |     | <span class='neutral'>        // We don&#39;t need to compute the high bits of the result and prod1</span>
 103 |     | <span class='neutral'>        // is no longer required.</span>
 104 |     | <span class='unexecuted'>        result = prod0 * inv;</span>
 105 |     | <span class='unexecuted'>        return result;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
 109 |     | <span class='neutral'>    /// @param a The multiplicand</span>
 110 |     | <span class='neutral'>    /// @param b The multiplier</span>
 111 |     | <span class='neutral'>    /// @param denominator The divisor</span>
 112 |     | <span class='neutral'>    /// @return result The 256-bit result</span>
 113 |     | <span class='unexecuted'>    function mulDivRoundingUp(</span>
 114 |     | <span class='neutral'>        uint256 a,</span>
 115 |     | <span class='neutral'>        uint256 b,</span>
 116 |     | <span class='neutral'>        uint256 denominator</span>
 117 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
 118 |     | <span class='unexecuted'>        result = mulDiv(a, b, denominator);</span>
 119 |     | <span class='unexecuted'>        if (mulmod(a, b, denominator) &gt; 0) {</span>
 120 |     | <span class='unexecuted'>            require(result &lt; type(uint256).max);</span>
 121 |     | <span class='unexecuted'>            result++;</span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'>}</span>
 125 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/LiquidityMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>/// @title Math library for liquidity</span>
  5 |     | <span class='neutral'>library LiquidityMath {</span>
  6 |     | <span class='neutral'>    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows</span>
  7 |     | <span class='neutral'>    /// @param x The liquidity before change</span>
  8 |     | <span class='neutral'>    /// @param y The delta by which liquidity should be changed</span>
  9 |     | <span class='neutral'>    /// @return z The liquidity delta</span>
 10 |     | <span class='unexecuted'>    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {</span>
 11 |     | <span class='unexecuted'>        if (y &lt; 0) {</span>
 12 |     | <span class='unexecuted'>            require((z = x - uint128(-y)) &lt; x, &#39;LS&#39;);</span>
 13 |     | <span class='neutral'>        } else {</span>
 14 |     | <span class='unexecuted'>            require((z = x + uint128(y)) &gt;= x, &#39;LA&#39;);</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/LowGasSafeMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.7.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Optimized overflow and underflow safe math operations</span>
  5 |     | <span class='unexecuted'>/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost</span>
  6 |     | <span class='neutral'>library LowGasSafeMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns x + y, reverts if sum overflows uint256</span>
  8 |     | <span class='neutral'>    /// @param x The augend</span>
  9 |     | <span class='neutral'>    /// @param y The addend</span>
 10 |     | <span class='neutral'>    /// @return z The sum of x and y</span>
 11 |     | <span class='unexecuted'>    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 12 |     | <span class='unexecuted'>        require((z = x + y) &gt;= x);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @notice Returns x - y, reverts if underflows</span>
 16 |     | <span class='neutral'>    /// @param x The minuend</span>
 17 |     | <span class='neutral'>    /// @param y The subtrahend</span>
 18 |     | <span class='neutral'>    /// @return z The difference of x and y</span>
 19 |     | <span class='unexecuted'>    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 20 |     | <span class='unexecuted'>        require((z = x - y) &lt;= x);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns x * y, reverts if overflows</span>
 24 |     | <span class='neutral'>    /// @param x The multiplicand</span>
 25 |     | <span class='neutral'>    /// @param y The multiplier</span>
 26 |     | <span class='neutral'>    /// @return z The product of x and y</span>
 27 |     | <span class='unexecuted'>    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 28 |     | <span class='unexecuted'>        require(x == 0 || (z = x * y) / x == y);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Returns x + y, reverts if overflows or underflows</span>
 32 |     | <span class='neutral'>    /// @param x The augend</span>
 33 |     | <span class='neutral'>    /// @param y The addend</span>
 34 |     | <span class='neutral'>    /// @return z The sum of x and y</span>
 35 |     | <span class='unexecuted'>    function add(int256 x, int256 y) internal pure returns (int256 z) {</span>
 36 |     | <span class='unexecuted'>        require((z = x + y) &gt;= x == (y &gt;= 0));</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /// @notice Returns x - y, reverts if overflows or underflows</span>
 40 |     | <span class='neutral'>    /// @param x The minuend</span>
 41 |     | <span class='neutral'>    /// @param y The subtrahend</span>
 42 |     | <span class='neutral'>    /// @return z The difference of x and y</span>
 43 |     | <span class='unexecuted'>    function sub(int256 x, int256 y) internal pure returns (int256 z) {</span>
 44 |     | <span class='unexecuted'>        require((z = x - y) &lt;= x == (y &gt;= 0));</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/Oracle.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0 &lt;0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Oracle</span>
   5 |     | <span class='neutral'>/// @notice Provides price and liquidity data useful for a wide variety of system designs</span>
   6 |     | <span class='neutral'>/// @dev Instances of stored oracle data, &quot;observations&quot;, are collected in the oracle array</span>
   7 |     | <span class='neutral'>/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the</span>
   8 |     | <span class='neutral'>/// maximum length of the oracle array. New slots will be added when the array is fully populated.</span>
   9 |     | <span class='neutral'>/// Observations are overwritten when the full length of the oracle array is populated.</span>
  10 |     | <span class='unexecuted'>/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()</span>
  11 |     | <span class='neutral'>library Oracle {</span>
  12 |     | <span class='neutral'>    struct Observation {</span>
  13 |     | <span class='neutral'>        // the block timestamp of the observation</span>
  14 |     | <span class='neutral'>        uint32 blockTimestamp;</span>
  15 |     | <span class='neutral'>        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized</span>
  16 |     | <span class='neutral'>        int56 tickCumulative;</span>
  17 |     | <span class='neutral'>        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized</span>
  18 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128;</span>
  19 |     | <span class='neutral'>        // whether or not the observation is initialized</span>
  20 |     | <span class='neutral'>        bool initialized;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values</span>
  24 |     | <span class='neutral'>    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows</span>
  25 |     | <span class='neutral'>    /// @param last The specified observation to be transformed</span>
  26 |     | <span class='neutral'>    /// @param blockTimestamp The timestamp of the new observation</span>
  27 |     | <span class='neutral'>    /// @param tick The active tick at the time of the new observation</span>
  28 |     | <span class='neutral'>    /// @param liquidity The total in-range liquidity at the time of the new observation</span>
  29 |     | <span class='neutral'>    /// @return Observation The newly populated observation</span>
  30 |     | <span class='unexecuted'>    function transform(</span>
  31 |     | <span class='neutral'>        Observation memory last,</span>
  32 |     | <span class='neutral'>        uint32 blockTimestamp,</span>
  33 |     | <span class='neutral'>        int24 tick,</span>
  34 |     | <span class='neutral'>        uint128 liquidity</span>
  35 |     | <span class='unexecuted'>    ) private pure returns (Observation memory) {</span>
  36 |     | <span class='unexecuted'>        uint32 delta = blockTimestamp - last.blockTimestamp;</span>
  37 |     | <span class='unexecuted'>        return</span>
  38 |     | <span class='unexecuted'>            Observation({</span>
  39 |     | <span class='unexecuted'>                blockTimestamp: blockTimestamp,</span>
  40 |     | <span class='unexecuted'>                tickCumulative: last.tickCumulative + int56(tick) * delta,</span>
  41 |     | <span class='unexecuted'>                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +</span>
  42 |     | <span class='unexecuted'>                    ((uint160(delta) &lt;&lt; 128) / (liquidity &gt; 0 ? liquidity : 1)),</span>
  43 |     | <span class='unexecuted'>                initialized: true</span>
  44 |     | <span class='neutral'>            });</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array</span>
  48 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
  49 |     | <span class='neutral'>    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32</span>
  50 |     | <span class='neutral'>    /// @return cardinality The number of populated elements in the oracle array</span>
  51 |     | <span class='neutral'>    /// @return cardinalityNext The new length of the oracle array, independent of population</span>
  52 |     | <span class='unexecuted'>    function initialize(Observation[65535] storage self, uint32 time)</span>
  53 |     | <span class='neutral'>        internal</span>
  54 |     | <span class='unexecuted'>        returns (uint16 cardinality, uint16 cardinalityNext)</span>
  55 |     | <span class='neutral'>    {</span>
  56 |     | <span class='unexecuted'>        self[0] = Observation({</span>
  57 |     | <span class='unexecuted'>            blockTimestamp: time,</span>
  58 |     | <span class='unexecuted'>            tickCumulative: 0,</span>
  59 |     | <span class='unexecuted'>            secondsPerLiquidityCumulativeX128: 0,</span>
  60 |     | <span class='unexecuted'>            initialized: true</span>
  61 |     | <span class='neutral'>        });</span>
  62 |     | <span class='unexecuted'>        return (1, 1);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice Writes an oracle observation to the array</span>
  66 |     | <span class='neutral'>    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.</span>
  67 |     | <span class='neutral'>    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality</span>
  68 |     | <span class='neutral'>    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.</span>
  69 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
  70 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
  71 |     | <span class='neutral'>    /// @param blockTimestamp The timestamp of the new observation</span>
  72 |     | <span class='neutral'>    /// @param tick The active tick at the time of the new observation</span>
  73 |     | <span class='neutral'>    /// @param liquidity The total in-range liquidity at the time of the new observation</span>
  74 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
  75 |     | <span class='neutral'>    /// @param cardinalityNext The new length of the oracle array, independent of population</span>
  76 |     | <span class='neutral'>    /// @return indexUpdated The new index of the most recently written element in the oracle array</span>
  77 |     | <span class='neutral'>    /// @return cardinalityUpdated The new cardinality of the oracle array</span>
  78 |     | <span class='unexecuted'>    function write(</span>
  79 |     | <span class='neutral'>        Observation[65535] storage self,</span>
  80 |     | <span class='neutral'>        uint16 index,</span>
  81 |     | <span class='neutral'>        uint32 blockTimestamp,</span>
  82 |     | <span class='neutral'>        int24 tick,</span>
  83 |     | <span class='neutral'>        uint128 liquidity,</span>
  84 |     | <span class='neutral'>        uint16 cardinality,</span>
  85 |     | <span class='neutral'>        uint16 cardinalityNext</span>
  86 |     | <span class='unexecuted'>    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {</span>
  87 |     | <span class='unexecuted'>        Observation memory last = self[index];</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        // early return if we&#39;ve already written an observation this block</span>
  90 |     | <span class='unexecuted'>        if (last.blockTimestamp == blockTimestamp) return (index, cardinality);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        // if the conditions are right, we can bump the cardinality</span>
  93 |     | <span class='unexecuted'>        if (cardinalityNext &gt; cardinality &amp;&amp; index == (cardinality - 1)) {</span>
  94 |     | <span class='unexecuted'>            cardinalityUpdated = cardinalityNext;</span>
  95 |     | <span class='neutral'>        } else {</span>
  96 |     | <span class='unexecuted'>            cardinalityUpdated = cardinality;</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        indexUpdated = (index + 1) % cardinalityUpdated;</span>
 100 |     | <span class='unexecuted'>        self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @notice Prepares the oracle array to store up to `next` observations</span>
 104 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 105 |     | <span class='neutral'>    /// @param current The current next cardinality of the oracle array</span>
 106 |     | <span class='neutral'>    /// @param next The proposed next cardinality which will be populated in the oracle array</span>
 107 |     | <span class='neutral'>    /// @return next The next cardinality which will be populated in the oracle array</span>
 108 |     | <span class='unexecuted'>    function grow(</span>
 109 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 110 |     | <span class='neutral'>        uint16 current,</span>
 111 |     | <span class='neutral'>        uint16 next</span>
 112 |     | <span class='unexecuted'>    ) internal returns (uint16) {</span>
 113 |     | <span class='unexecuted'>        require(current &gt; 0, &#39;I&#39;);</span>
 114 |     | <span class='neutral'>        // no-op if the passed next value isn&#39;t greater than the current next value</span>
 115 |     | <span class='unexecuted'>        if (next &lt;= current) return current;</span>
 116 |     | <span class='neutral'>        // store in each slot to prevent fresh SSTOREs in swaps</span>
 117 |     | <span class='neutral'>        // this data will not be used because the initialized boolean is still false</span>
 118 |     | <span class='unexecuted'>        for (uint16 i = current; i &lt; next; i++) self[i].blockTimestamp = 1;</span>
 119 |     | <span class='unexecuted'>        return next;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @notice comparator for 32-bit timestamps</span>
 123 |     | <span class='neutral'>    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time</span>
 124 |     | <span class='neutral'>    /// @param time A timestamp truncated to 32 bits</span>
 125 |     | <span class='neutral'>    /// @param a A comparison timestamp from which to determine the relative position of `time`</span>
 126 |     | <span class='neutral'>    /// @param b From which to determine the relative position of `time`</span>
 127 |     | <span class='neutral'>    /// @return bool Whether `a` is chronologically &lt;= `b`</span>
 128 |     | <span class='unexecuted'>    function lte(</span>
 129 |     | <span class='neutral'>        uint32 time,</span>
 130 |     | <span class='neutral'>        uint32 a,</span>
 131 |     | <span class='neutral'>        uint32 b</span>
 132 |     | <span class='unexecuted'>    ) private pure returns (bool) {</span>
 133 |     | <span class='neutral'>        // if there hasn&#39;t been overflow, no need to adjust</span>
 134 |     | <span class='unexecuted'>        if (a &lt;= time &amp;&amp; b &lt;= time) return a &lt;= b;</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>        uint256 aAdjusted = a &gt; time ? a : a + 2**32;</span>
 137 |     | <span class='unexecuted'>        uint256 bAdjusted = b &gt; time ? b : b + 2**32;</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        return aAdjusted &lt;= bAdjusted;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.</span>
 143 |     | <span class='neutral'>    /// The result may be the same observation, or adjacent observations.</span>
 144 |     | <span class='neutral'>    /// @dev The answer must be contained in the array, used when the target is located within the stored observation</span>
 145 |     | <span class='neutral'>    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation</span>
 146 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 147 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 148 |     | <span class='neutral'>    /// @param target The timestamp at which the reserved observation should be for</span>
 149 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 150 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 151 |     | <span class='neutral'>    /// @return beforeOrAt The observation recorded before, or at, the target</span>
 152 |     | <span class='neutral'>    /// @return atOrAfter The observation recorded at, or after, the target</span>
 153 |     | <span class='unexecuted'>    function binarySearch(</span>
 154 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 155 |     | <span class='neutral'>        uint32 time,</span>
 156 |     | <span class='neutral'>        uint32 target,</span>
 157 |     | <span class='neutral'>        uint16 index,</span>
 158 |     | <span class='neutral'>        uint16 cardinality</span>
 159 |     | <span class='unexecuted'>    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {</span>
 160 |     | <span class='unexecuted'>        uint256 l = (index + 1) % cardinality; // oldest observation</span>
 161 |     | <span class='unexecuted'>        uint256 r = l + cardinality - 1; // newest observation</span>
 162 |     | <span class='unexecuted'>        uint256 i;</span>
 163 |     | <span class='unexecuted'>        while (true) {</span>
 164 |     | <span class='unexecuted'>            i = (l + r) / 2;</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>            beforeOrAt = self[i % cardinality];</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>            // we&#39;ve landed on an uninitialized tick, keep searching higher (more recently)</span>
 169 |     | <span class='unexecuted'>            if (!beforeOrAt.initialized) {</span>
 170 |     | <span class='unexecuted'>                l = i + 1;</span>
 171 |     | <span class='unexecuted'>                continue;</span>
 172 |     | <span class='neutral'>            }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>            atOrAfter = self[(i + 1) % cardinality];</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>            bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>            // check if we&#39;ve found the answer!</span>
 179 |     | <span class='unexecuted'>            if (targetAtOrAfter &amp;&amp; lte(time, target, atOrAfter.blockTimestamp)) break;</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>            if (!targetAtOrAfter) r = i - 1;</span>
 182 |     | <span class='unexecuted'>            else l = i + 1;</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied</span>
 187 |     | <span class='neutral'>    /// @dev Assumes there is at least 1 initialized observation.</span>
 188 |     | <span class='neutral'>    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.</span>
 189 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 190 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 191 |     | <span class='neutral'>    /// @param target The timestamp at which the reserved observation should be for</span>
 192 |     | <span class='neutral'>    /// @param tick The active tick at the time of the returned or simulated observation</span>
 193 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 194 |     | <span class='neutral'>    /// @param liquidity The total pool liquidity at the time of the call</span>
 195 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 196 |     | <span class='neutral'>    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp</span>
 197 |     | <span class='neutral'>    /// @return atOrAfter The observation which occurred at, or after, the given timestamp</span>
 198 |     | <span class='unexecuted'>    function getSurroundingObservations(</span>
 199 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 200 |     | <span class='neutral'>        uint32 time,</span>
 201 |     | <span class='neutral'>        uint32 target,</span>
 202 |     | <span class='neutral'>        int24 tick,</span>
 203 |     | <span class='neutral'>        uint16 index,</span>
 204 |     | <span class='neutral'>        uint128 liquidity,</span>
 205 |     | <span class='neutral'>        uint16 cardinality</span>
 206 |     | <span class='unexecuted'>    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {</span>
 207 |     | <span class='neutral'>        // optimistically set before to the newest observation</span>
 208 |     | <span class='unexecuted'>        beforeOrAt = self[index];</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>        // if the target is chronologically at or after the newest observation, we can early return</span>
 211 |     | <span class='unexecuted'>        if (lte(time, beforeOrAt.blockTimestamp, target)) {</span>
 212 |     | <span class='unexecuted'>            if (beforeOrAt.blockTimestamp == target) {</span>
 213 |     | <span class='neutral'>                // if newest observation equals target, we&#39;re in the same block, so we can ignore atOrAfter</span>
 214 |     | <span class='unexecuted'>                return (beforeOrAt, atOrAfter);</span>
 215 |     | <span class='neutral'>            } else {</span>
 216 |     | <span class='neutral'>                // otherwise, we need to transform</span>
 217 |     | <span class='unexecuted'>                return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));</span>
 218 |     | <span class='neutral'>            }</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>        // now, set before to the oldest observation</span>
 222 |     | <span class='unexecuted'>        beforeOrAt = self[(index + 1) % cardinality];</span>
 223 |     | <span class='unexecuted'>        if (!beforeOrAt.initialized) beforeOrAt = self[0];</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>        // ensure that the target is chronologically at or after the oldest observation</span>
 226 |     | <span class='unexecuted'>        require(lte(time, beforeOrAt.blockTimestamp, target), &#39;OLD&#39;);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        // if we&#39;ve reached this point, we have to binary search</span>
 229 |     | <span class='unexecuted'>        return binarySearch(self, time, target, index, cardinality);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.</span>
 233 |     | <span class='neutral'>    /// 0 may be passed as `secondsAgo&#39; to return the current cumulative values.</span>
 234 |     | <span class='neutral'>    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values</span>
 235 |     | <span class='neutral'>    /// at exactly the timestamp between the two observations.</span>
 236 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 237 |     | <span class='neutral'>    /// @param time The current block timestamp</span>
 238 |     | <span class='neutral'>    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation</span>
 239 |     | <span class='neutral'>    /// @param tick The current tick</span>
 240 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 241 |     | <span class='neutral'>    /// @param liquidity The current in-range pool liquidity</span>
 242 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 243 |     | <span class='neutral'>    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`</span>
 244 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`</span>
 245 |     | <span class='unexecuted'>    function observeSingle(</span>
 246 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 247 |     | <span class='neutral'>        uint32 time,</span>
 248 |     | <span class='neutral'>        uint32 secondsAgo,</span>
 249 |     | <span class='neutral'>        int24 tick,</span>
 250 |     | <span class='neutral'>        uint16 index,</span>
 251 |     | <span class='neutral'>        uint128 liquidity,</span>
 252 |     | <span class='neutral'>        uint16 cardinality</span>
 253 |     | <span class='unexecuted'>    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {</span>
 254 |     | <span class='unexecuted'>        if (secondsAgo == 0) {</span>
 255 |     | <span class='unexecuted'>            Observation memory last = self[index];</span>
 256 |     | <span class='unexecuted'>            if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);</span>
 257 |     | <span class='unexecuted'>            return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);</span>
 258 |     | <span class='neutral'>        }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='unexecuted'>        uint32 target = time - secondsAgo;</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='unexecuted'>        (Observation memory beforeOrAt, Observation memory atOrAfter) =</span>
 263 |     | <span class='unexecuted'>            getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='unexecuted'>        if (target == beforeOrAt.blockTimestamp) {</span>
 266 |     | <span class='neutral'>            // we&#39;re at the left boundary</span>
 267 |     | <span class='unexecuted'>            return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);</span>
 268 |     | <span class='unexecuted'>        } else if (target == atOrAfter.blockTimestamp) {</span>
 269 |     | <span class='neutral'>            // we&#39;re at the right boundary</span>
 270 |     | <span class='unexecuted'>            return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);</span>
 271 |     | <span class='neutral'>        } else {</span>
 272 |     | <span class='neutral'>            // we&#39;re in the middle</span>
 273 |     | <span class='unexecuted'>            uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;</span>
 274 |     | <span class='unexecuted'>            uint32 targetDelta = target - beforeOrAt.blockTimestamp;</span>
 275 |     | <span class='unexecuted'>            return (</span>
 276 |     | <span class='unexecuted'>                beforeOrAt.tickCumulative +</span>
 277 |     | <span class='unexecuted'>                    ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / observationTimeDelta) *</span>
 278 |     | <span class='unexecuted'>                    targetDelta,</span>
 279 |     | <span class='unexecuted'>                beforeOrAt.secondsPerLiquidityCumulativeX128 +</span>
 280 |     | <span class='neutral'>                    uint160(</span>
 281 |     | <span class='unexecuted'>                        (uint256(</span>
 282 |     | <span class='unexecuted'>                            atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128</span>
 283 |     | <span class='unexecuted'>                        ) * targetDelta) / observationTimeDelta</span>
 284 |     | <span class='neutral'>                    )</span>
 285 |     | <span class='neutral'>            );</span>
 286 |     | <span class='neutral'>        }</span>
 287 |     | <span class='neutral'>    }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`</span>
 290 |     | <span class='neutral'>    /// @dev Reverts if `secondsAgos` &gt; oldest observation</span>
 291 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 292 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 293 |     | <span class='neutral'>    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation</span>
 294 |     | <span class='neutral'>    /// @param tick The current tick</span>
 295 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 296 |     | <span class='neutral'>    /// @param liquidity The current in-range pool liquidity</span>
 297 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 298 |     | <span class='neutral'>    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`</span>
 299 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`</span>
 300 |     | <span class='unexecuted'>    function observe(</span>
 301 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 302 |     | <span class='neutral'>        uint32 time,</span>
 303 |     | <span class='neutral'>        uint32[] memory secondsAgos,</span>
 304 |     | <span class='neutral'>        int24 tick,</span>
 305 |     | <span class='neutral'>        uint16 index,</span>
 306 |     | <span class='neutral'>        uint128 liquidity,</span>
 307 |     | <span class='neutral'>        uint16 cardinality</span>
 308 |     | <span class='unexecuted'>    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {</span>
 309 |     | <span class='unexecuted'>        require(cardinality &gt; 0, &#39;I&#39;);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='unexecuted'>        tickCumulatives = new int56[](secondsAgos.length);</span>
 312 |     | <span class='unexecuted'>        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);</span>
 313 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; secondsAgos.length; i++) {</span>
 314 |     | <span class='unexecuted'>            (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(</span>
 315 |     | <span class='unexecuted'>                self,</span>
 316 |     | <span class='unexecuted'>                time,</span>
 317 |     | <span class='unexecuted'>                secondsAgos[i],</span>
 318 |     | <span class='unexecuted'>                tick,</span>
 319 |     | <span class='unexecuted'>                index,</span>
 320 |     | <span class='unexecuted'>                liquidity,</span>
 321 |     | <span class='unexecuted'>                cardinality</span>
 322 |     | <span class='neutral'>            );</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'>}</span>
 326 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/Position.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0 &lt;0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./FullMath.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./FixedPoint128.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;./LiquidityMath.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @title Position</span>
  9 |     | <span class='neutral'>/// @notice Positions represent an owner address&#39; liquidity between a lower and upper tick boundary</span>
 10 |     | <span class='unexecuted'>/// @dev Positions store additional state for tracking fees owed to the position</span>
 11 |     | <span class='neutral'>library Position {</span>
 12 |     | <span class='neutral'>    // info stored for each user&#39;s position</span>
 13 |     | <span class='neutral'>    struct Info {</span>
 14 |     | <span class='neutral'>        // the amount of liquidity owned by this position</span>
 15 |     | <span class='neutral'>        uint128 liquidity;</span>
 16 |     | <span class='neutral'>        // fee growth per unit of liquidity as of the last update to liquidity or fees owed</span>
 17 |     | <span class='neutral'>        uint256 feeGrowthInside0LastX128;</span>
 18 |     | <span class='neutral'>        uint256 feeGrowthInside1LastX128;</span>
 19 |     | <span class='neutral'>        // the fees owed to the position owner in token0/token1</span>
 20 |     | <span class='neutral'>        uint128 tokensOwed0;</span>
 21 |     | <span class='neutral'>        uint128 tokensOwed1;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @notice Returns the Info struct of a position, given an owner and position boundaries</span>
 25 |     | <span class='neutral'>    /// @param self The mapping containing all user positions</span>
 26 |     | <span class='neutral'>    /// @param owner The address of the position owner</span>
 27 |     | <span class='neutral'>    /// @param tickLower The lower tick boundary of the position</span>
 28 |     | <span class='neutral'>    /// @param tickUpper The upper tick boundary of the position</span>
 29 |     | <span class='neutral'>    /// @return position The position info struct of the given owners&#39; position</span>
 30 |     | <span class='unexecuted'>    function get(</span>
 31 |     | <span class='neutral'>        mapping(bytes32 =&gt; Info) storage self,</span>
 32 |     | <span class='neutral'>        address owner,</span>
 33 |     | <span class='neutral'>        int24 tickLower,</span>
 34 |     | <span class='neutral'>        int24 tickUpper</span>
 35 |     | <span class='unexecuted'>    ) internal view returns (Position.Info storage position) {</span>
 36 |     | <span class='unexecuted'>        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /// @notice Credits accumulated fees to a user&#39;s position</span>
 40 |     | <span class='neutral'>    /// @param self The individual position to update</span>
 41 |     | <span class='neutral'>    /// @param liquidityDelta The change in pool liquidity as a result of the position update</span>
 42 |     | <span class='neutral'>    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position&#39;s tick boundaries</span>
 43 |     | <span class='neutral'>    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position&#39;s tick boundaries</span>
 44 |     | <span class='unexecuted'>    function update(</span>
 45 |     | <span class='neutral'>        Info storage self,</span>
 46 |     | <span class='neutral'>        int128 liquidityDelta,</span>
 47 |     | <span class='neutral'>        uint256 feeGrowthInside0X128,</span>
 48 |     | <span class='neutral'>        uint256 feeGrowthInside1X128</span>
 49 |     | <span class='neutral'>    ) internal {</span>
 50 |     | <span class='unexecuted'>        Info memory _self = self;</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>        uint128 liquidityNext;</span>
 53 |     | <span class='unexecuted'>        if (liquidityDelta == 0) {</span>
 54 |     | <span class='unexecuted'>            require(_self.liquidity &gt; 0, &#39;NP&#39;); // disallow pokes for 0 liquidity positions</span>
 55 |     | <span class='unexecuted'>            liquidityNext = _self.liquidity;</span>
 56 |     | <span class='neutral'>        } else {</span>
 57 |     | <span class='unexecuted'>            liquidityNext = LiquidityMath.addDelta(_self.liquidity, liquidityDelta);</span>
 58 |     | <span class='neutral'>        }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // calculate accumulated fees</span>
 61 |     | <span class='unexecuted'>        uint128 tokensOwed0 =</span>
 62 |     | <span class='neutral'>            uint128(</span>
 63 |     | <span class='unexecuted'>                FullMath.mulDiv(</span>
 64 |     | <span class='unexecuted'>                    feeGrowthInside0X128 - _self.feeGrowthInside0LastX128,</span>
 65 |     | <span class='unexecuted'>                    _self.liquidity,</span>
 66 |     | <span class='neutral'>                    FixedPoint128.Q128</span>
 67 |     | <span class='neutral'>                )</span>
 68 |     | <span class='neutral'>            );</span>
 69 |     | <span class='unexecuted'>        uint128 tokensOwed1 =</span>
 70 |     | <span class='neutral'>            uint128(</span>
 71 |     | <span class='unexecuted'>                FullMath.mulDiv(</span>
 72 |     | <span class='unexecuted'>                    feeGrowthInside1X128 - _self.feeGrowthInside1LastX128,</span>
 73 |     | <span class='unexecuted'>                    _self.liquidity,</span>
 74 |     | <span class='neutral'>                    FixedPoint128.Q128</span>
 75 |     | <span class='neutral'>                )</span>
 76 |     | <span class='neutral'>            );</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='neutral'>        // update the position</span>
 79 |     | <span class='unexecuted'>        if (liquidityDelta != 0) self.liquidity = liquidityNext;</span>
 80 |     | <span class='unexecuted'>        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;</span>
 81 |     | <span class='unexecuted'>        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;</span>
 82 |     | <span class='unexecuted'>        if (tokensOwed0 &gt; 0 || tokensOwed1 &gt; 0) {</span>
 83 |     | <span class='neutral'>            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees</span>
 84 |     | <span class='unexecuted'>            self.tokensOwed0 += tokensOwed0;</span>
 85 |     | <span class='unexecuted'>            self.tokensOwed1 += tokensOwed1;</span>
 86 |     | <span class='neutral'>        }</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/SafeCast.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Safe casting methods</span>
  5 |     | <span class='unexecuted'>/// @notice Contains methods for safely casting between types</span>
  6 |     | <span class='neutral'>library SafeCast {</span>
  7 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
  8 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
  9 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 10 |     | <span class='unexecuted'>    function toUint160(uint256 y) internal pure returns (uint160 z) {</span>
 11 |     | <span class='unexecuted'>        require((z = uint160(y)) == y);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 15 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 16 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 17 |     | <span class='unexecuted'>    function toInt128(int256 y) internal pure returns (int128 z) {</span>
 18 |     | <span class='unexecuted'>        require((z = int128(y)) == y);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /// @notice Cast a uint256 to a int256, revert on overflow</span>
 22 |     | <span class='neutral'>    /// @param y The uint256 to be casted</span>
 23 |     | <span class='neutral'>    /// @return z The casted integer, now type int256</span>
 24 |     | <span class='unexecuted'>    function toInt256(uint256 y) internal pure returns (int256 z) {</span>
 25 |     | <span class='unexecuted'>        require(y &lt; 2**255);</span>
 26 |     | <span class='unexecuted'>        z = int256(y);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/SafeMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.7.0;</span>
   3 |     | <span class='neutral'>/**</span>
   4 |     | <span class='neutral'> * @dev Wrappers over Solidity&#39;s arithmetic operations with added overflow</span>
   5 |     | <span class='neutral'> * checks.</span>
   6 |     | <span class='neutral'> *</span>
   7 |     | <span class='neutral'> * Arithmetic operations in Solidity wrap on overflow. This can easily result</span>
   8 |     | <span class='neutral'> * in bugs, because programmers usually assume that an overflow raises an</span>
   9 |     | <span class='neutral'> * error, which is the standard behavior in high level programming languages.</span>
  10 |     | <span class='neutral'> * `SafeMath` restores this intuition by reverting the transaction when an</span>
  11 |     | <span class='neutral'> * operation overflows.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * Using this library instead of the unchecked operations eliminates an entire</span>
  14 |     | <span class='neutral'> * class of bugs, so it&#39;s recommended to use it always.</span>
  15 |     | <span class='unexecuted'> */</span>
  16 |     | <span class='neutral'>library SafeMath {</span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @dev Returns the addition of two unsigned integers, with an overflow flag.</span>
  19 |     | <span class='neutral'>     *</span>
  20 |     | <span class='neutral'>     * _Available since v3.4._</span>
  21 |     | <span class='neutral'>     */</span>
  22 |     | <span class='neutral'>    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
  23 |     | <span class='neutral'>        uint256 c = a + b;</span>
  24 |     | <span class='neutral'>        if (c &lt; a) return (false, 0);</span>
  25 |     | <span class='neutral'>        return (true, c);</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Returns the substraction of two unsigned integers, with an overflow flag.</span>
  29 |     | <span class='neutral'>     *</span>
  30 |     | <span class='neutral'>     * _Available since v3.4._</span>
  31 |     | <span class='neutral'>     */</span>
  32 |     | <span class='neutral'>    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
  33 |     | <span class='neutral'>        if (b &gt; a) return (false, 0);</span>
  34 |     | <span class='neutral'>        return (true, a - b);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.</span>
  38 |     | <span class='neutral'>     *</span>
  39 |     | <span class='neutral'>     * _Available since v3.4._</span>
  40 |     | <span class='neutral'>     */</span>
  41 |     | <span class='neutral'>    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
  42 |     | <span class='neutral'>        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the</span>
  43 |     | <span class='neutral'>        // benefit is lost if &#39;b&#39; is also tested.</span>
  44 |     | <span class='neutral'>        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522</span>
  45 |     | <span class='neutral'>        if (a == 0) return (true, 0);</span>
  46 |     | <span class='neutral'>        uint256 c = a * b;</span>
  47 |     | <span class='neutral'>        if (c / a != b) return (false, 0);</span>
  48 |     | <span class='neutral'>        return (true, c);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @dev Returns the division of two unsigned integers, with a division by zero flag.</span>
  52 |     | <span class='neutral'>     *</span>
  53 |     | <span class='neutral'>     * _Available since v3.4._</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
  56 |     | <span class='neutral'>        if (b == 0) return (false, 0);</span>
  57 |     | <span class='neutral'>        return (true, a / b);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * _Available since v3.4._</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {</span>
  65 |     | <span class='neutral'>        if (b == 0) return (false, 0);</span>
  66 |     | <span class='neutral'>        return (true, a % b);</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'>    /**</span>
  69 |     | <span class='neutral'>     * @dev Returns the addition of two unsigned integers, reverting on</span>
  70 |     | <span class='neutral'>     * overflow.</span>
  71 |     | <span class='neutral'>     *</span>
  72 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `+` operator.</span>
  73 |     | <span class='neutral'>     *</span>
  74 |     | <span class='neutral'>     * Requirements:</span>
  75 |     | <span class='neutral'>     *</span>
  76 |     | <span class='neutral'>     * - Addition cannot overflow.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='neutral'>    function add(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  79 |     | <span class='neutral'>        uint256 c = a + b;</span>
  80 |     | <span class='neutral'>        require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);</span>
  81 |     | <span class='neutral'>        return c;</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Returns the subtraction of two unsigned integers, reverting on</span>
  85 |     | <span class='neutral'>     * overflow (when the result is negative).</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `-` operator.</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='neutral'>     * Requirements:</span>
  90 |     | <span class='neutral'>     *</span>
  91 |     | <span class='neutral'>     * - Subtraction cannot overflow.</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='neutral'>    function sub(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  94 |     | <span class='neutral'>        require(b &lt;= a, &quot;SafeMath: subtraction overflow&quot;);</span>
  95 |     | <span class='neutral'>        return a - b;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * @dev Returns the multiplication of two unsigned integers, reverting on</span>
  99 |     | <span class='neutral'>     * overflow.</span>
 100 |     | <span class='neutral'>     *</span>
 101 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `*` operator.</span>
 102 |     | <span class='neutral'>     *</span>
 103 |     | <span class='neutral'>     * Requirements:</span>
 104 |     | <span class='neutral'>     *</span>
 105 |     | <span class='neutral'>     * - Multiplication cannot overflow.</span>
 106 |     | <span class='neutral'>     */</span>
 107 |     | <span class='neutral'>    function mul(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 108 |     | <span class='neutral'>        if (a == 0) return 0;</span>
 109 |     | <span class='neutral'>        uint256 c = a * b;</span>
 110 |     | <span class='neutral'>        require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);</span>
 111 |     | <span class='neutral'>        return c;</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'>    /**</span>
 114 |     | <span class='neutral'>     * @dev Returns the integer division of two unsigned integers, reverting on</span>
 115 |     | <span class='neutral'>     * division by zero. The result is rounded towards zero.</span>
 116 |     | <span class='neutral'>     *</span>
 117 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `/` operator. Note: this function uses a</span>
 118 |     | <span class='neutral'>     * `revert` opcode (which leaves remaining gas untouched) while Solidity</span>
 119 |     | <span class='neutral'>     * uses an invalid opcode to revert (consuming all remaining gas).</span>
 120 |     | <span class='neutral'>     *</span>
 121 |     | <span class='neutral'>     * Requirements:</span>
 122 |     | <span class='neutral'>     *</span>
 123 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 124 |     | <span class='neutral'>     */</span>
 125 |     | <span class='neutral'>    function div(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 126 |     | <span class='neutral'>        require(b &gt; 0, &quot;SafeMath: division by zero&quot;);</span>
 127 |     | <span class='neutral'>        return a / b;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),</span>
 131 |     | <span class='neutral'>     * reverting when dividing by zero.</span>
 132 |     | <span class='neutral'>     *</span>
 133 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `%` operator. This function uses a `revert`</span>
 134 |     | <span class='neutral'>     * opcode (which leaves remaining gas untouched) while Solidity uses an</span>
 135 |     | <span class='neutral'>     * invalid opcode to revert (consuming all remaining gas).</span>
 136 |     | <span class='neutral'>     *</span>
 137 |     | <span class='neutral'>     * Requirements:</span>
 138 |     | <span class='neutral'>     *</span>
 139 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 140 |     | <span class='neutral'>     */</span>
 141 |     | <span class='neutral'>    function mod(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 142 |     | <span class='neutral'>        require(b &gt; 0, &quot;SafeMath: modulo by zero&quot;);</span>
 143 |     | <span class='neutral'>        return a % b;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'>    /**</span>
 146 |     | <span class='neutral'>     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on</span>
 147 |     | <span class='neutral'>     * overflow (when the result is negative).</span>
 148 |     | <span class='neutral'>     *</span>
 149 |     | <span class='neutral'>     * CAUTION: This function is deprecated because it requires allocating memory for the error</span>
 150 |     | <span class='neutral'>     * message unnecessarily. For custom revert reasons use {trySub}.</span>
 151 |     | <span class='neutral'>     *</span>
 152 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `-` operator.</span>
 153 |     | <span class='neutral'>     *</span>
 154 |     | <span class='neutral'>     * Requirements:</span>
 155 |     | <span class='neutral'>     *</span>
 156 |     | <span class='neutral'>     * - Subtraction cannot overflow.</span>
 157 |     | <span class='neutral'>     */</span>
 158 |     | <span class='neutral'>    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {</span>
 159 |     | <span class='neutral'>        require(b &lt;= a, errorMessage);</span>
 160 |     | <span class='neutral'>        return a - b;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'>    /**</span>
 163 |     | <span class='neutral'>     * @dev Returns the integer division of two unsigned integers, reverting with custom message on</span>
 164 |     | <span class='neutral'>     * division by zero. The result is rounded towards zero.</span>
 165 |     | <span class='neutral'>     *</span>
 166 |     | <span class='neutral'>     * CAUTION: This function is deprecated because it requires allocating memory for the error</span>
 167 |     | <span class='neutral'>     * message unnecessarily. For custom revert reasons use {tryDiv}.</span>
 168 |     | <span class='neutral'>     *</span>
 169 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `/` operator. Note: this function uses a</span>
 170 |     | <span class='neutral'>     * `revert` opcode (which leaves remaining gas untouched) while Solidity</span>
 171 |     | <span class='neutral'>     * uses an invalid opcode to revert (consuming all remaining gas).</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * Requirements:</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='neutral'>    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {</span>
 178 |     | <span class='neutral'>        require(b &gt; 0, errorMessage);</span>
 179 |     | <span class='neutral'>        return a / b;</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'>    /**</span>
 182 |     | <span class='neutral'>     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),</span>
 183 |     | <span class='neutral'>     * reverting with custom message when dividing by zero.</span>
 184 |     | <span class='neutral'>     *</span>
 185 |     | <span class='neutral'>     * CAUTION: This function is deprecated because it requires allocating memory for the error</span>
 186 |     | <span class='neutral'>     * message unnecessarily. For custom revert reasons use {tryMod}.</span>
 187 |     | <span class='neutral'>     *</span>
 188 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `%` operator. This function uses a `revert`</span>
 189 |     | <span class='neutral'>     * opcode (which leaves remaining gas untouched) while Solidity uses an</span>
 190 |     | <span class='neutral'>     * invalid opcode to revert (consuming all remaining gas).</span>
 191 |     | <span class='neutral'>     *</span>
 192 |     | <span class='neutral'>     * Requirements:</span>
 193 |     | <span class='neutral'>     *</span>
 194 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 195 |     | <span class='neutral'>     */</span>
 196 |     | <span class='neutral'>    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {</span>
 197 |     | <span class='neutral'>        require(b &gt; 0, errorMessage);</span>
 198 |     | <span class='neutral'>        return a % b;</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'>        function sqrt(uint y) internal pure returns (uint z) {</span>
 201 |     | <span class='neutral'>        if (y &gt; 3) {</span>
 202 |     | <span class='neutral'>            z = y;</span>
 203 |     | <span class='neutral'>            uint x = y / 2 + 1;</span>
 204 |     | <span class='neutral'>            while (x &lt; z) {</span>
 205 |     | <span class='neutral'>                z = x;</span>
 206 |     | <span class='neutral'>                x = (y / x + x) / 2;</span>
 207 |     | <span class='neutral'>            }</span>
 208 |     | <span class='neutral'>        } else if (y != 0) {</span>
 209 |     | <span class='neutral'>            z = 1;</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'>        // else z = 0 (default value)</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/SqrtPriceMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LowGasSafeMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./SafeCast.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &#39;./FullMath.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./UnsafeMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./FixedPoint96.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @title Functions based on Q64.96 sqrt price and liquidity</span>
  12 |     | <span class='unexecuted'>/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas</span>
  13 |     | <span class='neutral'>library SqrtPriceMath {</span>
  14 |     | <span class='neutral'>    using LowGasSafeMath for uint256;</span>
  15 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given a delta of token0</span>
  18 |     | <span class='neutral'>    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least</span>
  19 |     | <span class='neutral'>    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the</span>
  20 |     | <span class='neutral'>    /// price less in order to not send too much output.</span>
  21 |     | <span class='neutral'>    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),</span>
  22 |     | <span class='neutral'>    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).</span>
  23 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta</span>
  24 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
  25 |     | <span class='neutral'>    /// @param amount How much of token0 to add or remove from virtual reserves</span>
  26 |     | <span class='neutral'>    /// @param add Whether to add or remove the amount of token0</span>
  27 |     | <span class='neutral'>    /// @return The price after adding or removing amount, depending on add</span>
  28 |     | <span class='unexecuted'>    function getNextSqrtPriceFromAmount0RoundingUp(</span>
  29 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
  30 |     | <span class='neutral'>        uint128 liquidity,</span>
  31 |     | <span class='neutral'>        uint256 amount,</span>
  32 |     | <span class='neutral'>        bool add</span>
  33 |     | <span class='unexecuted'>    ) internal pure returns (uint160) {</span>
  34 |     | <span class='neutral'>        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price</span>
  35 |     | <span class='unexecuted'>        if (amount == 0) return sqrtPX96;</span>
  36 |     | <span class='unexecuted'>        uint256 numerator1 = uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>        if (add) {</span>
  39 |     | <span class='unexecuted'>            uint256 product;</span>
  40 |     | <span class='unexecuted'>            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {</span>
  41 |     | <span class='unexecuted'>                uint256 denominator = numerator1 + product;</span>
  42 |     | <span class='unexecuted'>                if (denominator &gt;= numerator1)</span>
  43 |     | <span class='neutral'>                    // always fits in 160 bits</span>
  44 |     | <span class='unexecuted'>                    return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));</span>
  48 |     | <span class='neutral'>        } else {</span>
  49 |     | <span class='unexecuted'>            uint256 product;</span>
  50 |     | <span class='neutral'>            // if the product overflows, we know the denominator underflows</span>
  51 |     | <span class='neutral'>            // in addition, we must check that the denominator does not underflow</span>
  52 |     | <span class='unexecuted'>            require((product = amount * sqrtPX96) / amount == sqrtPX96 &amp;&amp; numerator1 &gt; product);</span>
  53 |     | <span class='unexecuted'>            uint256 denominator = numerator1 - product;</span>
  54 |     | <span class='unexecuted'>            return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given a delta of token1</span>
  59 |     | <span class='neutral'>    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least</span>
  60 |     | <span class='neutral'>    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the</span>
  61 |     | <span class='neutral'>    /// price less in order to not send too much output.</span>
  62 |     | <span class='neutral'>    /// The formula we compute is within &lt;1 wei of the lossless version: sqrtPX96 +- amount / liquidity</span>
  63 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta</span>
  64 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
  65 |     | <span class='neutral'>    /// @param amount How much of token1 to add, or remove, from virtual reserves</span>
  66 |     | <span class='neutral'>    /// @param add Whether to add, or remove, the amount of token1</span>
  67 |     | <span class='neutral'>    /// @return The price after adding or removing `amount`</span>
  68 |     | <span class='unexecuted'>    function getNextSqrtPriceFromAmount1RoundingDown(</span>
  69 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
  70 |     | <span class='neutral'>        uint128 liquidity,</span>
  71 |     | <span class='neutral'>        uint256 amount,</span>
  72 |     | <span class='neutral'>        bool add</span>
  73 |     | <span class='unexecuted'>    ) internal pure returns (uint160) {</span>
  74 |     | <span class='neutral'>        // if we&#39;re adding (subtracting), rounding down requires rounding the quotient down (up)</span>
  75 |     | <span class='neutral'>        // in both cases, avoid a mulDiv for most inputs</span>
  76 |     | <span class='unexecuted'>        if (add) {</span>
  77 |     | <span class='unexecuted'>            uint256 quotient =</span>
  78 |     | <span class='neutral'>                (</span>
  79 |     | <span class='unexecuted'>                    amount &lt;= type(uint160).max</span>
  80 |     | <span class='unexecuted'>                        ? (amount &lt;&lt; FixedPoint96.RESOLUTION) / liquidity</span>
  81 |     | <span class='unexecuted'>                        : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)</span>
  82 |     | <span class='neutral'>                );</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>            return uint256(sqrtPX96).add(quotient).toUint160();</span>
  85 |     | <span class='neutral'>        } else {</span>
  86 |     | <span class='unexecuted'>            uint256 quotient =</span>
  87 |     | <span class='neutral'>                (</span>
  88 |     | <span class='unexecuted'>                    amount &lt;= type(uint160).max</span>
  89 |     | <span class='unexecuted'>                        ? UnsafeMath.divRoundingUp(amount &lt;&lt; FixedPoint96.RESOLUTION, liquidity)</span>
  90 |     | <span class='unexecuted'>                        : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)</span>
  91 |     | <span class='neutral'>                );</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>            require(sqrtPX96 &gt; quotient);</span>
  94 |     | <span class='neutral'>            // always fits 160 bits</span>
  95 |     | <span class='unexecuted'>            return uint160(sqrtPX96 - quotient);</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given an input amount of token0 or token1</span>
 100 |     | <span class='neutral'>    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds</span>
 101 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount</span>
 102 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 103 |     | <span class='neutral'>    /// @param amountIn How much of token0, or token1, is being swapped in</span>
 104 |     | <span class='neutral'>    /// @param zeroForOne Whether the amount in is token0 or token1</span>
 105 |     | <span class='neutral'>    /// @return sqrtQX96 The price after adding the input amount to token0 or token1</span>
 106 |     | <span class='unexecuted'>    function getNextSqrtPriceFromInput(</span>
 107 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
 108 |     | <span class='neutral'>        uint128 liquidity,</span>
 109 |     | <span class='neutral'>        uint256 amountIn,</span>
 110 |     | <span class='neutral'>        bool zeroForOne</span>
 111 |     | <span class='unexecuted'>    ) internal pure returns (uint160 sqrtQX96) {</span>
 112 |     | <span class='unexecuted'>        require(sqrtPX96 &gt; 0);</span>
 113 |     | <span class='unexecuted'>        require(liquidity &gt; 0);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        // round to make sure that we don&#39;t pass the target price</span>
 116 |     | <span class='unexecuted'>        return</span>
 117 |     | <span class='unexecuted'>            zeroForOne</span>
 118 |     | <span class='unexecuted'>                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)</span>
 119 |     | <span class='unexecuted'>                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given an output amount of token0 or token1</span>
 123 |     | <span class='neutral'>    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds</span>
 124 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price before accounting for the output amount</span>
 125 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 126 |     | <span class='neutral'>    /// @param amountOut How much of token0, or token1, is being swapped out</span>
 127 |     | <span class='neutral'>    /// @param zeroForOne Whether the amount out is token0 or token1</span>
 128 |     | <span class='neutral'>    /// @return sqrtQX96 The price after removing the output amount of token0 or token1</span>
 129 |     | <span class='unexecuted'>    function getNextSqrtPriceFromOutput(</span>
 130 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
 131 |     | <span class='neutral'>        uint128 liquidity,</span>
 132 |     | <span class='neutral'>        uint256 amountOut,</span>
 133 |     | <span class='neutral'>        bool zeroForOne</span>
 134 |     | <span class='unexecuted'>    ) internal pure returns (uint160 sqrtQX96) {</span>
 135 |     | <span class='unexecuted'>        require(sqrtPX96 &gt; 0);</span>
 136 |     | <span class='unexecuted'>        require(liquidity &gt; 0);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        // round to make sure that we pass the target price</span>
 139 |     | <span class='unexecuted'>        return</span>
 140 |     | <span class='unexecuted'>            zeroForOne</span>
 141 |     | <span class='unexecuted'>                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)</span>
 142 |     | <span class='unexecuted'>                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    /// @notice Gets the amount0 delta between two prices</span>
 146 |     | <span class='neutral'>    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),</span>
 147 |     | <span class='neutral'>    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))</span>
 148 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 149 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 150 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 151 |     | <span class='neutral'>    /// @param roundUp Whether to round the amount up or down</span>
 152 |     | <span class='neutral'>    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices</span>
 153 |     | <span class='unexecuted'>    function getAmount0Delta(</span>
 154 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 155 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 156 |     | <span class='neutral'>        uint128 liquidity,</span>
 157 |     | <span class='neutral'>        bool roundUp</span>
 158 |     | <span class='unexecuted'>    ) internal pure returns (uint256 amount0) {</span>
 159 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>        uint256 numerator1 = uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION;</span>
 162 |     | <span class='unexecuted'>        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>        require(sqrtRatioAX96 &gt; 0);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>        return</span>
 167 |     | <span class='unexecuted'>            roundUp</span>
 168 |     | <span class='unexecuted'>                ? UnsafeMath.divRoundingUp(</span>
 169 |     | <span class='unexecuted'>                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),</span>
 170 |     | <span class='unexecuted'>                    sqrtRatioAX96</span>
 171 |     | <span class='neutral'>                )</span>
 172 |     | <span class='unexecuted'>                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    /// @notice Gets the amount1 delta between two prices</span>
 176 |     | <span class='neutral'>    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))</span>
 177 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 178 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 179 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 180 |     | <span class='neutral'>    /// @param roundUp Whether to round the amount up, or down</span>
 181 |     | <span class='neutral'>    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices</span>
 182 |     | <span class='unexecuted'>    function getAmount1Delta(</span>
 183 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 184 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 185 |     | <span class='neutral'>        uint128 liquidity,</span>
 186 |     | <span class='neutral'>        bool roundUp</span>
 187 |     | <span class='unexecuted'>    ) internal pure returns (uint256 amount1) {</span>
 188 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>        return</span>
 191 |     | <span class='unexecuted'>            roundUp</span>
 192 |     | <span class='unexecuted'>                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)</span>
 193 |     | <span class='unexecuted'>                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    /// @notice Helper that gets signed token0 delta</span>
 197 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 198 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 199 |     | <span class='neutral'>    /// @param liquidity The change in liquidity for which to compute the amount0 delta</span>
 200 |     | <span class='neutral'>    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices</span>
 201 |     | <span class='unexecuted'>    function getAmount0Delta(</span>
 202 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 203 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 204 |     | <span class='neutral'>        int128 liquidity</span>
 205 |     | <span class='unexecuted'>    ) internal pure returns (int256 amount0) {</span>
 206 |     | <span class='unexecuted'>        return</span>
 207 |     | <span class='unexecuted'>            liquidity &lt; 0</span>
 208 |     | <span class='unexecuted'>                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()</span>
 209 |     | <span class='unexecuted'>                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /// @notice Helper that gets signed token1 delta</span>
 213 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 214 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 215 |     | <span class='neutral'>    /// @param liquidity The change in liquidity for which to compute the amount1 delta</span>
 216 |     | <span class='neutral'>    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices</span>
 217 |     | <span class='unexecuted'>    function getAmount1Delta(</span>
 218 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 219 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 220 |     | <span class='neutral'>        int128 liquidity</span>
 221 |     | <span class='unexecuted'>    ) internal pure returns (int256 amount1) {</span>
 222 |     | <span class='unexecuted'>        return</span>
 223 |     | <span class='unexecuted'>            liquidity &lt; 0</span>
 224 |     | <span class='unexecuted'>                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()</span>
 225 |     | <span class='unexecuted'>                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'>}</span>
 228 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/SwapMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./FullMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./SqrtPriceMath.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @title Computes the result of a swap within ticks</span>
   8 |     | <span class='unexecuted'>/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.</span>
   9 |     | <span class='neutral'>library SwapMath {</span>
  10 |     | <span class='neutral'>    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap</span>
  11 |     | <span class='neutral'>    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap&#39;s `amountSpecified` is positive</span>
  12 |     | <span class='neutral'>    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool</span>
  13 |     | <span class='neutral'>    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred</span>
  14 |     | <span class='neutral'>    /// @param liquidity The usable liquidity</span>
  15 |     | <span class='neutral'>    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out</span>
  16 |     | <span class='neutral'>    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip</span>
  17 |     | <span class='neutral'>    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target</span>
  18 |     | <span class='neutral'>    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap</span>
  19 |     | <span class='neutral'>    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap</span>
  20 |     | <span class='neutral'>    /// @return feeAmount The amount of input that will be taken as a fee</span>
  21 |     | <span class='unexecuted'>    function computeSwapStep(</span>
  22 |     | <span class='neutral'>        uint160 sqrtRatioCurrentX96,</span>
  23 |     | <span class='neutral'>        uint160 sqrtRatioTargetX96,</span>
  24 |     | <span class='neutral'>        uint128 liquidity,</span>
  25 |     | <span class='neutral'>        int256 amountRemaining,</span>
  26 |     | <span class='neutral'>        uint24 feePips</span>
  27 |     | <span class='neutral'>    )</span>
  28 |     | <span class='neutral'>        internal</span>
  29 |     | <span class='neutral'>        pure</span>
  30 |     | <span class='neutral'>        returns (</span>
  31 |     | <span class='unexecuted'>            uint160 sqrtRatioNextX96,</span>
  32 |     | <span class='unexecuted'>            uint256 amountIn,</span>
  33 |     | <span class='unexecuted'>            uint256 amountOut,</span>
  34 |     | <span class='unexecuted'>            uint256 feeAmount</span>
  35 |     | <span class='neutral'>        )</span>
  36 |     | <span class='neutral'>    {</span>
  37 |     | <span class='unexecuted'>        bool zeroForOne = sqrtRatioCurrentX96 &gt;= sqrtRatioTargetX96;</span>
  38 |     | <span class='unexecuted'>        bool exactIn = amountRemaining &gt;= 0;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>        if (exactIn) {</span>
  41 |     | <span class='unexecuted'>            uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);</span>
  42 |     | <span class='unexecuted'>            amountIn = zeroForOne</span>
  43 |     | <span class='unexecuted'>                ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)</span>
  44 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);</span>
  45 |     | <span class='unexecuted'>            if (amountRemainingLessFee &gt;= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;</span>
  46 |     | <span class='neutral'>            else</span>
  47 |     | <span class='unexecuted'>                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(</span>
  48 |     | <span class='unexecuted'>                    sqrtRatioCurrentX96,</span>
  49 |     | <span class='unexecuted'>                    liquidity,</span>
  50 |     | <span class='unexecuted'>                    amountRemainingLessFee,</span>
  51 |     | <span class='unexecuted'>                    zeroForOne</span>
  52 |     | <span class='neutral'>                );</span>
  53 |     | <span class='neutral'>        } else {</span>
  54 |     | <span class='unexecuted'>            amountOut = zeroForOne</span>
  55 |     | <span class='unexecuted'>                ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)</span>
  56 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);</span>
  57 |     | <span class='unexecuted'>            if (uint256(-amountRemaining) &gt;= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;</span>
  58 |     | <span class='neutral'>            else</span>
  59 |     | <span class='unexecuted'>                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(</span>
  60 |     | <span class='unexecuted'>                    sqrtRatioCurrentX96,</span>
  61 |     | <span class='unexecuted'>                    liquidity,</span>
  62 |     | <span class='unexecuted'>                    uint256(-amountRemaining),</span>
  63 |     | <span class='unexecuted'>                    zeroForOne</span>
  64 |     | <span class='neutral'>                );</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        // get the input/output amounts</span>
  70 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
  71 |     | <span class='unexecuted'>            amountIn = max &amp;&amp; exactIn</span>
  72 |     | <span class='unexecuted'>                ? amountIn</span>
  73 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);</span>
  74 |     | <span class='unexecuted'>            amountOut = max &amp;&amp; !exactIn</span>
  75 |     | <span class='unexecuted'>                ? amountOut</span>
  76 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);</span>
  77 |     | <span class='neutral'>        } else {</span>
  78 |     | <span class='unexecuted'>            amountIn = max &amp;&amp; exactIn</span>
  79 |     | <span class='unexecuted'>                ? amountIn</span>
  80 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);</span>
  81 |     | <span class='unexecuted'>            amountOut = max &amp;&amp; !exactIn</span>
  82 |     | <span class='unexecuted'>                ? amountOut</span>
  83 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        // cap the output amount to not exceed the remaining output amount</span>
  87 |     | <span class='unexecuted'>        if (!exactIn &amp;&amp; amountOut &gt; uint256(-amountRemaining)) {</span>
  88 |     | <span class='unexecuted'>            amountOut = uint256(-amountRemaining);</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        if (exactIn &amp;&amp; sqrtRatioNextX96 != sqrtRatioTargetX96) {</span>
  92 |     | <span class='neutral'>            // we didn&#39;t reach the target, so take the remainder of the maximum input as fee</span>
  93 |     | <span class='unexecuted'>            feeAmount = uint256(amountRemaining) - amountIn;</span>
  94 |     | <span class='neutral'>        } else {</span>
  95 |     | <span class='unexecuted'>            feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'>}</span>
  99 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/Tick.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0 &lt;0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LowGasSafeMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./SafeCast.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &#39;./TickMath.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./LiquidityMath.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @title Tick</span>
  11 |     | <span class='unexecuted'>/// @notice Contains functions for managing tick processes and relevant calculations</span>
  12 |     | <span class='neutral'>library Tick {</span>
  13 |     | <span class='neutral'>    using LowGasSafeMath for int256;</span>
  14 |     | <span class='neutral'>    using SafeCast for int256;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    // info stored for each initialized individual tick</span>
  17 |     | <span class='neutral'>    struct Info {</span>
  18 |     | <span class='neutral'>        // the total position liquidity that references this tick</span>
  19 |     | <span class='neutral'>        uint128 liquidityGross;</span>
  20 |     | <span class='neutral'>        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),</span>
  21 |     | <span class='neutral'>        int128 liquidityNet;</span>
  22 |     | <span class='neutral'>        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span>
  23 |     | <span class='neutral'>        // only has relative meaning, not absolute  the value depends on when the tick is initialized</span>
  24 |     | <span class='neutral'>        uint256 feeGrowthOutside0X128;</span>
  25 |     | <span class='neutral'>        uint256 feeGrowthOutside1X128;</span>
  26 |     | <span class='neutral'>        // the cumulative tick value on the other side of the tick</span>
  27 |     | <span class='neutral'>        int56 tickCumulativeOutside;</span>
  28 |     | <span class='neutral'>        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span>
  29 |     | <span class='neutral'>        // only has relative meaning, not absolute  the value depends on when the tick is initialized</span>
  30 |     | <span class='neutral'>        uint160 secondsPerLiquidityOutsideX128;</span>
  31 |     | <span class='neutral'>        // the seconds spent on the other side of the tick (relative to the current tick)</span>
  32 |     | <span class='neutral'>        // only has relative meaning, not absolute  the value depends on when the tick is initialized</span>
  33 |     | <span class='neutral'>        uint32 secondsOutside;</span>
  34 |     | <span class='neutral'>        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0</span>
  35 |     | <span class='neutral'>        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks</span>
  36 |     | <span class='neutral'>        bool initialized;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /// @notice Derives max liquidity per tick from given tick spacing</span>
  40 |     | <span class='neutral'>    /// @dev Executed within the pool constructor</span>
  41 |     | <span class='neutral'>    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`</span>
  42 |     | <span class='neutral'>    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...</span>
  43 |     | <span class='neutral'>    /// @return The max liquidity per tick</span>
  44 |     | <span class='unexecuted'>    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {</span>
  45 |     | <span class='unexecuted'>        int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;</span>
  46 |     | <span class='unexecuted'>        int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;</span>
  47 |     | <span class='unexecuted'>        uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;</span>
  48 |     | <span class='unexecuted'>        return type(uint128).max / numTicks;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @notice Retrieves fee growth data</span>
  52 |     | <span class='neutral'>    /// @param self The mapping containing all tick information for initialized ticks</span>
  53 |     | <span class='neutral'>    /// @param tickLower The lower tick boundary of the position</span>
  54 |     | <span class='neutral'>    /// @param tickUpper The upper tick boundary of the position</span>
  55 |     | <span class='neutral'>    /// @param tickCurrent The current tick</span>
  56 |     | <span class='neutral'>    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0</span>
  57 |     | <span class='neutral'>    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1</span>
  58 |     | <span class='neutral'>    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position&#39;s tick boundaries</span>
  59 |     | <span class='neutral'>    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position&#39;s tick boundaries</span>
  60 |     | <span class='unexecuted'>    function getFeeGrowthInside(</span>
  61 |     | <span class='neutral'>        mapping(int24 =&gt; Tick.Info) storage self,</span>
  62 |     | <span class='neutral'>        int24 tickLower,</span>
  63 |     | <span class='neutral'>        int24 tickUpper,</span>
  64 |     | <span class='neutral'>        int24 tickCurrent,</span>
  65 |     | <span class='neutral'>        uint256 feeGrowthGlobal0X128,</span>
  66 |     | <span class='neutral'>        uint256 feeGrowthGlobal1X128</span>
  67 |     | <span class='unexecuted'>    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {</span>
  68 |     | <span class='unexecuted'>        Info storage lower = self[tickLower];</span>
  69 |     | <span class='unexecuted'>        Info storage upper = self[tickUpper];</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // calculate fee growth below</span>
  72 |     | <span class='unexecuted'>        uint256 feeGrowthBelow0X128;</span>
  73 |     | <span class='unexecuted'>        uint256 feeGrowthBelow1X128;</span>
  74 |     | <span class='unexecuted'>        if (tickCurrent &gt;= tickLower) {</span>
  75 |     | <span class='unexecuted'>            feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;</span>
  76 |     | <span class='unexecuted'>            feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;</span>
  77 |     | <span class='neutral'>        } else {</span>
  78 |     | <span class='unexecuted'>            feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;</span>
  79 |     | <span class='unexecuted'>            feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        // calculate fee growth above</span>
  83 |     | <span class='unexecuted'>        uint256 feeGrowthAbove0X128;</span>
  84 |     | <span class='unexecuted'>        uint256 feeGrowthAbove1X128;</span>
  85 |     | <span class='unexecuted'>        if (tickCurrent &lt; tickUpper) {</span>
  86 |     | <span class='unexecuted'>            feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;</span>
  87 |     | <span class='unexecuted'>            feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;</span>
  88 |     | <span class='neutral'>        } else {</span>
  89 |     | <span class='unexecuted'>            feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;</span>
  90 |     | <span class='unexecuted'>            feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;</span>
  91 |     | <span class='neutral'>        }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;</span>
  94 |     | <span class='unexecuted'>        feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa</span>
  98 |     | <span class='neutral'>    /// @param self The mapping containing all tick information for initialized ticks</span>
  99 |     | <span class='neutral'>    /// @param tick The tick that will be updated</span>
 100 |     | <span class='neutral'>    /// @param tickCurrent The current tick</span>
 101 |     | <span class='neutral'>    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)</span>
 102 |     | <span class='neutral'>    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0</span>
 103 |     | <span class='neutral'>    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1</span>
 104 |     | <span class='neutral'>    /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool</span>
 105 |     | <span class='neutral'>    /// @param tickCumulative The tick * time elapsed since the pool was first initialized</span>
 106 |     | <span class='neutral'>    /// @param time The current block timestamp cast to a uint32</span>
 107 |     | <span class='neutral'>    /// @param upper true for updating a position&#39;s upper tick, or false for updating a position&#39;s lower tick</span>
 108 |     | <span class='neutral'>    /// @param maxLiquidity The maximum liquidity allocation for a single tick</span>
 109 |     | <span class='neutral'>    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa</span>
 110 |     | <span class='unexecuted'>    function update(</span>
 111 |     | <span class='neutral'>        mapping(int24 =&gt; Tick.Info) storage self,</span>
 112 |     | <span class='neutral'>        int24 tick,</span>
 113 |     | <span class='neutral'>        int24 tickCurrent,</span>
 114 |     | <span class='neutral'>        int128 liquidityDelta,</span>
 115 |     | <span class='neutral'>        uint256 feeGrowthGlobal0X128,</span>
 116 |     | <span class='neutral'>        uint256 feeGrowthGlobal1X128,</span>
 117 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128,</span>
 118 |     | <span class='neutral'>        int56 tickCumulative,</span>
 119 |     | <span class='neutral'>        uint32 time,</span>
 120 |     | <span class='neutral'>        bool upper,</span>
 121 |     | <span class='neutral'>        uint128 maxLiquidity</span>
 122 |     | <span class='unexecuted'>    ) internal returns (bool flipped) {</span>
 123 |     | <span class='unexecuted'>        Tick.Info storage info = self[tick];</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        uint128 liquidityGrossBefore = info.liquidityGross;</span>
 126 |     | <span class='unexecuted'>        uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        require(liquidityGrossAfter &lt;= maxLiquidity, &#39;LO&#39;);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>        if (liquidityGrossBefore == 0) {</span>
 133 |     | <span class='neutral'>            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick</span>
 134 |     | <span class='unexecuted'>            if (tick &lt;= tickCurrent) {</span>
 135 |     | <span class='unexecuted'>                info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;</span>
 136 |     | <span class='unexecuted'>                info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;</span>
 137 |     | <span class='unexecuted'>                info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;</span>
 138 |     | <span class='unexecuted'>                info.tickCumulativeOutside = tickCumulative;</span>
 139 |     | <span class='unexecuted'>                info.secondsOutside = time;</span>
 140 |     | <span class='neutral'>            }</span>
 141 |     | <span class='unexecuted'>            info.initialized = true;</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        info.liquidityGross = liquidityGrossAfter;</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)</span>
 147 |     | <span class='unexecuted'>        info.liquidityNet = upper</span>
 148 |     | <span class='unexecuted'>            ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()</span>
 149 |     | <span class='unexecuted'>            : int256(info.liquidityNet).add(liquidityDelta).toInt128();</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /// @notice Clears tick data</span>
 153 |     | <span class='neutral'>    /// @param self The mapping containing all initialized tick information for initialized ticks</span>
 154 |     | <span class='neutral'>    /// @param tick The tick that will be cleared</span>
 155 |     | <span class='unexecuted'>    function clear(mapping(int24 =&gt; Tick.Info) storage self, int24 tick) internal {</span>
 156 |     | <span class='unexecuted'>        delete self[tick];</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @notice Transitions to next tick as needed by price movement</span>
 160 |     | <span class='neutral'>    /// @param self The mapping containing all tick information for initialized ticks</span>
 161 |     | <span class='neutral'>    /// @param tick The destination tick of the transition</span>
 162 |     | <span class='neutral'>    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0</span>
 163 |     | <span class='neutral'>    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1</span>
 164 |     | <span class='neutral'>    /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity</span>
 165 |     | <span class='neutral'>    /// @param tickCumulative The tick * time elapsed since the pool was first initialized</span>
 166 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 167 |     | <span class='neutral'>    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)</span>
 168 |     | <span class='unexecuted'>    function cross(</span>
 169 |     | <span class='neutral'>        mapping(int24 =&gt; Tick.Info) storage self,</span>
 170 |     | <span class='neutral'>        int24 tick,</span>
 171 |     | <span class='neutral'>        uint256 feeGrowthGlobal0X128,</span>
 172 |     | <span class='neutral'>        uint256 feeGrowthGlobal1X128,</span>
 173 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128,</span>
 174 |     | <span class='neutral'>        int56 tickCumulative,</span>
 175 |     | <span class='neutral'>        uint32 time</span>
 176 |     | <span class='unexecuted'>    ) internal returns (int128 liquidityNet) {</span>
 177 |     | <span class='unexecuted'>        Tick.Info storage info = self[tick];</span>
 178 |     | <span class='unexecuted'>        info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;</span>
 179 |     | <span class='unexecuted'>        info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;</span>
 180 |     | <span class='unexecuted'>        info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;</span>
 181 |     | <span class='unexecuted'>        info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;</span>
 182 |     | <span class='unexecuted'>        info.secondsOutside = time - info.secondsOutside;</span>
 183 |     | <span class='unexecuted'>        liquidityNet = info.liquidityNet;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'>}</span>
 186 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/TickBitmap.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./BitMath.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title Packed tick initialized state library</span>
  7 |     | <span class='neutral'>/// @notice Stores a packed mapping of tick index to its initialized state</span>
  8 |     | <span class='unexecuted'>/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.</span>
  9 |     | <span class='neutral'>library TickBitmap {</span>
 10 |     | <span class='neutral'>    /// @notice Computes the position in the mapping where the initialized bit for a tick lives</span>
 11 |     | <span class='neutral'>    /// @param tick The tick for which to compute the position</span>
 12 |     | <span class='neutral'>    /// @return wordPos The key in the mapping containing the word in which the bit is stored</span>
 13 |     | <span class='neutral'>    /// @return bitPos The bit position in the word where the flag is stored</span>
 14 |     | <span class='unexecuted'>    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {</span>
 15 |     | <span class='unexecuted'>        wordPos = int16(tick &gt;&gt; 8);</span>
 16 |     | <span class='unexecuted'>        bitPos = uint8(tick % 256);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice Flips the initialized state for a given tick from false to true, or vice versa</span>
 20 |     | <span class='neutral'>    /// @param self The mapping in which to flip the tick</span>
 21 |     | <span class='neutral'>    /// @param tick The tick to flip</span>
 22 |     | <span class='neutral'>    /// @param tickSpacing The spacing between usable ticks</span>
 23 |     | <span class='unexecuted'>    function flipTick(</span>
 24 |     | <span class='neutral'>        mapping(int16 =&gt; uint256) storage self,</span>
 25 |     | <span class='neutral'>        int24 tick,</span>
 26 |     | <span class='neutral'>        int24 tickSpacing</span>
 27 |     | <span class='neutral'>    ) internal {</span>
 28 |     | <span class='unexecuted'>        require(tick % tickSpacing == 0); // ensure that the tick is spaced</span>
 29 |     | <span class='unexecuted'>        (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);</span>
 30 |     | <span class='unexecuted'>        uint256 mask = 1 &lt;&lt; bitPos;</span>
 31 |     | <span class='unexecuted'>        self[wordPos] ^= mask;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either</span>
 35 |     | <span class='neutral'>    /// to the left (less than or equal to) or right (greater than) of the given tick</span>
 36 |     | <span class='neutral'>    /// @param self The mapping in which to compute the next initialized tick</span>
 37 |     | <span class='neutral'>    /// @param tick The starting tick</span>
 38 |     | <span class='neutral'>    /// @param tickSpacing The spacing between usable ticks</span>
 39 |     | <span class='neutral'>    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)</span>
 40 |     | <span class='neutral'>    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick</span>
 41 |     | <span class='neutral'>    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks</span>
 42 |     | <span class='unexecuted'>    function nextInitializedTickWithinOneWord(</span>
 43 |     | <span class='neutral'>        mapping(int16 =&gt; uint256) storage self,</span>
 44 |     | <span class='neutral'>        int24 tick,</span>
 45 |     | <span class='neutral'>        int24 tickSpacing,</span>
 46 |     | <span class='neutral'>        bool lte</span>
 47 |     | <span class='unexecuted'>    ) internal view returns (int24 next, bool initialized) {</span>
 48 |     | <span class='unexecuted'>        int24 compressed = tick / tickSpacing;</span>
 49 |     | <span class='unexecuted'>        if (tick &lt; 0 &amp;&amp; tick % tickSpacing != 0) compressed--; // round towards negative infinity</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        if (lte) {</span>
 52 |     | <span class='unexecuted'>            (int16 wordPos, uint8 bitPos) = position(compressed);</span>
 53 |     | <span class='neutral'>            // all the 1s at or to the right of the current bitPos</span>
 54 |     | <span class='unexecuted'>            uint256 mask = (1 &lt;&lt; bitPos) - 1 + (1 &lt;&lt; bitPos);</span>
 55 |     | <span class='unexecuted'>            uint256 masked = self[wordPos] &amp; mask;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>            // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word</span>
 58 |     | <span class='unexecuted'>            initialized = masked != 0;</span>
 59 |     | <span class='neutral'>            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick</span>
 60 |     | <span class='unexecuted'>            next = initialized</span>
 61 |     | <span class='unexecuted'>                ? (compressed - int24(bitPos - BitMath.mostSignificantBit(masked))) * tickSpacing</span>
 62 |     | <span class='unexecuted'>                : (compressed - int24(bitPos)) * tickSpacing;</span>
 63 |     | <span class='neutral'>        } else {</span>
 64 |     | <span class='neutral'>            // start from the word of the next tick, since the current tick state doesn&#39;t matter</span>
 65 |     | <span class='unexecuted'>            (int16 wordPos, uint8 bitPos) = position(compressed + 1);</span>
 66 |     | <span class='neutral'>            // all the 1s at or to the left of the bitPos</span>
 67 |     | <span class='unexecuted'>            uint256 mask = ~((1 &lt;&lt; bitPos) - 1);</span>
 68 |     | <span class='unexecuted'>            uint256 masked = self[wordPos] &amp; mask;</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>            // if there are no initialized ticks to the left of the current tick, return leftmost in the word</span>
 71 |     | <span class='unexecuted'>            initialized = masked != 0;</span>
 72 |     | <span class='neutral'>            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick</span>
 73 |     | <span class='unexecuted'>            next = initialized</span>
 74 |     | <span class='unexecuted'>                ? (compressed + 1 + int24(BitMath.leastSignificantBit(masked) - bitPos)) * tickSpacing</span>
 75 |     | <span class='unexecuted'>                : (compressed + 1 + int24(type(uint8).max - bitPos)) * tickSpacing;</span>
 76 |     | <span class='neutral'>        }</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/TickMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0 &lt;0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Math library for computing sqrt prices from ticks and vice versa</span>
   5 |     | <span class='neutral'>/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports</span>
   6 |     | <span class='unexecuted'>/// prices between 2**-128 and 2**128</span>
   7 |     | <span class='neutral'>library TickMath {</span>
   8 |     | <span class='neutral'>    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128</span>
   9 |     | <span class='unexecuted'>    int24 internal constant MIN_TICK = -887272;</span>
  10 |     | <span class='neutral'>    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128</span>
  11 |     | <span class='unexecuted'>    int24 internal constant MAX_TICK = -MIN_TICK;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)</span>
  14 |     | <span class='unexecuted'>    uint160 internal constant MIN_SQRT_RATIO = 4295128739;</span>
  15 |     | <span class='neutral'>    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)</span>
  16 |     | <span class='unexecuted'>    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96</span>
  19 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick</span>
  20 |     | <span class='neutral'>    /// @param tick The input tick for the above formula</span>
  21 |     | <span class='neutral'>    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
  22 |     | <span class='neutral'>    /// at the given tick</span>
  23 |     | <span class='unexecuted'>    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {</span>
  24 |     | <span class='unexecuted'>        uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span>
  25 |     | <span class='unexecuted'>        require(absTick &lt;= uint256(MAX_TICK), &#39;T&#39;);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>        uint256 ratio = absTick &amp; 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;</span>
  28 |     | <span class='unexecuted'>        if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
  29 |     | <span class='unexecuted'>        if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
  30 |     | <span class='unexecuted'>        if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
  31 |     | <span class='unexecuted'>        if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
  32 |     | <span class='unexecuted'>        if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
  33 |     | <span class='unexecuted'>        if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
  34 |     | <span class='unexecuted'>        if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
  35 |     | <span class='unexecuted'>        if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
  36 |     | <span class='unexecuted'>        if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
  37 |     | <span class='unexecuted'>        if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
  38 |     | <span class='unexecuted'>        if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
  39 |     | <span class='unexecuted'>        if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
  40 |     | <span class='unexecuted'>        if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
  41 |     | <span class='unexecuted'>        if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
  42 |     | <span class='unexecuted'>        if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
  43 |     | <span class='unexecuted'>        if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
  44 |     | <span class='unexecuted'>        if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
  45 |     | <span class='unexecuted'>        if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
  46 |     | <span class='unexecuted'>        if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // this divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
  51 |     | <span class='neutral'>        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint</span>
  52 |     | <span class='neutral'>        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent</span>
  53 |     | <span class='unexecuted'>        sqrtPriceX96 = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio</span>
  57 |     | <span class='neutral'>    /// @dev Throws in case sqrtPriceX96 &lt; MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may</span>
  58 |     | <span class='neutral'>    /// ever return.</span>
  59 |     | <span class='neutral'>    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96</span>
  60 |     | <span class='neutral'>    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio</span>
  61 |     | <span class='unexecuted'>    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {</span>
  62 |     | <span class='neutral'>        // second inequality must be &lt; because the price can never reach the price at the max tick</span>
  63 |     | <span class='unexecuted'>        require(sqrtPriceX96 &gt;= MIN_SQRT_RATIO &amp;&amp; sqrtPriceX96 &lt; MAX_SQRT_RATIO, &#39;R&#39;);</span>
  64 |     | <span class='unexecuted'>        uint256 ratio = uint256(sqrtPriceX96) &lt;&lt; 32;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>        uint256 r = ratio;</span>
  67 |     | <span class='unexecuted'>        uint256 msb = 0;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        assembly {</span>
  70 |     | <span class='unexecuted'>            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
  71 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  72 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='unexecuted'>        assembly {</span>
  75 |     | <span class='unexecuted'>            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
  76 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  77 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='unexecuted'>        assembly {</span>
  80 |     | <span class='unexecuted'>            let f := shl(5, gt(r, 0xFFFFFFFF))</span>
  81 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  82 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='unexecuted'>        assembly {</span>
  85 |     | <span class='unexecuted'>            let f := shl(4, gt(r, 0xFFFF))</span>
  86 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  87 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='unexecuted'>        assembly {</span>
  90 |     | <span class='unexecuted'>            let f := shl(3, gt(r, 0xFF))</span>
  91 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  92 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='unexecuted'>        assembly {</span>
  95 |     | <span class='unexecuted'>            let f := shl(2, gt(r, 0xF))</span>
  96 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  97 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='unexecuted'>        assembly {</span>
 100 |     | <span class='unexecuted'>            let f := shl(1, gt(r, 0x3))</span>
 101 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 102 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='unexecuted'>        assembly {</span>
 105 |     | <span class='unexecuted'>            let f := gt(r, 0x1)</span>
 106 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 110 |     | <span class='unexecuted'>        else r = ratio &lt;&lt; (127 - msb);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        int256 log_2 = (int256(msb) - 128) &lt;&lt; 64;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        assembly {</span>
 115 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 116 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 117 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(63, f))</span>
 118 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='unexecuted'>        assembly {</span>
 121 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 122 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 123 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(62, f))</span>
 124 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='unexecuted'>        assembly {</span>
 127 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 128 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 129 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(61, f))</span>
 130 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='unexecuted'>        assembly {</span>
 133 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 134 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 135 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(60, f))</span>
 136 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='unexecuted'>        assembly {</span>
 139 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 140 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 141 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(59, f))</span>
 142 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='unexecuted'>        assembly {</span>
 145 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 146 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 147 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(58, f))</span>
 148 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='unexecuted'>        assembly {</span>
 151 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 152 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 153 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(57, f))</span>
 154 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='unexecuted'>        assembly {</span>
 157 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 158 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 159 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(56, f))</span>
 160 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='unexecuted'>        assembly {</span>
 163 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 164 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 165 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(55, f))</span>
 166 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='unexecuted'>        assembly {</span>
 169 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 170 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 171 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(54, f))</span>
 172 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='unexecuted'>        assembly {</span>
 175 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 176 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 177 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(53, f))</span>
 178 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='unexecuted'>        assembly {</span>
 181 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 182 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 183 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(52, f))</span>
 184 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='unexecuted'>        assembly {</span>
 187 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 188 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 189 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(51, f))</span>
 190 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='unexecuted'>        assembly {</span>
 193 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 194 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 195 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(50, f))</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) &gt;&gt; 128);</span>
 201 |     | <span class='unexecuted'>        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) &gt;&gt; 128);</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) &lt;= sqrtPriceX96 ? tickHi : tickLow;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'>}</span>
 206 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/TransferHelper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/IERC20Minimal.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title TransferHelper</span>
  7 |     | <span class='unexecuted'>/// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false</span>
  8 |     | <span class='neutral'>library TransferHelper {</span>
  9 |     | <span class='neutral'>    /// @notice Transfers tokens from msg.sender to a recipient</span>
 10 |     | <span class='neutral'>    /// @dev Calls transfer on token contract, errors with TF if transfer fails</span>
 11 |     | <span class='neutral'>    /// @param token The contract address of the token which will be transferred</span>
 12 |     | <span class='neutral'>    /// @param to The recipient of the transfer</span>
 13 |     | <span class='neutral'>    /// @param value The value of the transfer</span>
 14 |     | <span class='unexecuted'>    function safeTransfer(</span>
 15 |     | <span class='neutral'>        address token,</span>
 16 |     | <span class='neutral'>        address to,</span>
 17 |     | <span class='neutral'>        uint256 value</span>
 18 |     | <span class='neutral'>    ) internal {</span>
 19 |     | <span class='unexecuted'>        (bool success, bytes memory data) =</span>
 20 |     | <span class='unexecuted'>            token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value));</span>
 21 |     | <span class='unexecuted'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &#39;TF&#39;);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/UnsafeMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Math functions that do not check inputs or outputs</span>
  5 |     | <span class='unexecuted'>/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks</span>
  6 |     | <span class='neutral'>library UnsafeMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns ceil(x / y)</span>
  8 |     | <span class='neutral'>    /// @dev division by 0 has unspecified behavior, and must be checked externally</span>
  9 |     | <span class='neutral'>    /// @param x The dividend</span>
 10 |     | <span class='neutral'>    /// @param y The divisor</span>
 11 |     | <span class='neutral'>    /// @return z The quotient, ceil(x / y)</span>
 12 |     | <span class='unexecuted'>    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 13 |     | <span class='unexecuted'>        assembly {</span>
 14 |     | <span class='unexecuted'>            z := add(div(x, y), gt(mod(x, y), 0))</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/interfaces/IUnipilotFactory.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title The interface for the Unipilot Factory</span>
  5 |     | <span class='neutral'>interface IUnipilotFactory {</span>
  6 |     | <span class='neutral'>    /// @notice Emitted when a vault is created</span>
  7 |     | <span class='neutral'>    /// @param _tokenA The first token of the pool by address sort order</span>
  8 |     | <span class='neutral'>    /// @param _tokenB The second token of the pool by address sort order</span>
  9 |     | <span class='neutral'>    /// @param _fee The fee tier for which the vault is created</span>
 10 |     | <span class='neutral'>    /// @param _vault The address of the vault that is created</span>
 11 |     | <span class='neutral'>    event VaultCreated(</span>
 12 |     | <span class='neutral'>        address indexed _tokenA,</span>
 13 |     | <span class='neutral'>        address indexed _tokenB,</span>
 14 |     | <span class='neutral'>        uint16 _strategyType,</span>
 15 |     | <span class='neutral'>        uint24 _fee,</span>
 16 |     | <span class='neutral'>        address indexed _vault</span>
 17 |     | <span class='neutral'>    );</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice Emitted when the governance of the factory is changed</span>
 20 |     | <span class='neutral'>    /// @param _oldGovernance The governance before the governance was changed</span>
 21 |     | <span class='neutral'>    /// @param _newGovernance The governance after the governance was changed</span>
 22 |     | <span class='neutral'>    event GovernanceChanged(</span>
 23 |     | <span class='neutral'>        address indexed _oldGovernance,</span>
 24 |     | <span class='neutral'>        address indexed _newGovernance</span>
 25 |     | <span class='neutral'>    );</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /// @notice Creates a vault for the given two tokens and fee</span>
 28 |     | <span class='neutral'>    /// @param _tokenA The first token of the pool by address sort order</span>
 29 |     | <span class='neutral'>    /// @param _tokenB The second token of the pool by address sort order</span>
 30 |     | <span class='neutral'>    /// @param _fee The desired fee for the unipilot vault</span>
 31 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0.</span>
 32 |     | <span class='neutral'>    /// The call will revert if the vault already exists, the fee is invalid, or the token arguments</span>
 33 |     | <span class='neutral'>    /// are invalid.</span>
 34 |     | <span class='neutral'>    /// @return _vault The address of the newly created pool</span>
 35 |     | <span class='neutral'>    function createVault(</span>
 36 |     | <span class='neutral'>        address _tokenA,</span>
 37 |     | <span class='neutral'>        address _tokenB,</span>
 38 |     | <span class='neutral'>        uint24 _fee,</span>
 39 |     | <span class='neutral'>        uint16 _vaultStrategy,</span>
 40 |     | <span class='neutral'>        uint160 _sqrtPriceX96,</span>
 41 |     | <span class='neutral'>        string memory _name,</span>
 42 |     | <span class='neutral'>        string memory _symbol</span>
 43 |     | <span class='neutral'>    ) external returns (address _vault);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    /// @notice Used to give addresses of governance, strategy, indexFund</span>
 46 |     | <span class='neutral'>    /// @return governance address, strategy address, indexFund address</span>
 47 |     | <span class='neutral'>    function getUnipilotDetails()</span>
 48 |     | <span class='neutral'>        external</span>
 49 |     | <span class='neutral'>        view</span>
 50 |     | <span class='neutral'>        returns (</span>
 51 |     | <span class='neutral'>            address,</span>
 52 |     | <span class='neutral'>            address,</span>
 53 |     | <span class='neutral'>            address,</span>
 54 |     | <span class='neutral'>            uint8,</span>
 55 |     | <span class='neutral'>            uint8</span>
 56 |     | <span class='neutral'>        );</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/interfaces/IUnipilotStrategy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.7.6;</span>
  3 |     | <span class='neutral'>pragma abicoder v2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IUnipilotStrategy {</span>
  6 |     | <span class='neutral'>    struct PoolStrategy {</span>
  7 |     | <span class='neutral'>        int24 baseThreshold;</span>
  8 |     | <span class='neutral'>        int24 rangeThreshold;</span>
  9 |     | <span class='neutral'>        int24 maxTwapDeviation;</span>
 10 |     | <span class='neutral'>        int24 readjustThreshold;</span>
 11 |     | <span class='neutral'>        uint32 twapDuration;</span>
 12 |     | <span class='neutral'>        int24 baseMultiplier;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    event GovernanceUpdated(address oldGovernance, address newGovernance);</span>
 16 |     | <span class='neutral'>    event StrategyUpdated(PoolStrategy oldStrategy, PoolStrategy newStrategy);</span>
 17 |     | <span class='neutral'>    event MaxTwapDeviationUpdated(int24 oldDeviation, int24 newDeviation);</span>
 18 |     | <span class='neutral'>    event BaseTicksUpdated(int24 oldBaseTicks, int24 newBaseTicks);</span>
 19 |     | <span class='neutral'>    event RangeTicksUpdated(int24 oldRangeTicks, int24 newRangeTicks);</span>
 20 |     | <span class='neutral'>    event TwapDurationUpdated(uint32 oldDuration, uint32 newDuration);</span>
 21 |     | <span class='neutral'>    event ReadjustMultiplierUpdated(int24 oldMultiplier, int24 newMultiplier);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function getTicks(address _pool)</span>
 24 |     | <span class='neutral'>        external</span>
 25 |     | <span class='neutral'>        returns (</span>
 26 |     | <span class='neutral'>            int24 baseLower,</span>
 27 |     | <span class='neutral'>            int24 baseUpper,</span>
 28 |     | <span class='neutral'>            int24 bidLower,</span>
 29 |     | <span class='neutral'>            int24 bidUpper,</span>
 30 |     | <span class='neutral'>            int24 askLower,</span>
 31 |     | <span class='neutral'>            int24 askUpper</span>
 32 |     | <span class='neutral'>        );</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function getTwap(address _pool) external view returns (int24);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function getStrategy(address _pool)</span>
 37 |     | <span class='neutral'>        external</span>
 38 |     | <span class='neutral'>        view</span>
 39 |     | <span class='neutral'>        returns (PoolStrategy memory strategy);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function getBaseThreshold(address _pool, uint16 _strategyType)</span>
 42 |     | <span class='neutral'>        external</span>
 43 |     | <span class='neutral'>        view</span>
 44 |     | <span class='neutral'>        returns (int24 baseThreshold);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function twapDuration() external view returns (uint32);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function maxTwapDeviation() external view returns (int24);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function checkDeviation(address pool) external view;</span>
 51 |     | <span class='neutral'>}</span>
 52 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/interfaces/IUnipilotVault.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.7.6;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface IUnipilotVault {</span>
   5 |     | <span class='neutral'>    struct ReadjustVars {</span>
   6 |     | <span class='neutral'>        uint256 fees0;</span>
   7 |     | <span class='neutral'>        uint256 fees1;</span>
   8 |     | <span class='neutral'>        int24 currentTick;</span>
   9 |     | <span class='neutral'>        int24 tickLower;</span>
  10 |     | <span class='neutral'>        int24 tickUpper;</span>
  11 |     | <span class='neutral'>        uint256 amount0Desired;</span>
  12 |     | <span class='neutral'>        uint256 amount1Desired;</span>
  13 |     | <span class='neutral'>        uint128 liquidity;</span>
  14 |     | <span class='neutral'>        uint256 amount0;</span>
  15 |     | <span class='neutral'>        uint256 amount1;</span>
  16 |     | <span class='neutral'>        bool zeroForOne;</span>
  17 |     | <span class='neutral'>        int256 amountSpecified;</span>
  18 |     | <span class='neutral'>        uint160 exactSqrtPriceImpact;</span>
  19 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    struct TicksData {</span>
  23 |     | <span class='neutral'>        int24 baseTickLower;</span>
  24 |     | <span class='neutral'>        int24 baseTickUpper;</span>
  25 |     | <span class='neutral'>        int24 rangeTickLower;</span>
  26 |     | <span class='neutral'>        int24 rangeTickUpper;</span>
  27 |     | <span class='neutral'>    }</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    struct Tick {</span>
  30 |     | <span class='neutral'>        int24 baseTickLower;</span>
  31 |     | <span class='neutral'>        int24 baseTickUpper;</span>
  32 |     | <span class='neutral'>        int24 bidTickLower;</span>
  33 |     | <span class='neutral'>        int24 bidTickUpper;</span>
  34 |     | <span class='neutral'>        int24 rangeTickLower;</span>
  35 |     | <span class='neutral'>        int24 rangeTickUpper;</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    struct Cache {</span>
  39 |     | <span class='neutral'>        uint256 totalSupply;</span>
  40 |     | <span class='neutral'>        uint256 liquidityShare;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    event Deposit(</span>
  44 |     | <span class='neutral'>        address indexed depositor,</span>
  45 |     | <span class='neutral'>        address indexed recipient,</span>
  46 |     | <span class='neutral'>        uint256 amount0,</span>
  47 |     | <span class='neutral'>        uint256 amount1,</span>
  48 |     | <span class='neutral'>        uint256 lpShares</span>
  49 |     | <span class='neutral'>    );</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    event FeesSnapshot(bool isReadjustLiquidity, uint256 fees0, uint256 fees1);</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    event Withdraw(</span>
  54 |     | <span class='neutral'>        address indexed recipient,</span>
  55 |     | <span class='neutral'>        uint256 shares,</span>
  56 |     | <span class='neutral'>        uint256 amount0,</span>
  57 |     | <span class='neutral'>        uint256 amount1</span>
  58 |     | <span class='neutral'>    );</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    event PullLiquidity(</span>
  61 |     | <span class='neutral'>        uint256 reserves0,</span>
  62 |     | <span class='neutral'>        uint256 reserves1,</span>
  63 |     | <span class='neutral'>        uint256 fees0,</span>
  64 |     | <span class='neutral'>        uint256 fees1</span>
  65 |     | <span class='neutral'>    );</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    event CompoundFees(uint256 amount0, uint256 amount1);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /// @notice Deposits tokens in proportion to the Unipilot&#39;s current holdings &amp; mints them</span>
  70 |     | <span class='neutral'>    /// `Unipilot`s LP token.</span>
  71 |     | <span class='neutral'>    /// @param amount0Desired Max amount of token0 to deposit</span>
  72 |     | <span class='neutral'>    /// @param amount1Desired Max amount of token1 to deposit</span>
  73 |     | <span class='neutral'>    /// @param recipient Recipient of shares</span>
  74 |     | <span class='neutral'>    /// @return lpShares Number of shares minted</span>
  75 |     | <span class='neutral'>    /// @return amount0 Amount of token0 deposited in vault</span>
  76 |     | <span class='neutral'>    /// @return amount1 Amount of token1 deposited in vault</span>
  77 |     | <span class='neutral'>    function deposit(</span>
  78 |     | <span class='neutral'>        uint256 amount0Desired,</span>
  79 |     | <span class='neutral'>        uint256 amount1Desired,</span>
  80 |     | <span class='neutral'>        address recipient</span>
  81 |     | <span class='neutral'>    )</span>
  82 |     | <span class='neutral'>        external</span>
  83 |     | <span class='neutral'>        payable</span>
  84 |     | <span class='neutral'>        returns (</span>
  85 |     | <span class='neutral'>            uint256 lpShares,</span>
  86 |     | <span class='neutral'>            uint256 amount0,</span>
  87 |     | <span class='neutral'>            uint256 amount1</span>
  88 |     | <span class='neutral'>        );</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /// @notice Withdraws the desired shares from the vault with accumulated user fees and transfers to recipient.</span>
  91 |     | <span class='neutral'>    /// @param recipient Recipient of tokens</span>
  92 |     | <span class='neutral'>    /// @param refundAsETH whether to recieve in WETH or ETH (only valid for WETH/ALT pairs)</span>
  93 |     | <span class='neutral'>    /// @return amount0 Amount of token0 sent to recipient</span>
  94 |     | <span class='neutral'>    /// @return amount1 Amount of token1 sent to recipient</span>
  95 |     | <span class='neutral'>    function withdraw(</span>
  96 |     | <span class='neutral'>        uint256 liquidity,</span>
  97 |     | <span class='neutral'>        address recipient,</span>
  98 |     | <span class='neutral'>        bool refundAsETH</span>
  99 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /// @notice Pull in tokens from sender. Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.</span>
 102 |     | <span class='neutral'>    /// @dev In the implementation you must pay to the pool for the minted liquidity.</span>
 103 |     | <span class='neutral'>    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity</span>
 104 |     | <span class='neutral'>    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity</span>
 105 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call</span>
 106 |     | <span class='neutral'>    function uniswapV3MintCallback(</span>
 107 |     | <span class='neutral'>        uint256 amount0Owed,</span>
 108 |     | <span class='neutral'>        uint256 amount1Owed,</span>
 109 |     | <span class='neutral'>        bytes calldata data</span>
 110 |     | <span class='neutral'>    ) external;</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after minting swaping from IUniswapV3Pool#swap.</span>
 113 |     | <span class='neutral'>    /// @dev In the implementation you must pay to the pool for swap.</span>
 114 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 due to the pool for the swap</span>
 115 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 due to the pool for the swap</span>
 116 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call</span>
 117 |     | <span class='neutral'>    function uniswapV3SwapCallback(</span>
 118 |     | <span class='neutral'>        int256 amount0Delta,</span>
 119 |     | <span class='neutral'>        int256 amount1Delta,</span>
 120 |     | <span class='neutral'>        bytes calldata data</span>
 121 |     | <span class='neutral'>    ) external;</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /// @notice Burns all position(s), collects any fees accrued and updates Unipilot&#39;s position(s)</span>
 124 |     | <span class='neutral'>    /// @dev mints all amounts to this position(s) (including earned fees)</span>
 125 |     | <span class='neutral'>    /// @dev For active vaults it can be called by the governance or operator,</span>
 126 |     | <span class='neutral'>    /// swaps imbalanced token and add all liquidity in base position.</span>
 127 |     | <span class='neutral'>    /// @dev For passive vaults it can be called by any user.</span>
 128 |     | <span class='neutral'>    /// Two positions are placed - a base position and a limit position. The base</span>
 129 |     | <span class='neutral'>    /// position is placed first with as much liquidity as possible. This position</span>
 130 |     | <span class='neutral'>    /// should use up all of one token, leaving only the other one. This excess</span>
 131 |     | <span class='neutral'>    /// amount is then placed as a single-sided bid or ask position.</span>
 132 |     | <span class='neutral'>    function readjustLiquidity(uint8 swapBP) external;</span>
 133 |     | <span class='neutral'>}</span>
 134 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/interfaces/external/IWETH9.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// import &quot;./IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IWETH9 {</span>
  7 |     | <span class='neutral'>    /**</span>
  8 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
  9 |     | <span class='neutral'>     */</span>
 10 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `recipient`.</span>
 19 |     | <span class='neutral'>     *</span>
 20 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /**</span>
 27 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 28 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 29 |     | <span class='neutral'>     * zero by default.</span>
 30 |     | <span class='neutral'>     *</span>
 31 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 32 |     | <span class='neutral'>     */</span>
 33 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 37 |     | <span class='neutral'>     *</span>
 38 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 39 |     | <span class='neutral'>     *</span>
 40 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 41 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 42 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 43 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 44 |     | <span class='neutral'>     * desired value afterwards:</span>
 45 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 48 |     | <span class='neutral'>     */</span>
 49 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    /**</span>
 52 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `sender` to `recipient` using the</span>
 53 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 54 |     | <span class='neutral'>     * allowance.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    /**</span>
 63 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 64 |     | <span class='neutral'>     * another (`to`).</span>
 65 |     | <span class='neutral'>     *</span>
 66 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 67 |     | <span class='neutral'>     */</span>
 68 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    /**</span>
 71 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 72 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 73 |     | <span class='neutral'>     */</span>
 74 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>     function deposit() external payable;</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='neutral'>    /// @notice Withdraw wrapped ether to get ether</span>
 79 |     | <span class='neutral'>    function withdraw(uint256) external;</span>
 80 |     | <span class='neutral'>}</span>
 81 |     | <span class='neutral'></span>
 82 |     | <span class='neutral'>/// @title Interface for WETH9</span>
 83 |     | <span class='neutral'>// interface IWETH9 is IERC20 {</span>
 84 |     | <span class='neutral'>//     /// @notice Deposit ether to get wrapped ether</span>
 85 |     | <span class='neutral'>//     function deposit() external payable;</span>
 86 |     | <span class='neutral'></span>
 87 |     | <span class='neutral'>//     /// @notice Withdraw wrapped ether to get ether</span>
 88 |     | <span class='neutral'>//     function withdraw(uint256) external;</span>
 89 |     | <span class='neutral'>// }</span>
 90 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/libraries/SafeCastExtended.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity ^0.7.0;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>/**</span>
   6 |     | <span class='neutral'> * @dev Wrappers over Solidity&#39;s uintXX/intXX casting operators with added overflow</span>
   7 |     | <span class='neutral'> * checks.</span>
   8 |     | <span class='neutral'> *</span>
   9 |     | <span class='neutral'> * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can</span>
  10 |     | <span class='neutral'> * easily result in undesired exploitation or bugs, since developers usually</span>
  11 |     | <span class='neutral'> * assume that overflows raise errors. `SafeCast` restores this intuition by</span>
  12 |     | <span class='neutral'> * reverting the transaction when such an operation overflows.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * Using this library instead of the unchecked operations eliminates an entire</span>
  15 |     | <span class='neutral'> * class of bugs, so it&#39;s recommended to use it always.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing</span>
  18 |     | <span class='neutral'> * all math on `uint256` and `int256` and then downcasting.</span>
  19 |     | <span class='unexecuted'> */</span>
  20 |     | <span class='neutral'>library SafeCastExtended {</span>
  21 |     | <span class='neutral'>    /**</span>
  22 |     | <span class='neutral'>     * @dev Returns the downcasted uint128 from uint256, reverting on</span>
  23 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint128).</span>
  24 |     | <span class='neutral'>     *</span>
  25 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint128` operator.</span>
  26 |     | <span class='neutral'>     *</span>
  27 |     | <span class='neutral'>     * Requirements:</span>
  28 |     | <span class='neutral'>     *</span>
  29 |     | <span class='neutral'>     * - input must fit into 128 bits</span>
  30 |     | <span class='neutral'>     */</span>
  31 |     | <span class='unexecuted'>    function toUint128(uint256 value) internal pure returns (uint128) {</span>
  32 |     | <span class='unexecuted'>        require(value &lt; 2**128, &quot;SafeCast: value doesn&#39;t fit in 128 bits&quot;);</span>
  33 |     | <span class='unexecuted'>        return uint128(value);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * @dev Returns the downcasted uint64 from uint256, reverting on</span>
  38 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint64).</span>
  39 |     | <span class='neutral'>     *</span>
  40 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint64` operator.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * Requirements:</span>
  43 |     | <span class='neutral'>     *</span>
  44 |     | <span class='neutral'>     * - input must fit into 64 bits</span>
  45 |     | <span class='neutral'>     */</span>
  46 |     | <span class='neutral'>    function toUint64(uint256 value) internal pure returns (uint64) {</span>
  47 |     | <span class='neutral'>        require(value &lt; 2**64, &quot;SafeCast: value doesn&#39;t fit in 64 bits&quot;);</span>
  48 |     | <span class='neutral'>        return uint64(value);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /**</span>
  52 |     | <span class='neutral'>     * @dev Returns the downcasted uint32 from uint256, reverting on</span>
  53 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint32).</span>
  54 |     | <span class='neutral'>     *</span>
  55 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint32` operator.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * Requirements:</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * - input must fit into 32 bits</span>
  60 |     | <span class='neutral'>     */</span>
  61 |     | <span class='neutral'>    function toUint32(uint256 value) internal pure returns (uint32) {</span>
  62 |     | <span class='neutral'>        require(value &lt; 2**32, &quot;SafeCast: value doesn&#39;t fit in 32 bits&quot;);</span>
  63 |     | <span class='neutral'>        return uint32(value);</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the downcasted uint16 from uint256, reverting on</span>
  68 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint16).</span>
  69 |     | <span class='neutral'>     *</span>
  70 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint16` operator.</span>
  71 |     | <span class='neutral'>     *</span>
  72 |     | <span class='neutral'>     * Requirements:</span>
  73 |     | <span class='neutral'>     *</span>
  74 |     | <span class='neutral'>     * - input must fit into 16 bits</span>
  75 |     | <span class='neutral'>     */</span>
  76 |     | <span class='neutral'>    function toUint16(uint256 value) internal pure returns (uint16) {</span>
  77 |     | <span class='neutral'>        require(value &lt; 2**16, &quot;SafeCast: value doesn&#39;t fit in 16 bits&quot;);</span>
  78 |     | <span class='neutral'>        return uint16(value);</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /**</span>
  82 |     | <span class='neutral'>     * @dev Returns the downcasted uint8 from uint256, reverting on</span>
  83 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint8).</span>
  84 |     | <span class='neutral'>     *</span>
  85 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint8` operator.</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * Requirements:</span>
  88 |     | <span class='neutral'>     *</span>
  89 |     | <span class='neutral'>     * - input must fit into 8 bits.</span>
  90 |     | <span class='neutral'>     */</span>
  91 |     | <span class='neutral'>    function toUint8(uint256 value) internal pure returns (uint8) {</span>
  92 |     | <span class='neutral'>        require(value &lt; 2**8, &quot;SafeCast: value doesn&#39;t fit in 8 bits&quot;);</span>
  93 |     | <span class='neutral'>        return uint8(value);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    /**</span>
  97 |     | <span class='neutral'>     * @dev Converts a signed int256 into an unsigned uint256.</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * Requirements:</span>
 100 |     | <span class='neutral'>     *</span>
 101 |     | <span class='neutral'>     * - input must be greater than or equal to 0.</span>
 102 |     | <span class='neutral'>     */</span>
 103 |     | <span class='neutral'>    function toUint256(int256 value) internal pure returns (uint256) {</span>
 104 |     | <span class='neutral'>        require(value &gt;= 0, &quot;SafeCast: value must be positive&quot;);</span>
 105 |     | <span class='neutral'>        return uint256(value);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /**</span>
 109 |     | <span class='neutral'>     * @dev Returns the downcasted int128 from int256, reverting on</span>
 110 |     | <span class='neutral'>     * overflow (when the input is less than smallest int128 or</span>
 111 |     | <span class='neutral'>     * greater than largest int128).</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int128` operator.</span>
 114 |     | <span class='neutral'>     *</span>
 115 |     | <span class='neutral'>     * Requirements:</span>
 116 |     | <span class='neutral'>     *</span>
 117 |     | <span class='neutral'>     * - input must fit into 128 bits</span>
 118 |     | <span class='neutral'>     *</span>
 119 |     | <span class='neutral'>     * _Available since v3.1._</span>
 120 |     | <span class='neutral'>     */</span>
 121 |     | <span class='neutral'>    function toInt128(int256 value) internal pure returns (int128) {</span>
 122 |     | <span class='neutral'>        require(</span>
 123 |     | <span class='neutral'>            value &gt;= -2**127 &amp;&amp; value &lt; 2**127,</span>
 124 |     | <span class='neutral'>            &quot;SafeCast: value doesn&#39;t fit in 128 bits&quot;</span>
 125 |     | <span class='neutral'>        );</span>
 126 |     | <span class='neutral'>        return int128(value);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @dev Returns the downcasted int64 from int256, reverting on</span>
 131 |     | <span class='neutral'>     * overflow (when the input is less than smallest int64 or</span>
 132 |     | <span class='neutral'>     * greater than largest int64).</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int64` operator.</span>
 135 |     | <span class='neutral'>     *</span>
 136 |     | <span class='neutral'>     * Requirements:</span>
 137 |     | <span class='neutral'>     *</span>
 138 |     | <span class='neutral'>     * - input must fit into 64 bits</span>
 139 |     | <span class='neutral'>     *</span>
 140 |     | <span class='neutral'>     * _Available since v3.1._</span>
 141 |     | <span class='neutral'>     */</span>
 142 |     | <span class='neutral'>    function toInt64(int256 value) internal pure returns (int64) {</span>
 143 |     | <span class='neutral'>        require(</span>
 144 |     | <span class='neutral'>            value &gt;= -2**63 &amp;&amp; value &lt; 2**63,</span>
 145 |     | <span class='neutral'>            &quot;SafeCast: value doesn&#39;t fit in 64 bits&quot;</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='neutral'>        return int64(value);</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    /**</span>
 151 |     | <span class='neutral'>     * @dev Returns the downcasted int32 from int256, reverting on</span>
 152 |     | <span class='neutral'>     * overflow (when the input is less than smallest int32 or</span>
 153 |     | <span class='neutral'>     * greater than largest int32).</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int32` operator.</span>
 156 |     | <span class='neutral'>     *</span>
 157 |     | <span class='neutral'>     * Requirements:</span>
 158 |     | <span class='neutral'>     *</span>
 159 |     | <span class='neutral'>     * - input must fit into 32 bits</span>
 160 |     | <span class='neutral'>     *</span>
 161 |     | <span class='neutral'>     * _Available since v3.1._</span>
 162 |     | <span class='neutral'>     */</span>
 163 |     | <span class='neutral'>    function toInt32(int256 value) internal pure returns (int32) {</span>
 164 |     | <span class='neutral'>        require(</span>
 165 |     | <span class='neutral'>            value &gt;= -2**31 &amp;&amp; value &lt; 2**31,</span>
 166 |     | <span class='neutral'>            &quot;SafeCast: value doesn&#39;t fit in 32 bits&quot;</span>
 167 |     | <span class='neutral'>        );</span>
 168 |     | <span class='neutral'>        return int32(value);</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    /**</span>
 172 |     | <span class='neutral'>     * @dev Returns the downcasted int16 from int256, reverting on</span>
 173 |     | <span class='neutral'>     * overflow (when the input is less than smallest int16 or</span>
 174 |     | <span class='neutral'>     * greater than largest int16).</span>
 175 |     | <span class='neutral'>     *</span>
 176 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int16` operator.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * Requirements:</span>
 179 |     | <span class='neutral'>     *</span>
 180 |     | <span class='neutral'>     * - input must fit into 16 bits</span>
 181 |     | <span class='neutral'>     *</span>
 182 |     | <span class='neutral'>     * _Available since v3.1._</span>
 183 |     | <span class='neutral'>     */</span>
 184 |     | <span class='neutral'>    function toInt16(int256 value) internal pure returns (int16) {</span>
 185 |     | <span class='neutral'>        require(</span>
 186 |     | <span class='neutral'>            value &gt;= -2**15 &amp;&amp; value &lt; 2**15,</span>
 187 |     | <span class='neutral'>            &quot;SafeCast: value doesn&#39;t fit in 16 bits&quot;</span>
 188 |     | <span class='neutral'>        );</span>
 189 |     | <span class='neutral'>        return int16(value);</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    /**</span>
 193 |     | <span class='neutral'>     * @dev Returns the downcasted int8 from int256, reverting on</span>
 194 |     | <span class='neutral'>     * overflow (when the input is less than smallest int8 or</span>
 195 |     | <span class='neutral'>     * greater than largest int8).</span>
 196 |     | <span class='neutral'>     *</span>
 197 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int8` operator.</span>
 198 |     | <span class='neutral'>     *</span>
 199 |     | <span class='neutral'>     * Requirements:</span>
 200 |     | <span class='neutral'>     *</span>
 201 |     | <span class='neutral'>     * - input must fit into 8 bits.</span>
 202 |     | <span class='neutral'>     *</span>
 203 |     | <span class='neutral'>     * _Available since v3.1._</span>
 204 |     | <span class='neutral'>     */</span>
 205 |     | <span class='neutral'>    function toInt8(int256 value) internal pure returns (int8) {</span>
 206 |     | <span class='neutral'>        require(</span>
 207 |     | <span class='neutral'>            value &gt;= -2**7 &amp;&amp; value &lt; 2**7,</span>
 208 |     | <span class='neutral'>            &quot;SafeCast: value doesn&#39;t fit in 8 bits&quot;</span>
 209 |     | <span class='neutral'>        );</span>
 210 |     | <span class='neutral'>        return int8(value);</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Converts an unsigned uint256 into a signed int256.</span>
 215 |     | <span class='neutral'>     *</span>
 216 |     | <span class='neutral'>     * Requirements:</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * - input must be less than or equal to maxInt256.</span>
 219 |     | <span class='neutral'>     */</span>
 220 |     | <span class='unexecuted'>    function toInt256(uint256 value) internal pure returns (int256) {</span>
 221 |     | <span class='unexecuted'>        require(value &lt; 2**255, &quot;SafeCast: value doesn&#39;t fit in an int256&quot;);</span>
 222 |     | <span class='unexecuted'>        return int256(value);</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'>}</span>
 225 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/libraries/TransferHelper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// import &quot;../interfaces/external/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import {ERC20Permit, IERC20, ERC20} from &quot;../dependencies/ERC20Permit.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>//import &quot;../interfaces/external/IERC20.sol&quot;;</span>
  8 |     | <span class='unexecuted'></span>
  9 |     | <span class='neutral'>library TransferHelper {</span>
 10 |     | <span class='neutral'>    /// @notice Transfers tokens from the targeted address to the given destination</span>
 11 |     | <span class='neutral'>    /// @notice Errors with &#39;STF&#39; if transfer fails</span>
 12 |     | <span class='neutral'>    /// @param token The contract address of the token to be transferred</span>
 13 |     | <span class='neutral'>    /// @param from The originating address from which the tokens will be transferred</span>
 14 |     | <span class='neutral'>    /// @param to The destination address of the transfer</span>
 15 |     | <span class='neutral'>    /// @param value The amount to be transferred</span>
 16 |     | <span class='unexecuted'>    function safeTransferFrom(</span>
 17 |     | <span class='neutral'>        address token,</span>
 18 |     | <span class='neutral'>        address from,</span>
 19 |     | <span class='neutral'>        address to,</span>
 20 |     | <span class='neutral'>        uint256 value</span>
 21 |     | <span class='neutral'>    ) internal {</span>
 22 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token.call(</span>
 23 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 24 |     | <span class='unexecuted'>                IERC20.transferFrom.selector,</span>
 25 |     | <span class='unexecuted'>                from,</span>
 26 |     | <span class='unexecuted'>                to,</span>
 27 |     | <span class='unexecuted'>                value</span>
 28 |     | <span class='neutral'>            )</span>
 29 |     | <span class='neutral'>        );</span>
 30 |     | <span class='unexecuted'>        require(</span>
 31 |     | <span class='unexecuted'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
 32 |     | <span class='neutral'>            &quot;STF&quot;</span>
 33 |     | <span class='neutral'>        );</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Transfers tokens from msg.sender to a recipient</span>
 37 |     | <span class='neutral'>    /// @dev Errors with ST if transfer fails</span>
 38 |     | <span class='neutral'>    /// @param token The contract address of the token which will be transferred</span>
 39 |     | <span class='neutral'>    /// @param to The recipient of the transfer</span>
 40 |     | <span class='neutral'>    /// @param value The value of the transfer</span>
 41 |     | <span class='unexecuted'>    function safeTransfer(</span>
 42 |     | <span class='neutral'>        address token,</span>
 43 |     | <span class='neutral'>        address to,</span>
 44 |     | <span class='neutral'>        uint256 value</span>
 45 |     | <span class='neutral'>    ) internal {</span>
 46 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token.call(</span>
 47 |     | <span class='unexecuted'>            abi.encodeWithSelector(IERC20.transfer.selector, to, value)</span>
 48 |     | <span class='neutral'>        );</span>
 49 |     | <span class='unexecuted'>        require(</span>
 50 |     | <span class='unexecuted'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
 51 |     | <span class='neutral'>            &quot;ST&quot;</span>
 52 |     | <span class='neutral'>        );</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    /// @notice Approves the stipulated contract to spend the given allowance in the given token</span>
 56 |     | <span class='neutral'>    /// @dev Errors with &#39;SA&#39; if transfer fails</span>
 57 |     | <span class='neutral'>    /// @param token The contract address of the token to be approved</span>
 58 |     | <span class='neutral'>    /// @param to The target of the approval</span>
 59 |     | <span class='neutral'>    /// @param value The amount of the given token the target will be allowed to spend</span>
 60 |     | <span class='neutral'>    function safeApprove(</span>
 61 |     | <span class='neutral'>        address token,</span>
 62 |     | <span class='neutral'>        address to,</span>
 63 |     | <span class='neutral'>        uint256 value</span>
 64 |     | <span class='neutral'>    ) internal {</span>
 65 |     | <span class='neutral'>        (bool success, bytes memory data) = token.call(</span>
 66 |     | <span class='neutral'>            abi.encodeWithSelector(IERC20.approve.selector, to, value)</span>
 67 |     | <span class='neutral'>        );</span>
 68 |     | <span class='neutral'>        require(</span>
 69 |     | <span class='neutral'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
 70 |     | <span class='neutral'>            &quot;SA&quot;</span>
 71 |     | <span class='neutral'>        );</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    /// @notice Transfers ETH to the recipient address</span>
 75 |     | <span class='neutral'>    /// @dev Fails with `STE`</span>
 76 |     | <span class='neutral'>    /// @param to The destination of the transfer</span>
 77 |     | <span class='neutral'>    /// @param value The value to be transferred</span>
 78 |     | <span class='unexecuted'>    function safeTransferETH(address to, uint256 value) internal {</span>
 79 |     | <span class='unexecuted'>        (bool success, ) = to.call{ value: value }(new bytes(0));</span>
 80 |     | <span class='unexecuted'>        require(success, &quot;STE&quot;);</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/libraries/UniswapLiquidityManagement.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'>import &quot;./UniswapPoolActions.sol&quot;;</span>
   4 |     | <span class='neutral'>import &quot;../dependencies/libraries/TickMath.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../dependencies/libraries/SqrtPriceMath.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../dependencies/PositionKey.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../dependencies/LiquidityAmounts.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../interfaces/IUnipilotVault.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @title Liquidity and ticks functions</span>
  11 |     | <span class='unexecuted'>/// @notice Provides functions for computing liquidity and ticks for token amounts and prices</span>
  12 |     | <span class='neutral'>library UniswapLiquidityManagement {</span>
  13 |     | <span class='neutral'>    using LowGasSafeMath for uint256;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    struct Info {</span>
  16 |     | <span class='neutral'>        uint256 amount0Desired;</span>
  17 |     | <span class='neutral'>        uint256 amount1Desired;</span>
  18 |     | <span class='neutral'>        uint256 amount0;</span>
  19 |     | <span class='neutral'>        uint256 amount1;</span>
  20 |     | <span class='neutral'>        uint128 liquidity;</span>
  21 |     | <span class='neutral'>        int24 tickLower;</span>
  22 |     | <span class='neutral'>        int24 tickUpper;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @dev Wrapper around `LiquidityAmounts.getAmountsForLiquidity()`.</span>
  26 |     | <span class='neutral'>    /// @param pool Uniswap V3 pool</span>
  27 |     | <span class='neutral'>    /// @param liquidity  The liquidity being valued</span>
  28 |     | <span class='neutral'>    /// @param _tickLower The lower tick of the range</span>
  29 |     | <span class='neutral'>    /// @param _tickUpper The upper tick of the range</span>
  30 |     | <span class='neutral'>    /// @return amounts of token0 and token1 that corresponds to liquidity</span>
  31 |     | <span class='unexecuted'>    function getAmountsForLiquidity(</span>
  32 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
  33 |     | <span class='neutral'>        uint128 liquidity,</span>
  34 |     | <span class='neutral'>        int24 _tickLower,</span>
  35 |     | <span class='neutral'>        int24 _tickUpper</span>
  36 |     | <span class='unexecuted'>    ) internal view returns (uint256, uint256) {</span>
  37 |     | <span class='unexecuted'>        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();</span>
  38 |     | <span class='unexecuted'>        return</span>
  39 |     | <span class='unexecuted'>            LiquidityAmounts.getAmountsForLiquidity(</span>
  40 |     | <span class='unexecuted'>                sqrtRatioX96,</span>
  41 |     | <span class='unexecuted'>                TickMath.getSqrtRatioAtTick(_tickLower),</span>
  42 |     | <span class='unexecuted'>                TickMath.getSqrtRatioAtTick(_tickUpper),</span>
  43 |     | <span class='unexecuted'>                liquidity</span>
  44 |     | <span class='neutral'>            );</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @dev Wrapper around `LiquidityAmounts.getLiquidityForAmounts()`.</span>
  48 |     | <span class='neutral'>    /// @param pool Uniswap V3 pool</span>
  49 |     | <span class='neutral'>    /// @param amount0 The amount of token0</span>
  50 |     | <span class='neutral'>    /// @param amount1 The amount of token1</span>
  51 |     | <span class='neutral'>    /// @param _tickLower The lower tick of the range</span>
  52 |     | <span class='neutral'>    /// @param _tickUpper The upper tick of the range</span>
  53 |     | <span class='neutral'>    /// @return The maximum amount of liquidity that can be held amount0 and amount1</span>
  54 |     | <span class='unexecuted'>    function getLiquidityForAmounts(</span>
  55 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
  56 |     | <span class='neutral'>        uint256 amount0,</span>
  57 |     | <span class='neutral'>        uint256 amount1,</span>
  58 |     | <span class='neutral'>        int24 _tickLower,</span>
  59 |     | <span class='neutral'>        int24 _tickUpper</span>
  60 |     | <span class='unexecuted'>    ) internal view returns (uint128) {</span>
  61 |     | <span class='unexecuted'>        (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>        return</span>
  64 |     | <span class='unexecuted'>            LiquidityAmounts.getLiquidityForAmounts(</span>
  65 |     | <span class='unexecuted'>                sqrtRatioX96,</span>
  66 |     | <span class='unexecuted'>                TickMath.getSqrtRatioAtTick(_tickLower),</span>
  67 |     | <span class='unexecuted'>                TickMath.getSqrtRatioAtTick(_tickUpper),</span>
  68 |     | <span class='unexecuted'>                amount0,</span>
  69 |     | <span class='unexecuted'>                amount1</span>
  70 |     | <span class='neutral'>            );</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /// @dev Amount of liquidity in contract position.</span>
  74 |     | <span class='neutral'>    /// @param pool Uniswap V3 pool</span>
  75 |     | <span class='neutral'>    /// @param _tickLower The lower tick of the range</span>
  76 |     | <span class='neutral'>    /// @param _tickUpper The upper tick of the range</span>
  77 |     | <span class='neutral'>    /// @return liquidity stored in position</span>
  78 |     | <span class='unexecuted'>    function getPositionLiquidity(</span>
  79 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
  80 |     | <span class='neutral'>        int24 _tickLower,</span>
  81 |     | <span class='neutral'>        int24 _tickUpper</span>
  82 |     | <span class='neutral'>    )</span>
  83 |     | <span class='neutral'>        internal</span>
  84 |     | <span class='neutral'>        view</span>
  85 |     | <span class='neutral'>        returns (</span>
  86 |     | <span class='unexecuted'>            uint128 liquidity,</span>
  87 |     | <span class='unexecuted'>            uint128 tokensOwed0,</span>
  88 |     | <span class='unexecuted'>            uint128 tokensOwed1</span>
  89 |     | <span class='neutral'>        )</span>
  90 |     | <span class='neutral'>    {</span>
  91 |     | <span class='unexecuted'>        bytes32 positionKey = PositionKey.compute(</span>
  92 |     | <span class='unexecuted'>            address(this),</span>
  93 |     | <span class='unexecuted'>            _tickLower,</span>
  94 |     | <span class='unexecuted'>            _tickUpper</span>
  95 |     | <span class='neutral'>        );</span>
  96 |     | <span class='unexecuted'>        (liquidity, , , tokensOwed0, tokensOwed1) = pool.positions(positionKey);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @dev Rounds tick down towards negative infinity so that it&#39;s a multiple</span>
 100 |     | <span class='neutral'>    /// of `tickSpacing`.</span>
 101 |     | <span class='unexecuted'>    function floor(int24 tick, int24 tickSpacing)</span>
 102 |     | <span class='neutral'>        internal</span>
 103 |     | <span class='neutral'>        pure</span>
 104 |     | <span class='unexecuted'>        returns (int24)</span>
 105 |     | <span class='neutral'>    {</span>
 106 |     | <span class='unexecuted'>        int24 compressed = tick / tickSpacing;</span>
 107 |     | <span class='unexecuted'>        if (tick &lt; 0 &amp;&amp; tick % tickSpacing != 0) compressed--;</span>
 108 |     | <span class='unexecuted'>        return compressed * tickSpacing;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function getSqrtRatioX96AndTick(IUniswapV3Pool pool)</span>
 112 |     | <span class='neutral'>        internal</span>
 113 |     | <span class='neutral'>        view</span>
 114 |     | <span class='neutral'>        returns (</span>
 115 |     | <span class='unexecuted'>            uint160 _sqrtRatioX96,</span>
 116 |     | <span class='unexecuted'>            int24 _tick,</span>
 117 |     | <span class='unexecuted'>            uint16 observationCardinality</span>
 118 |     | <span class='neutral'>        )</span>
 119 |     | <span class='neutral'>    {</span>
 120 |     | <span class='unexecuted'>        (_sqrtRatioX96, _tick, , observationCardinality, , , ) = pool.slot0();</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /// @dev Calc base ticks depending on base threshold and tickspacing</span>
 124 |     | <span class='unexecuted'>    function getBaseTicks(</span>
 125 |     | <span class='neutral'>        int24 currentTick,</span>
 126 |     | <span class='neutral'>        int24 baseThreshold,</span>
 127 |     | <span class='neutral'>        int24 tickSpacing</span>
 128 |     | <span class='unexecuted'>    ) internal pure returns (int24 tickLower, int24 tickUpper) {</span>
 129 |     | <span class='unexecuted'>        int24 tickFloor = floor(currentTick, tickSpacing);</span>
 130 |     | <span class='unexecuted'>        tickLower = tickFloor - baseThreshold;</span>
 131 |     | <span class='unexecuted'>        tickUpper = tickFloor + baseThreshold;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function collectableAmountsInPosition(</span>
 135 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
 136 |     | <span class='neutral'>        int24 _lowerTick,</span>
 137 |     | <span class='neutral'>        int24 _upperTick</span>
 138 |     | <span class='neutral'>    )</span>
 139 |     | <span class='neutral'>        internal</span>
 140 |     | <span class='neutral'>        view</span>
 141 |     | <span class='neutral'>        returns (</span>
 142 |     | <span class='unexecuted'>            uint256,</span>
 143 |     | <span class='unexecuted'>            uint256,</span>
 144 |     | <span class='unexecuted'>            uint256,</span>
 145 |     | <span class='unexecuted'>            uint256</span>
 146 |     | <span class='neutral'>        )</span>
 147 |     | <span class='neutral'>    {</span>
 148 |     | <span class='unexecuted'>        (</span>
 149 |     | <span class='unexecuted'>            uint128 liquidity,</span>
 150 |     | <span class='unexecuted'>            uint128 earnable0,</span>
 151 |     | <span class='unexecuted'>            uint128 earnable1</span>
 152 |     | <span class='unexecuted'>        ) = getPositionLiquidity(pool, _lowerTick, _upperTick);</span>
 153 |     | <span class='unexecuted'>        (uint256 burnable0, uint256 burnable1) = UniswapLiquidityManagement</span>
 154 |     | <span class='unexecuted'>            .getAmountsForLiquidity(pool, liquidity, _lowerTick, _upperTick);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        return (burnable0, burnable1, earnable0, earnable1);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>    function computeLpShares(</span>
 160 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
 161 |     | <span class='neutral'>        bool isWhitelisted,</span>
 162 |     | <span class='neutral'>        uint256 amount0Max,</span>
 163 |     | <span class='neutral'>        uint256 amount1Max,</span>
 164 |     | <span class='neutral'>        uint256 balance0,</span>
 165 |     | <span class='neutral'>        uint256 balance1,</span>
 166 |     | <span class='neutral'>        uint256 totalSupply,</span>
 167 |     | <span class='neutral'>        IUnipilotVault.TicksData memory ticks</span>
 168 |     | <span class='neutral'>    )</span>
 169 |     | <span class='neutral'>        internal</span>
 170 |     | <span class='neutral'>        returns (</span>
 171 |     | <span class='unexecuted'>            uint256 shares,</span>
 172 |     | <span class='unexecuted'>            uint256 amount0,</span>
 173 |     | <span class='unexecuted'>            uint256 amount1</span>
 174 |     | <span class='neutral'>        )</span>
 175 |     | <span class='neutral'>    {</span>
 176 |     | <span class='unexecuted'>        (</span>
 177 |     | <span class='unexecuted'>            uint256 res0,</span>
 178 |     | <span class='unexecuted'>            uint256 res1,</span>
 179 |     | <span class='unexecuted'>            uint256 fees0,</span>
 180 |     | <span class='unexecuted'>            uint256 fees1,</span>
 181 |     | <span class='neutral'>            ,</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        ) = getTotalAmounts(pool, isWhitelisted, ticks);</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>        uint256 reserve0 = res0.add(fees0).add(balance0);</span>
 186 |     | <span class='unexecuted'>        uint256 reserve1 = res1.add(fees1).add(balance1);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>        // If total supply &gt; 0, pool can&#39;t be empty</span>
 189 |     | <span class='unexecuted'>        assert(totalSupply == 0 || reserve0 != 0 || reserve1 != 0);</span>
 190 |     | <span class='unexecuted'>        (shares, amount0, amount1) = calculateShare(</span>
 191 |     | <span class='unexecuted'>            amount0Max,</span>
 192 |     | <span class='unexecuted'>            amount1Max,</span>
 193 |     | <span class='unexecuted'>            reserve0,</span>
 194 |     | <span class='unexecuted'>            reserve1,</span>
 195 |     | <span class='unexecuted'>            totalSupply</span>
 196 |     | <span class='neutral'>        );</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='unexecuted'>    function getTotalAmounts(</span>
 200 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
 201 |     | <span class='neutral'>        bool isWhitelisted,</span>
 202 |     | <span class='neutral'>        IUnipilotVault.TicksData memory ticks</span>
 203 |     | <span class='neutral'>    )</span>
 204 |     | <span class='neutral'>        internal</span>
 205 |     | <span class='neutral'>        returns (</span>
 206 |     | <span class='unexecuted'>            uint256 amount0,</span>
 207 |     | <span class='unexecuted'>            uint256 amount1,</span>
 208 |     | <span class='unexecuted'>            uint256 fees0,</span>
 209 |     | <span class='unexecuted'>            uint256 fees1,</span>
 210 |     | <span class='unexecuted'>            uint128 baseLiquidity,</span>
 211 |     | <span class='unexecuted'>            uint128 rangeLiquidity</span>
 212 |     | <span class='neutral'>        )</span>
 213 |     | <span class='neutral'>    {</span>
 214 |     | <span class='unexecuted'>        (amount0, amount1, fees0, fees1, baseLiquidity) = getReserves(</span>
 215 |     | <span class='unexecuted'>            pool,</span>
 216 |     | <span class='unexecuted'>            ticks.baseTickLower,</span>
 217 |     | <span class='unexecuted'>            ticks.baseTickUpper</span>
 218 |     | <span class='neutral'>        );</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='unexecuted'>        if (!isWhitelisted) {</span>
 221 |     | <span class='unexecuted'>            (</span>
 222 |     | <span class='unexecuted'>                uint256 range0,</span>
 223 |     | <span class='unexecuted'>                uint256 range1,</span>
 224 |     | <span class='unexecuted'>                uint256 rangeFees0,</span>
 225 |     | <span class='unexecuted'>                uint256 rangeFees1,</span>
 226 |     | <span class='unexecuted'>                uint128 rangeliquidity</span>
 227 |     | <span class='unexecuted'>            ) = getReserves(pool, ticks.rangeTickLower, ticks.rangeTickUpper);</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>            amount0 = amount0.add(range0);</span>
 230 |     | <span class='unexecuted'>            amount1 = amount1.add(range1);</span>
 231 |     | <span class='unexecuted'>            fees0 = fees0.add(rangeFees0);</span>
 232 |     | <span class='unexecuted'>            fees1 = fees1.add(rangeFees1);</span>
 233 |     | <span class='unexecuted'>            rangeLiquidity = rangeliquidity;</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='unexecuted'>    function getReserves(</span>
 238 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
 239 |     | <span class='neutral'>        int24 tickLower,</span>
 240 |     | <span class='neutral'>        int24 tickUpper</span>
 241 |     | <span class='neutral'>    )</span>
 242 |     | <span class='neutral'>        internal</span>
 243 |     | <span class='neutral'>        returns (</span>
 244 |     | <span class='unexecuted'>            uint256 amount0,</span>
 245 |     | <span class='unexecuted'>            uint256 amount1,</span>
 246 |     | <span class='unexecuted'>            uint256 fees0,</span>
 247 |     | <span class='unexecuted'>            uint256 fees1,</span>
 248 |     | <span class='unexecuted'>            uint128 liquidity</span>
 249 |     | <span class='neutral'>        )</span>
 250 |     | <span class='neutral'>    {</span>
 251 |     | <span class='unexecuted'>        liquidity = UniswapPoolActions.updatePosition(</span>
 252 |     | <span class='unexecuted'>            pool,</span>
 253 |     | <span class='unexecuted'>            tickLower,</span>
 254 |     | <span class='unexecuted'>            tickUpper</span>
 255 |     | <span class='neutral'>        );</span>
 256 |     | <span class='unexecuted'>        if (liquidity &gt; 0) {</span>
 257 |     | <span class='unexecuted'>            (amount0, amount1, fees0, fees1) = collectableAmountsInPosition(</span>
 258 |     | <span class='unexecuted'>                pool,</span>
 259 |     | <span class='unexecuted'>                tickLower,</span>
 260 |     | <span class='unexecuted'>                tickUpper</span>
 261 |     | <span class='neutral'>            );</span>
 262 |     | <span class='neutral'>        }</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='unexecuted'>    function calculateShare(</span>
 266 |     | <span class='neutral'>        uint256 amount0Max,</span>
 267 |     | <span class='neutral'>        uint256 amount1Max,</span>
 268 |     | <span class='neutral'>        uint256 reserve0,</span>
 269 |     | <span class='neutral'>        uint256 reserve1,</span>
 270 |     | <span class='neutral'>        uint256 totalSupply</span>
 271 |     | <span class='neutral'>    )</span>
 272 |     | <span class='neutral'>        internal</span>
 273 |     | <span class='neutral'>        pure</span>
 274 |     | <span class='neutral'>        returns (</span>
 275 |     | <span class='unexecuted'>            uint256 shares,</span>
 276 |     | <span class='unexecuted'>            uint256 amount0,</span>
 277 |     | <span class='unexecuted'>            uint256 amount1</span>
 278 |     | <span class='neutral'>        )</span>
 279 |     | <span class='neutral'>    {</span>
 280 |     | <span class='unexecuted'>        if (totalSupply == 0) {</span>
 281 |     | <span class='neutral'>            // For first deposit, just use the amounts desired</span>
 282 |     | <span class='unexecuted'>            amount0 = amount0Max;</span>
 283 |     | <span class='unexecuted'>            amount1 = amount1Max;</span>
 284 |     | <span class='unexecuted'>            shares = amount0 &gt; amount1 ? amount0 : amount1; // max</span>
 285 |     | <span class='unexecuted'>        } else if (reserve0 == 0) {</span>
 286 |     | <span class='unexecuted'>            amount1 = amount1Max;</span>
 287 |     | <span class='unexecuted'>            shares = FullMath.mulDiv(amount1, totalSupply, reserve1);</span>
 288 |     | <span class='unexecuted'>        } else if (reserve1 == 0) {</span>
 289 |     | <span class='unexecuted'>            amount0 = amount0Max;</span>
 290 |     | <span class='unexecuted'>            shares = FullMath.mulDiv(amount0, totalSupply, reserve0);</span>
 291 |     | <span class='neutral'>        } else {</span>
 292 |     | <span class='unexecuted'>            amount0 = FullMath.mulDiv(amount1Max, reserve0, reserve1);</span>
 293 |     | <span class='unexecuted'>            if (amount0 &lt; amount0Max) {</span>
 294 |     | <span class='unexecuted'>                amount1 = amount1Max;</span>
 295 |     | <span class='unexecuted'>                shares = FullMath.mulDiv(amount1, totalSupply, reserve1);</span>
 296 |     | <span class='neutral'>            } else {</span>
 297 |     | <span class='unexecuted'>                amount0 = amount0Max;</span>
 298 |     | <span class='unexecuted'>                amount1 = FullMath.mulDiv(amount0, reserve1, reserve0);</span>
 299 |     | <span class='unexecuted'>                shares = FullMath.mulDiv(amount0, totalSupply, reserve0);</span>
 300 |     | <span class='neutral'>            }</span>
 301 |     | <span class='neutral'>        }</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>    /// @dev Gets ticks with proportion equivalent to desired amount</span>
 305 |     | <span class='neutral'>    /// @param pool Uniswap V3 pool</span>
 306 |     | <span class='neutral'>    /// @param amount0Desired The desired amount of token0</span>
 307 |     | <span class='neutral'>    /// @param amount1Desired The desired amount of token1</span>
 308 |     | <span class='neutral'>    /// @param baseThreshold The range for upper and lower ticks</span>
 309 |     | <span class='neutral'>    /// @param tickSpacing The pool tick spacing</span>
 310 |     | <span class='neutral'>    /// @return tickLower The lower tick of the range</span>
 311 |     | <span class='neutral'>    /// @return tickUpper The upper tick of the range</span>
 312 |     | <span class='unexecuted'>    function getPositionTicks(</span>
 313 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
 314 |     | <span class='neutral'>        uint256 amount0Desired,</span>
 315 |     | <span class='neutral'>        uint256 amount1Desired,</span>
 316 |     | <span class='neutral'>        int24 baseThreshold,</span>
 317 |     | <span class='neutral'>        int24 tickSpacing</span>
 318 |     | <span class='unexecuted'>    ) internal view returns (int24 tickLower, int24 tickUpper) {</span>
 319 |     | <span class='unexecuted'>        Info memory cache = Info(amount0Desired, amount1Desired, 0, 0, 0, 0, 0);</span>
 320 |     | <span class='neutral'>        // Get current price and tick from the pool</span>
 321 |     | <span class='unexecuted'>        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();</span>
 322 |     | <span class='neutral'>        //Calc base ticks</span>
 323 |     | <span class='unexecuted'>        (cache.tickLower, cache.tickUpper) = getBaseTicks(</span>
 324 |     | <span class='unexecuted'>            currentTick,</span>
 325 |     | <span class='unexecuted'>            baseThreshold,</span>
 326 |     | <span class='unexecuted'>            tickSpacing</span>
 327 |     | <span class='neutral'>        );</span>
 328 |     | <span class='neutral'>        //Calc amounts of token0 and token1 that can be stored in base range</span>
 329 |     | <span class='unexecuted'>        (cache.amount0, cache.amount1) = getAmountsForTicks(</span>
 330 |     | <span class='unexecuted'>            pool,</span>
 331 |     | <span class='unexecuted'>            cache.amount0Desired,</span>
 332 |     | <span class='unexecuted'>            cache.amount1Desired,</span>
 333 |     | <span class='unexecuted'>            cache.tickLower,</span>
 334 |     | <span class='unexecuted'>            cache.tickUpper</span>
 335 |     | <span class='neutral'>        );</span>
 336 |     | <span class='neutral'>        // //Liquidity that can be stored in base range</span>
 337 |     | <span class='unexecuted'>        cache.liquidity = getLiquidityForAmounts(</span>
 338 |     | <span class='unexecuted'>            pool,</span>
 339 |     | <span class='unexecuted'>            cache.amount0,</span>
 340 |     | <span class='unexecuted'>            cache.amount1,</span>
 341 |     | <span class='unexecuted'>            cache.tickLower,</span>
 342 |     | <span class='unexecuted'>            cache.tickUpper</span>
 343 |     | <span class='neutral'>        );</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>        // //Get imbalanced token</span>
 346 |     | <span class='unexecuted'>        bool zeroGreaterOne = amountsDirection(</span>
 347 |     | <span class='unexecuted'>            cache.amount0Desired,</span>
 348 |     | <span class='unexecuted'>            cache.amount1Desired,</span>
 349 |     | <span class='unexecuted'>            cache.amount0,</span>
 350 |     | <span class='unexecuted'>            cache.amount1</span>
 351 |     | <span class='neutral'>        );</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>        //Calc new tick(upper or lower) for imbalanced token</span>
 354 |     | <span class='unexecuted'>        if (zeroGreaterOne) {</span>
 355 |     | <span class='unexecuted'>            uint160 nextSqrtPrice0 = SqrtPriceMath</span>
 356 |     | <span class='neutral'>                .getNextSqrtPriceFromAmount0RoundingUp(</span>
 357 |     | <span class='unexecuted'>                    sqrtPriceX96,</span>
 358 |     | <span class='unexecuted'>                    cache.liquidity,</span>
 359 |     | <span class='unexecuted'>                    cache.amount0Desired,</span>
 360 |     | <span class='unexecuted'>                    false</span>
 361 |     | <span class='neutral'>                );</span>
 362 |     | <span class='unexecuted'>            cache.tickUpper = floor(</span>
 363 |     | <span class='unexecuted'>                TickMath.getTickAtSqrtRatio(nextSqrtPrice0),</span>
 364 |     | <span class='unexecuted'>                tickSpacing</span>
 365 |     | <span class='neutral'>            );</span>
 366 |     | <span class='neutral'>        } else {</span>
 367 |     | <span class='unexecuted'>            uint160 nextSqrtPrice1 = SqrtPriceMath</span>
 368 |     | <span class='neutral'>                .getNextSqrtPriceFromAmount1RoundingDown(</span>
 369 |     | <span class='unexecuted'>                    sqrtPriceX96,</span>
 370 |     | <span class='unexecuted'>                    cache.liquidity,</span>
 371 |     | <span class='unexecuted'>                    cache.amount1Desired,</span>
 372 |     | <span class='unexecuted'>                    false</span>
 373 |     | <span class='neutral'>                );</span>
 374 |     | <span class='unexecuted'>            cache.tickLower = floor(</span>
 375 |     | <span class='unexecuted'>                TickMath.getTickAtSqrtRatio(nextSqrtPrice1),</span>
 376 |     | <span class='unexecuted'>                tickSpacing</span>
 377 |     | <span class='neutral'>            );</span>
 378 |     | <span class='neutral'>        }</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='unexecuted'>        checkRange(cache.tickLower, cache.tickUpper, tickSpacing);</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>        /// floor the tick again because one tick is still not valid tick due to + - baseThreshold</span>
 383 |     | <span class='unexecuted'>        tickLower = floor(cache.tickLower, tickSpacing);</span>
 384 |     | <span class='unexecuted'>        tickUpper = floor(cache.tickUpper, tickSpacing);</span>
 385 |     | <span class='neutral'>    }</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='neutral'>    /// @dev Gets amounts of token0 and token1 that can be stored in range of upper and lower ticks</span>
 388 |     | <span class='neutral'>    /// @param pool Uniswap V3 pool</span>
 389 |     | <span class='neutral'>    /// @param amount0Desired The desired amount of token0</span>
 390 |     | <span class='neutral'>    /// @param amount1Desired The desired amount of token1</span>
 391 |     | <span class='neutral'>    /// @param _tickLower The lower tick of the range</span>
 392 |     | <span class='neutral'>    /// @param _tickUpper The upper tick of the range</span>
 393 |     | <span class='neutral'>    /// @return amount0 amounts of token0 that can be stored in range</span>
 394 |     | <span class='neutral'>    /// @return amount1 amounts of token1 that can be stored in range</span>
 395 |     | <span class='unexecuted'>    function getAmountsForTicks(</span>
 396 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
 397 |     | <span class='neutral'>        uint256 amount0Desired,</span>
 398 |     | <span class='neutral'>        uint256 amount1Desired,</span>
 399 |     | <span class='neutral'>        int24 _tickLower,</span>
 400 |     | <span class='neutral'>        int24 _tickUpper</span>
 401 |     | <span class='unexecuted'>    ) internal view returns (uint256 amount0, uint256 amount1) {</span>
 402 |     | <span class='unexecuted'>        uint128 liquidity = getLiquidityForAmounts(</span>
 403 |     | <span class='unexecuted'>            pool,</span>
 404 |     | <span class='unexecuted'>            amount0Desired,</span>
 405 |     | <span class='unexecuted'>            amount1Desired,</span>
 406 |     | <span class='unexecuted'>            _tickLower,</span>
 407 |     | <span class='unexecuted'>            _tickUpper</span>
 408 |     | <span class='neutral'>        );</span>
 409 |     | <span class='neutral'></span>
 410 |     | <span class='unexecuted'>        (amount0, amount1) = getAmountsForLiquidity(</span>
 411 |     | <span class='unexecuted'>            pool,</span>
 412 |     | <span class='unexecuted'>            liquidity,</span>
 413 |     | <span class='unexecuted'>            _tickLower,</span>
 414 |     | <span class='unexecuted'>            _tickUpper</span>
 415 |     | <span class='neutral'>        );</span>
 416 |     | <span class='neutral'>    }</span>
 417 |     | <span class='neutral'></span>
 418 |     | <span class='neutral'>    /// @dev Common checks for valid tick inputs.</span>
 419 |     | <span class='neutral'>    /// @param tickLower The lower tick of the range</span>
 420 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the range</span>
 421 |     | <span class='neutral'>    /// @param tickSpacing The pool tick spacing</span>
 422 |     | <span class='unexecuted'>    function checkRange(</span>
 423 |     | <span class='neutral'>        int24 tickLower,</span>
 424 |     | <span class='neutral'>        int24 tickUpper,</span>
 425 |     | <span class='neutral'>        int24 tickSpacing</span>
 426 |     | <span class='neutral'>    ) internal pure {</span>
 427 |     | <span class='unexecuted'>        require(tickLower &lt; tickUpper, &quot;TLU&quot;);</span>
 428 |     | <span class='unexecuted'>        require(tickLower &gt;= TickMath.MIN_TICK, &quot;TLM&quot;);</span>
 429 |     | <span class='unexecuted'>        require(tickUpper &lt;= TickMath.MAX_TICK, &quot;TUM&quot;);</span>
 430 |     | <span class='unexecuted'>        require(tickLower % tickSpacing == 0, &quot;TLI&quot;);</span>
 431 |     | <span class='unexecuted'>        require(tickUpper % tickSpacing == 0, &quot;TUI&quot;);</span>
 432 |     | <span class='neutral'>    }</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='neutral'>    /// @dev Get imbalanced token</span>
 435 |     | <span class='neutral'>    /// @param amount0Desired The desired amount of token0</span>
 436 |     | <span class='neutral'>    /// @param amount1Desired The desired amount of token1</span>
 437 |     | <span class='neutral'>    /// @param amount0 Amounts of token0 that can be stored in base range</span>
 438 |     | <span class='neutral'>    /// @param amount1 Amounts of token1 that can be stored in base range</span>
 439 |     | <span class='neutral'>    /// @return zeroGreaterOne true if token0 is imbalanced. False if token1 is imbalanced</span>
 440 |     | <span class='unexecuted'>    function amountsDirection(</span>
 441 |     | <span class='neutral'>        uint256 amount0Desired,</span>
 442 |     | <span class='neutral'>        uint256 amount1Desired,</span>
 443 |     | <span class='neutral'>        uint256 amount0,</span>
 444 |     | <span class='neutral'>        uint256 amount1</span>
 445 |     | <span class='unexecuted'>    ) internal pure returns (bool zeroGreaterOne) {</span>
 446 |     | <span class='unexecuted'>        zeroGreaterOne = amount0Desired.sub(amount0).mul(amount1Desired) &gt;</span>
 447 |     | <span class='unexecuted'>            amount1Desired.sub(amount1).mul(amount0Desired)</span>
 448 |     | <span class='unexecuted'>            ? true</span>
 449 |     | <span class='unexecuted'>            : false;</span>
 450 |     | <span class='neutral'>    }</span>
 451 |     | <span class='neutral'>}</span>
 452 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/libraries/UniswapPoolActions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./SafeCastExtended.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./UniswapLiquidityManagement.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;../dependencies/interfaces/IUniswapV3Pool.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../dependencies/libraries/FullMath.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../dependencies/libraries/LowGasSafeMath.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @title Liquidity and ticks functions</span>
  12 |     | <span class='unexecuted'>/// @notice Provides functions for computing liquidity and ticks for token amounts and prices</span>
  13 |     | <span class='neutral'>library UniswapPoolActions {</span>
  14 |     | <span class='neutral'>    using LowGasSafeMath for uint256;</span>
  15 |     | <span class='neutral'>    using SafeCastExtended for uint256;</span>
  16 |     | <span class='neutral'>    using UniswapLiquidityManagement for IUniswapV3Pool;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    function updatePosition(</span>
  19 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
  20 |     | <span class='neutral'>        int24 tickLower,</span>
  21 |     | <span class='neutral'>        int24 tickUpper</span>
  22 |     | <span class='unexecuted'>    ) internal returns (uint128 liquidity) {</span>
  23 |     | <span class='unexecuted'>        (liquidity, , ) = pool.getPositionLiquidity(tickLower, tickUpper);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>        if (liquidity &gt; 0) {</span>
  26 |     | <span class='unexecuted'>            pool.burn(tickLower, tickUpper, 0);</span>
  27 |     | <span class='neutral'>        }</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    function burnLiquidity(</span>
  31 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
  32 |     | <span class='neutral'>        int24 tickLower,</span>
  33 |     | <span class='neutral'>        int24 tickUpper,</span>
  34 |     | <span class='neutral'>        address recipient</span>
  35 |     | <span class='neutral'>    )</span>
  36 |     | <span class='neutral'>        internal</span>
  37 |     | <span class='neutral'>        returns (</span>
  38 |     | <span class='unexecuted'>            uint256 amount0,</span>
  39 |     | <span class='unexecuted'>            uint256 amount1,</span>
  40 |     | <span class='unexecuted'>            uint256 fees0,</span>
  41 |     | <span class='unexecuted'>            uint256 fees1</span>
  42 |     | <span class='neutral'>        )</span>
  43 |     | <span class='neutral'>    {</span>
  44 |     | <span class='unexecuted'>        (uint128 liquidity, , ) = pool.getPositionLiquidity(</span>
  45 |     | <span class='unexecuted'>            tickLower,</span>
  46 |     | <span class='unexecuted'>            tickUpper</span>
  47 |     | <span class='neutral'>        );</span>
  48 |     | <span class='unexecuted'>        if (liquidity &gt; 0) {</span>
  49 |     | <span class='unexecuted'>            (amount0, amount1) = pool.burn(tickLower, tickUpper, liquidity);</span>
  50 |     | <span class='unexecuted'>            if (amount0 &gt; 0 || amount1 &gt; 0) {</span>
  51 |     | <span class='unexecuted'>                (uint256 collect0, uint256 collect1) = pool.collect(</span>
  52 |     | <span class='unexecuted'>                    recipient,</span>
  53 |     | <span class='unexecuted'>                    tickLower,</span>
  54 |     | <span class='unexecuted'>                    tickUpper,</span>
  55 |     | <span class='unexecuted'>                    type(uint128).max,</span>
  56 |     | <span class='unexecuted'>                    type(uint128).max</span>
  57 |     | <span class='neutral'>                );</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>                (fees0, fees1) = (collect0.sub(amount0), collect1.sub(amount1));</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='neutral'>        }</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function burnUserLiquidity(</span>
  65 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
  66 |     | <span class='neutral'>        int24 tickLower,</span>
  67 |     | <span class='neutral'>        int24 tickUpper,</span>
  68 |     | <span class='neutral'>        uint256 userSharePercentage,</span>
  69 |     | <span class='neutral'>        address recipient</span>
  70 |     | <span class='unexecuted'>    ) internal returns (uint256 amount0, uint256 amount1) {</span>
  71 |     | <span class='unexecuted'>        (uint128 liquidity, , ) = pool.getPositionLiquidity(</span>
  72 |     | <span class='unexecuted'>            tickLower,</span>
  73 |     | <span class='unexecuted'>            tickUpper</span>
  74 |     | <span class='neutral'>        );</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        uint256 liquidityRemoved = FullMath.mulDiv(</span>
  77 |     | <span class='unexecuted'>            uint256(liquidity),</span>
  78 |     | <span class='unexecuted'>            userSharePercentage,</span>
  79 |     | <span class='unexecuted'>            1e18</span>
  80 |     | <span class='neutral'>        );</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        (amount0, amount1) = pool.burn(</span>
  83 |     | <span class='unexecuted'>            tickLower,</span>
  84 |     | <span class='unexecuted'>            tickUpper,</span>
  85 |     | <span class='unexecuted'>            liquidityRemoved.toUint128()</span>
  86 |     | <span class='neutral'>        );</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        if (amount0 &gt; 0 || amount1 &gt; 0) {</span>
  89 |     | <span class='unexecuted'>            (amount0, amount0) = pool.collect(</span>
  90 |     | <span class='unexecuted'>                recipient,</span>
  91 |     | <span class='unexecuted'>                tickLower,</span>
  92 |     | <span class='unexecuted'>                tickUpper,</span>
  93 |     | <span class='unexecuted'>                amount0.toUint128(),</span>
  94 |     | <span class='unexecuted'>                amount1.toUint128()</span>
  95 |     | <span class='neutral'>            );</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function mintLiquidity(</span>
 100 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
 101 |     | <span class='neutral'>        int24 tickLower,</span>
 102 |     | <span class='neutral'>        int24 tickUpper,</span>
 103 |     | <span class='neutral'>        uint256 amount0Desired,</span>
 104 |     | <span class='neutral'>        uint256 amount1Desired</span>
 105 |     | <span class='unexecuted'>    ) internal returns (uint256 amount0, uint256 amount1) {</span>
 106 |     | <span class='unexecuted'>        uint128 liquidity = pool.getLiquidityForAmounts(</span>
 107 |     | <span class='unexecuted'>            amount0Desired,</span>
 108 |     | <span class='unexecuted'>            amount1Desired,</span>
 109 |     | <span class='unexecuted'>            tickLower,</span>
 110 |     | <span class='unexecuted'>            tickUpper</span>
 111 |     | <span class='neutral'>        );</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        if (liquidity &gt; 0) {</span>
 114 |     | <span class='unexecuted'>            (amount0, amount1) = pool.mint(</span>
 115 |     | <span class='unexecuted'>                address(this),</span>
 116 |     | <span class='unexecuted'>                tickLower,</span>
 117 |     | <span class='unexecuted'>                tickUpper,</span>
 118 |     | <span class='unexecuted'>                liquidity,</span>
 119 |     | <span class='unexecuted'>                abi.encode(address(this))</span>
 120 |     | <span class='neutral'>            );</span>
 121 |     | <span class='neutral'>        }</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>    function swapToken(</span>
 125 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
 126 |     | <span class='neutral'>        address recipient,</span>
 127 |     | <span class='neutral'>        bool zeroForOne,</span>
 128 |     | <span class='neutral'>        int256 amountSpecified</span>
 129 |     | <span class='neutral'>    ) internal {</span>
 130 |     | <span class='unexecuted'>        (uint160 sqrtPriceX96, , ) = pool.getSqrtRatioX96AndTick();</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>        uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (1e5 / 2)) / 1e6;</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        uint160 sqrtPriceLimitX96 = zeroForOne</span>
 135 |     | <span class='unexecuted'>            ? sqrtPriceX96 - exactSqrtPriceImpact</span>
 136 |     | <span class='unexecuted'>            : sqrtPriceX96 + exactSqrtPriceImpact;</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>        pool.swap(</span>
 139 |     | <span class='unexecuted'>            recipient,</span>
 140 |     | <span class='unexecuted'>            zeroForOne,</span>
 141 |     | <span class='unexecuted'>            amountSpecified,</span>
 142 |     | <span class='unexecuted'>            sqrtPriceLimitX96,</span>
 143 |     | <span class='unexecuted'>            abi.encode(zeroForOne)</span>
 144 |     | <span class='neutral'>        );</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>    function collectPendingFees(</span>
 148 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
 149 |     | <span class='neutral'>        address recipient,</span>
 150 |     | <span class='neutral'>        int24 tickLower,</span>
 151 |     | <span class='neutral'>        int24 tickUpper</span>
 152 |     | <span class='unexecuted'>    ) internal returns (uint256 collect0, uint256 collect1) {</span>
 153 |     | <span class='unexecuted'>        updatePosition(pool, tickLower, tickUpper);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>        (collect0, collect1) = pool.collect(</span>
 156 |     | <span class='unexecuted'>            recipient,</span>
 157 |     | <span class='unexecuted'>            tickLower,</span>
 158 |     | <span class='unexecuted'>            tickUpper,</span>
 159 |     | <span class='unexecuted'>            type(uint128).max,</span>
 160 |     | <span class='unexecuted'>            type(uint128).max</span>
 161 |     | <span class='neutral'>        );</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function rerangeLiquidity(</span>
 165 |     | <span class='neutral'>        IUniswapV3Pool pool,</span>
 166 |     | <span class='neutral'>        int24 baseThreshold,</span>
 167 |     | <span class='neutral'>        int24 tickSpacing,</span>
 168 |     | <span class='neutral'>        uint256 balance0,</span>
 169 |     | <span class='neutral'>        uint256 balance1</span>
 170 |     | <span class='neutral'>    ) internal returns (int24 tickLower, int24 tickUpper) {</span>
 171 |     | <span class='neutral'>        (tickLower, tickUpper) = pool.getPositionTicks(</span>
 172 |     | <span class='neutral'>            balance0,</span>
 173 |     | <span class='neutral'>            balance1,</span>
 174 |     | <span class='neutral'>            baseThreshold,</span>
 175 |     | <span class='neutral'>            tickSpacing</span>
 176 |     | <span class='neutral'>        );</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>        mintLiquidity(pool, tickLower, tickUpper, balance0, balance1);</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'>}</span>
 181 |     | <span class='neutral'></span>

</code>
<br />

