/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/UnipilotActiveFactory.sol
   1 | *r  | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.7.6;
   3 |     | 
   4 |     | import {UnipilotActiveVault} from "./UnipilotActiveVault.sol";
   5 |     | import "./interfaces/IUnipilotFactory.sol";
   6 |     | import "./dependencies/interfaces/IUniswapV3Factory.sol";
   7 |     | import "./dependencies/interfaces/IUniswapV3Pool.sol";
   8 |     | 
   9 |     | /// @title Unipilot Active Factory
  10 |     | /// @author 0xMudassir & 721Orbit
  11 |     | /// @notice Deploys Unipilot active vaults and manages ownership and control over all active vaults
  12 |     | /// active liquidity managament strategy will be used in these vaults
  13 | *r  | /// all active vaults will be managed by Unipilot Captains
  14 |     | contract UnipilotActiveFactory is IUnipilotFactory {
  15 |     |     address private admin;
  16 |     |     address private strategy;
  17 |     |     address private indexFund;
  18 |     |     address private WETH;
  19 |     |     uint8 private swapPercentage;
  20 |     |     uint8 private indexFundPercentage;
  21 |     |     IUniswapV3Factory private uniswapFactory;
  22 |     | 
  23 |     |     constructor(
  24 |     |         address _uniswapFactory,
  25 |     |         address _admin,
  26 |     |         address _uniStrategy,
  27 |     |         address _indexFund,
  28 |     |         address _WETH,
  29 |     |         uint8 percentage
  30 |     |     ) {
  31 |     |         admin = _admin;
  32 |     |         strategy = _uniStrategy;
  33 |     |         uniswapFactory = IUniswapV3Factory(_uniswapFactory);
  34 |     |         indexFund = _indexFund;
  35 |     |         WETH = _WETH;
  36 |     |         indexFundPercentage = percentage;
  37 |     |     }
  38 |     | 
  39 | *   |     mapping(address => mapping(address => mapping(uint24 => mapping(uint16 => address))))
  40 |     |         public vaults;
  41 |     | 
  42 |     |     modifier onlyadmin() {
  43 | r   |         require(msg.sender == admin);
  44 |     |         _;
  45 |     |     }
  46 |     | 
  47 |     |     /// @inheritdoc IUnipilotFactory
  48 | *   |     function getUnipilotDetails()
  49 |     |         external
  50 |     |         view
  51 |     |         override
  52 |     |         returns (
  53 | *   |             address,
  54 | *   |             address,
  55 | *   |             address,
  56 | *   |             uint8,
  57 | *   |             uint8
  58 |     |         )
  59 |     |     {
  60 | *   |         return (
  61 | *   |             admin,
  62 | *   |             strategy,
  63 | *   |             indexFund,
  64 | *   |             indexFundPercentage,
  65 | *   |             swapPercentage
  66 |     |         );
  67 |     |     }
  68 |     | 
  69 |     |     /// @inheritdoc IUnipilotFactory
  70 | r   |     function createVault(
  71 |     |         address _tokenA,
  72 |     |         address _tokenB,
  73 |     |         uint24 _fee,
  74 |     |         uint16 _vaultStrategy,
  75 |     |         uint160 _sqrtPriceX96,
  76 |     |         string memory _name,
  77 |     |         string memory _symbol
  78 | r   |     ) external override onlyadmin returns (address _vault) {
  79 | r   |         require(_tokenA != _tokenB);
  80 |     | 
  81 | r   |         (address token0, address token1) = _tokenA < _tokenB
  82 | r   |             ? (_tokenA, _tokenB)
  83 | r   |             : (_tokenB, _tokenA);
  84 |     | 
  85 | r   |         address pool = uniswapFactory.getPool(token0, token1, _fee);
  86 |     | 
  87 | r   |         if (pool != address(0)) {
  88 |     |             require(vaults[token0][token1][_fee][0] == address(0));
  89 |     |         } else {
  90 | r   |             pool = uniswapFactory.createPool(token0, token1, _fee);
  91 | r   |             IUniswapV3Pool(pool).initialize(_sqrtPriceX96);
  92 |     |         }
  93 |     | 
  94 |     |         _vault = address(
  95 | r   |             new UnipilotActiveVault{
  96 | r   |                 salt: keccak256(abi.encodePacked(_tokenA, _tokenB, _fee))
  97 | r   |             }(pool, address(this), WETH, _vaultStrategy, _name, _symbol)
  98 |     |         );
  99 |     | 
 100 |     |         vaults[token0][token1][_fee][_vaultStrategy] = _vault;
 101 |     |         vaults[token1][token0][_fee][_vaultStrategy] = _vault; // populate mapping in the reverse direction
 102 |     |         emit VaultCreated(token0, token1, _vaultStrategy, _fee, _vault);
 103 |     |     }
 104 |     | 
 105 |     |     /// @notice Updates the admin of the Unipilot factory
 106 |     |     /// @dev Must be called by the current admin
 107 |     |     /// @param _newadmin The new admin of the Unipilot factory
 108 | r   |     function setadmin(address _newadmin) external onlyadmin {
 109 |     |         require(_newadmin != address(0));
 110 |     |        // emit adminChanged(admin, _newadmin);
 111 |     |         admin = _newadmin;
 112 |     |     }
 113 |     | 
 114 |     |     /// @notice Updates all the necessary Unipilot details used in active vaults
 115 |     |     /// @dev Must be called by the current admin
 116 |     |     /// @param _strategy Unipilot strategy address
 117 |     |     /// @param _indexFund Unipilot index fund account
 118 |     |     /// @param _indexFundPercentage Percentage of fees for index fund
 119 | r   |     function setUnipilotDetails(
 120 |     |         address _strategy,
 121 |     |         address _indexFund,
 122 |     |         uint8 _indexFundPercentage
 123 |     |     ) external onlyadmin {
 124 |     |         require(_indexFundPercentage > 0 && _indexFundPercentage < 100);
 125 |     |         strategy = _strategy;
 126 |     |         indexFund = _indexFund;
 127 |     |         indexFundPercentage = _indexFundPercentage;
 128 |     |     }
 129 |     | }
 130 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/UnipilotActiveVault.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.7.6;
   3 |     | pragma abicoder v2;
   4 |     | 
   5 |     | import {ERC20Permit, IERC20, ERC20, TransferHelper} from "./libraries/TransferHelper.sol";
   6 |     | import "./interfaces/external/IWETH9.sol";
   7 |     | import "./interfaces/IUnipilotVault.sol";
   8 |     | import "./interfaces/IUnipilotStrategy.sol";
   9 |     | import "./interfaces/IUnipilotFactory.sol";
  10 |     | import "./libraries/UniswapLiquidityManagement.sol";
  11 |     | import "./libraries/SafeCastExtended.sol";
  12 |     | import "./libraries/UniswapPoolActions.sol";
  13 |     | 
  14 |     | /// @title Unipilot Active Vault
  15 |     | /// @author 0xMudassir & 721Orbit
  16 |     | /// @dev Active liquidity managment contract that handles user liquidity of any Uniswap V3 pool & earn fees for them
  17 |     | /// @dev minimalist, and gas-optimized contract that ensures user liquidity is always
  18 |     | /// in range and earns maximum amount of fees available at current liquidity utilization
  19 |     | /// rate.
  20 |     | /// @dev In order to minimize IL for users contract pulls liquidity to the vault (HODL) when necessary
  21 |     | contract UnipilotActiveVault is ERC20Permit, IUnipilotVault {
  22 |     |     using SafeCastExtended for uint256;
  23 |     |     using LowGasSafeMath for uint256;
  24 |     |     using UniswapPoolActions for IUniswapV3Pool;
  25 |     |     using UniswapLiquidityManagement for IUniswapV3Pool;
  26 |     | 
  27 |     |     IERC20 private token0;
  28 |     |     IERC20 private token1;
  29 |     |     uint24 private fee;
  30 |     |     int24 private tickSpacing;
  31 |     | 
  32 |     |     TicksData public ticksData;
  33 |     |     IUniswapV3Pool private pool;
  34 |     |     IUnipilotFactory private unipilotFactory;
  35 |     |     uint256 internal constant MIN_INITIAL_SHARES = 1e3;
  36 |     | 
  37 |     |     address private WETH;
  38 |     |     uint16 private _strategyType;
  39 |     |     uint32 private _pulled = 1;
  40 |     |     uint32 private _unlocked = 1;
  41 |     | 
  42 |     |     mapping(address => bool) private _operatorApproved;
  43 |     | 
  44 |     |     modifier onlyGovernance() {
  45 |     |         (address governance, , , , ) = getProtocolDetails();
  46 |     |         require(msg.sender == governance);
  47 |     |         _;
  48 |     |     }
  49 |     | 
  50 |     |     modifier onlyOperator() {
  51 |     |         require(_operatorApproved[msg.sender]);
  52 |     |         _;
  53 |     |     }
  54 |     | 
  55 |     |     modifier nonReentrant() {
  56 |     |         require(_unlocked == 1);
  57 |     |         _unlocked = 2;
  58 |     |         _;
  59 |     |         _unlocked = 1;
  60 |     |     }
  61 |     | 
  62 |     |     modifier checkDeviation() {
  63 |     |         (, address strategy, , , ) = getProtocolDetails();
  64 |     |         IUnipilotStrategy(strategy).checkDeviation(address(pool));
  65 |     |         _;
  66 |     |     }
  67 |     | 
  68 |     |     constructor(
  69 |     |         address _pool,
  70 |     |         address _unipilotFactory,
  71 |     |         address _WETH,
  72 |     |         uint16 _strategytype,
  73 |     |         string memory _name,
  74 |     |         string memory _symbol
  75 |     |     ) ERC20Permit(_name) ERC20(_name, _symbol) {
  76 |     |         require(_pool != address(0));
  77 |     |         require(_WETH != address(0));
  78 |     |         require(_unipilotFactory != address(0));
  79 |     | 
  80 |     |         pool = IUniswapV3Pool(_pool);
  81 |     |         unipilotFactory = IUnipilotFactory(_unipilotFactory);
  82 |     |         WETH = _WETH;
  83 |     |         token0 = IERC20(pool.token0());
  84 |     |         token1 = IERC20(pool.token1());
  85 |     |         fee = pool.fee();
  86 |     |         tickSpacing = pool.tickSpacing();
  87 |     |         _strategyType = _strategytype;
  88 |     |     }
  89 |     | 
  90 |     |     receive() external payable {}
  91 |     | 
  92 |     |     fallback() external payable {}
  93 |     | 
  94 |     |     /// @inheritdoc IUnipilotVault
  95 |     |     function deposit(
  96 |     |         uint256 amount0Desired,
  97 |     |         uint256 amount1Desired,
  98 |     |         address recipient
  99 |     |     )
 100 |     |         external
 101 |     |         payable
 102 |     |         override
 103 |     |         nonReentrant
 104 |     |         checkDeviation
 105 |     |         returns (
 106 |     |             uint256 lpShares,
 107 |     |             uint256 amount0,
 108 |     |             uint256 amount1
 109 |     |         )
 110 |     |     {
 111 |     |         require(recipient != address(0));
 112 |     |         require(amount0Desired > 0 && amount1Desired > 0);
 113 |     | 
 114 |     |         address sender = _msgSender();
 115 |     |         uint256 totalSupply = totalSupply();
 116 |     | 
 117 |     |         (lpShares, amount0, amount1) = pool.computeLpShares(
 118 |     |             true,
 119 |     |             amount0Desired,
 120 |     |             amount1Desired,
 121 |     |             _balance0(),
 122 |     |             _balance1(),
 123 |     |             totalSupply,
 124 |     |             ticksData
 125 |     |         );
 126 |     | 
 127 |     |         if (totalSupply == 0) {
 128 |     |             // prevent first LP from stealing funds of subsequent LPs
 129 |     |             // see https://code4rena.com/reports/2022-01-sherlock/#h-01-first-user-can-steal-everyone-elses-tokens
 130 |     |             require(lpShares > MIN_INITIAL_SHARES, "ML");
 131 |     |         }
 132 |     | 
 133 |     |         require(lpShares != 0, "IS");
 134 |     | 
 135 |     |         pay(address(token0), sender, address(this), amount0);
 136 |     |         pay(address(token1), sender, address(this), amount1);
 137 |     | 
 138 |     |         if (_pulled == 1) {
 139 |     |             pool.mintLiquidity(
 140 |     |                 ticksData.baseTickLower,
 141 |     |                 ticksData.baseTickUpper,
 142 |     |                 amount0,
 143 |     |                 amount1
 144 |     |             );
 145 |     |         }
 146 |     | 
 147 |     |         if (address(this).balance > 0)
 148 |     |             TransferHelper.safeTransferETH(sender, address(this).balance);
 149 |     | 
 150 |     |         _mint(recipient, lpShares);
 151 |     |         emit Deposit(sender, recipient, amount0, amount1, lpShares);
 152 |     |     }
 153 |     | 
 154 |     |     /// @inheritdoc IUnipilotVault
 155 |     |     function withdraw(
 156 |     |         uint256 liquidity,
 157 |     |         address recipient,
 158 |     |         bool refundAsETH
 159 |     |     )
 160 |     |         external
 161 |     |         override
 162 |     |         nonReentrant
 163 |     |         checkDeviation
 164 |     |         returns (uint256 amount0, uint256 amount1)
 165 |     |     {
 166 |     |         require(liquidity > 0);
 167 |     |         uint256 totalSupply = totalSupply();
 168 |     | 
 169 |     |         /// @dev if liquidity has pulled in contract then calculate share accordingly
 170 |     |         if (_pulled == 1) {
 171 |     |             uint256 liquidityShare = FullMath.mulDiv(
 172 |     |                 liquidity,
 173 |     |                 1e18,
 174 |     |                 totalSupply
 175 |     |             );
 176 |     | 
 177 |     |             (amount0, amount1) = pool.burnUserLiquidity(
 178 |     |                 ticksData.baseTickLower,
 179 |     |                 ticksData.baseTickUpper,
 180 |     |                 liquidityShare,
 181 |     |                 address(this)
 182 |     |             );
 183 |     | 
 184 |     |             (uint256 fees0, uint256 fees1) = pool.collectPendingFees(
 185 |     |                 address(this),
 186 |     |                 ticksData.baseTickLower,
 187 |     |                 ticksData.baseTickUpper
 188 |     |             );
 189 |     | 
 190 |     |             transferFeesToIF(false, fees0, fees1);
 191 |     |         }
 192 |     | 
 193 |     |         uint256 unusedAmount0 = FullMath.mulDiv(
 194 |     |             _balance0().sub(amount0),
 195 |     |             liquidity,
 196 |     |             totalSupply
 197 |     |         );
 198 |     | 
 199 |     |         uint256 unusedAmount1 = FullMath.mulDiv(
 200 |     |             _balance1().sub(amount1),
 201 |     |             liquidity,
 202 |     |             totalSupply
 203 |     |         );
 204 |     | 
 205 |     |         amount0 = amount0.add(unusedAmount0);
 206 |     |         amount1 = amount1.add(unusedAmount1);
 207 |     | 
 208 |     |         if (amount0 > 0) {
 209 |     |             transferFunds(refundAsETH, recipient, address(token0), amount0);
 210 |     |         }
 211 |     | 
 212 |     |         if (amount1 > 0) {
 213 |     |             transferFunds(refundAsETH, recipient, address(token1), amount1);
 214 |     |         }
 215 |     | 
 216 |     |         _burn(msg.sender, liquidity);
 217 |     |         emit Withdraw(recipient, liquidity, amount0, amount1);
 218 |     | 
 219 |     |         if (_pulled == 1) {
 220 |     |             (uint256 c0, uint256 c1) = pool.mintLiquidity(
 221 |     |                 ticksData.baseTickLower,
 222 |     |                 ticksData.baseTickUpper,
 223 |     |                 _balance0(),
 224 |     |                 _balance1()
 225 |     |             );
 226 |     | 
 227 |     |             emit CompoundFees(c0, c1);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     /// @inheritdoc IUnipilotVault
 232 |     |     function readjustLiquidity(uint8 swapBP)
 233 |     |         external
 234 |     |         override
 235 |     |         onlyOperator
 236 |     |         checkDeviation
 237 |     |     {
 238 |     |         _pulled = 1;
 239 |     |         ReadjustVars memory a;
 240 |     | 
 241 |     |         (uint128 totalLiquidity, , ) = pool.getPositionLiquidity(
 242 |     |             ticksData.baseTickLower,
 243 |     |             ticksData.baseTickUpper
 244 |     |         );
 245 |     | 
 246 |     |         (a.amount0Desired, a.amount1Desired, a.fees0, a.fees1) = pool
 247 |     |             .burnLiquidity(
 248 |     |                 ticksData.baseTickLower,
 249 |     |                 ticksData.baseTickUpper,
 250 |     |                 address(this)
 251 |     |             );
 252 |     | 
 253 |     |         transferFeesToIF(true, a.fees0, a.fees1);
 254 |     | 
 255 |     |         int24 baseThreshold = tickSpacing * getBaseThreshold();
 256 |     |         (, a.currentTick, ) = pool.getSqrtRatioX96AndTick();
 257 |     | 
 258 |     |         (a.tickLower, a.tickUpper) = UniswapLiquidityManagement.getBaseTicks(
 259 |     |             a.currentTick,
 260 |     |             baseThreshold,
 261 |     |             tickSpacing
 262 |     |         );
 263 |     | 
 264 |     |         if (
 265 |     |             (totalLiquidity > 0) &&
 266 |     |             (a.amount0Desired == 0 || a.amount1Desired == 0)
 267 |     |         ) {
 268 |     |             bool zeroForOne = a.amount0Desired > 0 ? true : false;
 269 |     | 
 270 |     |             int256 amountSpecified = zeroForOne
 271 |     |                 ? FullMath.mulDiv(a.amount0Desired, swapBP, 100).toInt256()
 272 |     |                 : FullMath.mulDiv(a.amount1Desired, swapBP, 100).toInt256();
 273 |     | 
 274 |     |             pool.swapToken(address(this), zeroForOne, amountSpecified);
 275 |     |         } else {
 276 |     |             a.amount0Desired = _balance0();
 277 |     |             a.amount1Desired = _balance1();
 278 |     | 
 279 |     |             a.liquidity = pool.getLiquidityForAmounts(
 280 |     |                 a.amount0Desired,
 281 |     |                 a.amount1Desired,
 282 |     |                 a.tickLower,
 283 |     |                 a.tickUpper
 284 |     |             );
 285 |     | 
 286 |     |             (a.amount0, a.amount1) = pool.getAmountsForLiquidity(
 287 |     |                 a.liquidity,
 288 |     |                 a.tickLower,
 289 |     |                 a.tickUpper
 290 |     |             );
 291 |     | 
 292 |     |             a.zeroForOne = UniswapLiquidityManagement.amountsDirection(
 293 |     |                 a.amount0Desired,
 294 |     |                 a.amount1Desired,
 295 |     |                 a.amount0,
 296 |     |                 a.amount1
 297 |     |             );
 298 |     | 
 299 |     |             a.amountSpecified = a.zeroForOne
 300 |     |                 ? int256(
 301 |     |                     FullMath.mulDiv(
 302 |     |                         a.amount0Desired.sub(a.amount0),
 303 |     |                         swapBP,
 304 |     |                         100
 305 |     |                     )
 306 |     |                 )
 307 |     |                 : int256(
 308 |     |                     FullMath.mulDiv(
 309 |     |                         a.amount1Desired.sub(a.amount1),
 310 |     |                         swapBP,
 311 |     |                         100
 312 |     |                     )
 313 |     |                 );
 314 |     | 
 315 |     |             pool.swapToken(address(this), a.zeroForOne, a.amountSpecified);
 316 |     |         }
 317 |     | 
 318 |     |         a.amount0Desired = _balance0();
 319 |     |         a.amount1Desired = _balance1();
 320 |     | 
 321 |     |         (ticksData.baseTickLower, ticksData.baseTickUpper) = pool
 322 |     |             .getPositionTicks(
 323 |     |                 a.amount0Desired,
 324 |     |                 a.amount1Desired,
 325 |     |                 baseThreshold,
 326 |     |                 tickSpacing
 327 |     |             );
 328 |     | 
 329 |     |         pool.mintLiquidity(
 330 |     |             ticksData.baseTickLower,
 331 |     |             ticksData.baseTickUpper,
 332 |     |             a.amount0Desired,
 333 |     |             a.amount1Desired
 334 |     |         );
 335 |     |     }
 336 |     | 
 337 |     |     function rebalance(
 338 |     |         int256 swapAmount,
 339 |     |         bool zeroForOne,
 340 |     |         int24 tickLower,
 341 |     |         int24 tickUpper
 342 |     |     ) external onlyOperator checkDeviation {
 343 |     |         _pulled = 1;
 344 |     |         UniswapLiquidityManagement.checkRange(
 345 |     |             tickLower,
 346 |     |             tickUpper,
 347 |     |             tickSpacing
 348 |     |         );
 349 |     | 
 350 |     |         // Withdraw all current liquidity from Uniswap pool & transfer fees
 351 |     |         (, , uint256 fees0, uint256 fees1) = pool.burnLiquidity(
 352 |     |             ticksData.baseTickLower,
 353 |     |             ticksData.baseTickUpper,
 354 |     |             address(this)
 355 |     |         );
 356 |     | 
 357 |     |         transferFeesToIF(true, fees0, fees1);
 358 |     | 
 359 |     |         if (swapAmount != 0)
 360 |     |             pool.swapToken(address(this), zeroForOne, swapAmount);
 361 |     | 
 362 |     |         pool.mintLiquidity(tickLower, tickUpper, _balance0(), _balance1());
 363 |     | 
 364 |     |         (ticksData.baseTickLower, ticksData.baseTickUpper) = (
 365 |     |             tickLower,
 366 |     |             tickUpper
 367 |     |         );
 368 |     |     }
 369 |     | 
 370 |     |     /// @inheritdoc IUnipilotVault
 371 |     |     function uniswapV3MintCallback(
 372 |     |         uint256 amount0Owed,
 373 |     |         uint256 amount1Owed,
 374 |     |         bytes calldata data
 375 |     |     ) external override {
 376 |     |         _verifyCallback();
 377 |     |         address recipient = _msgSender();
 378 |     |         address payer = abi.decode(data, (address));
 379 |     | 
 380 |     |         if (amount0Owed > 0)
 381 |     |             TransferHelper.safeTransfer(
 382 |     |                 address(token0),
 383 |     |                 recipient,
 384 |     |                 amount0Owed
 385 |     |             );
 386 |     | 
 387 |     |         if (amount1Owed > 0)
 388 |     |             TransferHelper.safeTransfer(
 389 |     |                 address(token1),
 390 |     |                 recipient,
 391 |     |                 amount1Owed
 392 |     |             );
 393 |     |     }
 394 |     | 
 395 |     |     /// @inheritdoc IUnipilotVault
 396 |     |     function uniswapV3SwapCallback(
 397 |     |         int256 amount0,
 398 |     |         int256 amount1,
 399 |     |         bytes calldata data
 400 |     |     ) external override {
 401 |     |         _verifyCallback();
 402 |     | 
 403 |     |         require(amount0 > 0 || amount1 > 0);
 404 |     |         bool zeroForOne = abi.decode(data, (bool));
 405 |     | 
 406 |     |         if (zeroForOne)
 407 |     |             TransferHelper.safeTransfer(
 408 |     |                 address(token0),
 409 |     |                 _msgSender(),
 410 |     |                 uint256(amount0)
 411 |     |             );
 412 |     |         else
 413 |     |             TransferHelper.safeTransfer(
 414 |     |                 address(token1),
 415 |     |                 _msgSender(),
 416 |     |                 uint256(amount1)
 417 |     |             );
 418 |     |     }
 419 |     | 
 420 |     |     /// @dev Burns all the Unipilot position and HODL in the vault to prevent users from huge IL
 421 |     |     /// Only called by the selected operators
 422 |     |     /// @dev Users can also deposit/withdraw during HODL period.
 423 |     |     function pullLiquidity() external onlyOperator {
 424 |     |         (
 425 |     |             uint256 reserves0,
 426 |     |             uint256 reserves1,
 427 |     |             uint256 fees0,
 428 |     |             uint256 fees1
 429 |     |         ) = pool.burnLiquidity(
 430 |     |                 ticksData.baseTickLower,
 431 |     |                 ticksData.baseTickUpper,
 432 |     |                 address(this)
 433 |     |             );
 434 |     | 
 435 |     |         _pulled = 2;
 436 |     |         emit PullLiquidity(reserves0, reserves1, fees0, fees1);
 437 |     |     }
 438 |     | 
 439 |     |     /// @notice Calculates the vault's total holdings of TOKEN0 and TOKEN1 - in
 440 |     |     /// other words, how much of each token the vault would hold if it withdrew
 441 |     |     /// all its liquidity from Uniswap.
 442 |     |     /// @dev Updates the position and return the updated reserves, fees & liquidity.
 443 |     |     /// @return amount0 Amount of token0 in the unipilot vault
 444 |     |     /// @return amount1 Amount of token1 in the unipilot vault
 445 |     |     /// @return fees0 Total amount of fees collected by unipilot position in terms of token0
 446 |     |     /// @return fees1 Total amount of fees collected by unipilot position in terms of token1
 447 |     |     /// @return baseLiquidity The total liquidity of the base position
 448 |     |     /// @return rangeLiquidity The total liquidity of the range position - N/A for active vault
 449 |     |     function getPositionDetails()
 450 |     |         external
 451 |     |         returns (
 452 |     |             uint256 amount0,
 453 |     |             uint256 amount1,
 454 |     |             uint256 fees0,
 455 |     |             uint256 fees1,
 456 |     |             uint128 baseLiquidity,
 457 |     |             uint128 rangeLiquidity
 458 |     |         )
 459 |     |     {
 460 |     |         return pool.getTotalAmounts(true, ticksData);
 461 |     |     }
 462 |     | 
 463 |     |     /// @notice Updates the status of given account as operator
 464 |     |     /// @dev Must be called by the current governance
 465 |     |     /// @param _operator Account to update status
 466 |     |     function toggleOperator(address _operator) external onlyGovernance {
 467 |     |         _operatorApproved[_operator] = !_operatorApproved[_operator];
 468 |     |     }
 469 |     | 
 470 |     |     /// @notice Returns the status for a given operator that can operate readjust & pull liquidity
 471 |     |     function isOperator(address _operator) external view returns (bool) {
 472 |     |         return _operatorApproved[_operator];
 473 |     |     }
 474 |     | 
 475 |     |     /// @notice Returns unipilot vault details
 476 |     |     /// @return The first of the two tokens of the pool, sorted by address
 477 |     |     /// @return The second of the two tokens of the pool, sorted by address
 478 |     |     /// @return The pool's fee in hundredths of a bip, i.e. 1e-6
 479 |     |     /// @return The address of the Uniswap V3 Pool
 480 |     |     function getVaultInfo()
 481 |     |         external
 482 |     |         view
 483 |     |         returns (
 484 |     |             address,
 485 |     |             address,
 486 |     |             uint24,
 487 |     |             address
 488 |     |         )
 489 |     |     {
 490 |     |         return (address(token0), address(token1), fee, address(pool));
 491 |     |     }
 492 |     | 
 493 |     |     /// @dev Amount of token0 held as unused balance.
 494 |     |     function _balance0() internal view returns (uint256) {
 495 |     |         return token0.balanceOf(address(this));
 496 |     |     }
 497 |     | 
 498 |     |     /// @dev Amount of token1 held as unused balance.
 499 |     |     function _balance1() internal view returns (uint256) {
 500 |     |         return token1.balanceOf(address(this));
 501 |     |     }
 502 |     | 
 503 |     |     /// @notice Verify that caller should be the address of a valid Uniswap V3 Pool
 504 |     |     function _verifyCallback() internal view {
 505 |     |         require(msg.sender == address(pool));
 506 |     |     }
 507 |     | 
 508 |     |     function getBaseThreshold() internal view returns (int24 baseThreshold) {
 509 |     |         (, address strategy, , , ) = getProtocolDetails();
 510 |     |         return
 511 |     |             IUnipilotStrategy(strategy).getBaseThreshold(
 512 |     |                 address(pool),
 513 |     |                 _strategyType
 514 |     |             );
 515 |     |     }
 516 |     | 
 517 |     |     function getProtocolDetails()
 518 |     |         internal
 519 |     |         view
 520 |     |         returns (
 521 |     |             address governance,
 522 |     |             address strategy,
 523 |     |             address indexFund,
 524 |     |             uint8 indexFundPercentage,
 525 |     |             uint8 swapPercentage
 526 |     |         )
 527 |     |     {
 528 |     |         return unipilotFactory.getUnipilotDetails();
 529 |     |     }
 530 |     | 
 531 |     |     /// @dev method to transfer unipilot earned fees to Index Fund
 532 |     |     function transferFeesToIF(
 533 |     |         bool isReadjustLiquidity,
 534 |     |         uint256 fees0,
 535 |     |         uint256 fees1
 536 |     |     ) internal {
 537 |     |         (, , address indexFund, uint8 percentage, ) = getProtocolDetails();
 538 |     | 
 539 |     |         if (percentage > 0) {
 540 |     |             if (fees0 > 0)
 541 |     |                 TransferHelper.safeTransfer(
 542 |     |                     address(token0),
 543 |     |                     indexFund,
 544 |     |                     FullMath.mulDiv(fees0, percentage, 100)
 545 |     |                 );
 546 |     | 
 547 |     |             if (fees1 > 0)
 548 |     |                 TransferHelper.safeTransfer(
 549 |     |                     address(token1),
 550 |     |                     indexFund,
 551 |     |                     FullMath.mulDiv(fees1, percentage, 100)
 552 |     |                 );
 553 |     | 
 554 |     |             emit FeesSnapshot(isReadjustLiquidity, fees0, fees1);
 555 |     |         }
 556 |     |     }
 557 |     | 
 558 |     |     function transferFunds(
 559 |     |         bool refundAsETH,
 560 |     |         address recipient,
 561 |     |         address token,
 562 |     |         uint256 amount
 563 |     |     ) internal {
 564 |     |         if (refundAsETH && token == WETH) {
 565 |     |             IWETH9(WETH).withdraw(amount);
 566 |     |             TransferHelper.safeTransferETH(recipient, amount);
 567 |     |         } else {
 568 |     |             TransferHelper.safeTransfer(token, recipient, amount);
 569 |     |         }
 570 |     |     }
 571 |     | 
 572 |     |     /// @param token The token to pay
 573 |     |     /// @param payer The entity that must pay
 574 |     |     /// @param recipient The entity that will receive payment
 575 |     |     /// @param value The amount to pay
 576 |     |     function pay(
 577 |     |         address token,
 578 |     |         address payer,
 579 |     |         address recipient,
 580 |     |         uint256 value
 581 |     |     ) internal {
 582 |     |         if (token == WETH && address(this).balance >= value) {
 583 |     |             // pay with WETH9
 584 |     |             IWETH9(WETH).deposit{ value: value }(); // wrap only what is needed to pay
 585 |     |             IWETH9(WETH).transfer(recipient, value);
 586 |     |         } else if (payer == address(this)) {
 587 |     |             // pay with tokens already in the contract (for the exact input multihop case)
 588 |     |             TransferHelper.safeTransfer(token, recipient, value);
 589 |     |         } else {
 590 |     |             // pull payment
 591 |     |             TransferHelper.safeTransferFrom(token, payer, recipient, value);
 592 |     |         }
 593 |     |     }
 594 |     | }
 595 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/UnipilotStrategy.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity =0.7.6;
   4 |     | pragma abicoder v2;
   5 |     | 
   6 |     | import "./interfaces/IUnipilotStrategy.sol";
   7 |     | import "./base/oracle/libraries/OracleLibrary.sol";
   8 |     | 
   9 |     | // import "./dependencies/libraries/TickMath.sol";
  10 |     | // import "./dependencies/interfaces/IUniswapV3Pool.sol";
  11 |     | 
  12 |     | /**
  13 |     |  *
  14 |     |  * @notice
  15 |     |  *   This contract calculates suitable tick ranges to fully deposit liquidity asset.
  16 |     |  *   It maintains two strategies for unipilot vaults
  17 |     |  *   1) Base order => For depositing in-range liquidity
  18 |     |  *   2) Range order => To distribute remaining assets behind or ahead of base order ticks,
  19 |     |  *   so that users liquidity does not abruptly goes out of range
  20 |     |  *   @dev These ranges are named as follows.
  21 |     |  *   Base => upper and lower ticks for main range to deposit
  22 |     |  *   Ask => Upper and lower ticks ahead of the current tick and base upper
  23 |     |  *   Bid => Upper and lower ticks behind the current and base lower
  24 | *r  |  **/
  25 |     | contract UnipilotStrategy is IUnipilotStrategy {
  26 |     |     /// @dev governance address is set on deployment for the governance based functions
  27 | *   |     address public governance;
  28 |     |     /// @dev rangeTicks is multiplied with tick spacing to calculate range order spread
  29 | *   |     int24 public rangeTicks;
  30 |     |     /// @dev baseTicks is multiplied with tick spacing to calculate base order spread
  31 | *   |     int24 public baseTicks;
  32 |     |     /// @dev rangeOrder is the range calculate the spread behind and ahead of the base range
  33 |     |     int24 private rangeOrder;
  34 |     |     /// @dev baseMultiplier multiplier for base position for active pools
  35 | *   |     int24 public baseMultiplier;
  36 |     |     /// @dev readjustMultiplier is the percentage multiplier of raedjust threshold
  37 |     |     int24 private readjustMultiplier;
  38 |     |     /// @dev maxTwapDeviation is the max time weighted average deviation of price from the normal range in both directions
  39 | *   |     int24 public override maxTwapDeviation;
  40 |     |     /// @dev twapDuration is the minimum duration in which the diviated price moves
  41 | *   |     uint32 public override twapDuration;
  42 |     | 
  43 |     |     constructor(address _governance) {
  44 |     |         governance = _governance;
  45 |     |         maxTwapDeviation = 300;
  46 |     |         twapDuration = 3600;
  47 |     |         rangeTicks = 1800;
  48 |     |         baseTicks = 1800;
  49 |     |         readjustMultiplier = 10;
  50 |     |         baseMultiplier = 30;
  51 |     |     }
  52 |     | 
  53 |     |     /// @dev poolStrategy maintains the base,range multipliers and
  54 |     |     ///  twap variations for each pool
  55 |     |     mapping(address => PoolStrategy) internal poolStrategy;
  56 |     | 
  57 |     |     mapping(address => mapping(uint16 => int24)) internal activePoolStrategy;
  58 |     | 
  59 |     |     modifier onlyGovernance() {
  60 | r   |         require(msg.sender == governance, "NG");
  61 |     |         _;
  62 |     |     }
  63 |     | 
  64 | r   |     function setGovernance(address _governance) external onlyGovernance {
  65 |     |         require(_governance != address(0), "IGA");
  66 |     |         emit GovernanceUpdated(governance, _governance);
  67 |     |         governance = _governance;
  68 |     |     }
  69 |     | 
  70 |     |     /**
  71 |     |      *   @notice This function returns base,ask and bid range ticks for the given pool
  72 |     |      *   - It fetches the current tick and tick spacing of the pool
  73 |     |      *   - Multiples the tick spacing with pools base and range multipliers
  74 |     |      *   - Calculates pools twap and verifies whether it is under the maxtwapdeviation
  75 |     |      *   - If the price is under the deviation limit, it returns the base ranges along with range order ticks
  76 |     |      *   @param _pool: pool address
  77 |     |      **/
  78 | r   |     function getTicks(address _pool)
  79 |     |         external
  80 |     |         override
  81 |     |         returns (
  82 | r   |             int24 baseLower,
  83 | r   |             int24 baseUpper,
  84 | r   |             int24 bidLower,
  85 | r   |             int24 bidUpper,
  86 | r   |             int24 askLower,
  87 | r   |             int24 askUpper
  88 |     |         )
  89 |     |     {
  90 | r   |         (int24 tick, int24 tickSpacing) = getCurrentTick(_pool);
  91 |     | 
  92 |     |         if (
  93 |     |             poolStrategy[_pool].baseThreshold == 0 ||
  94 |     |             poolStrategy[_pool].rangeThreshold == 0
  95 |     |         ) {
  96 |     |             int24 baseFloor = _floor(baseTicks, tickSpacing);
  97 |     | 
  98 |     |             poolStrategy[_pool] = PoolStrategy({
  99 |     |                 baseThreshold: baseFloor,
 100 |     |                 rangeThreshold: _floor(rangeTicks, tickSpacing),
 101 |     |                 maxTwapDeviation: maxTwapDeviation,
 102 |     |                 readjustThreshold: (baseFloor * readjustMultiplier) / 100,
 103 |     |                 twapDuration: twapDuration,
 104 |     |                 baseMultiplier: baseMultiplier
 105 |     |             });
 106 |     |         }
 107 |     |         rangeOrder = poolStrategy[_pool].rangeThreshold;
 108 |     | 
 109 |     |         int24 maxThreshold = poolStrategy[_pool].baseThreshold > rangeOrder
 110 |     |             ? poolStrategy[_pool].baseThreshold
 111 |     |             : rangeOrder;
 112 |     | 
 113 |     |         require(
 114 |     |             (tick > TickMath.MIN_TICK + maxThreshold + tickSpacing) &&
 115 |     |                 (tick < (TickMath.MAX_TICK - maxThreshold - tickSpacing)),
 116 |     |             "IT"
 117 |     |         );
 118 |     |         int24 twap = calculateTwap(_pool);
 119 |     |         int24 deviation = tick > twap ? tick - twap : twap - tick;
 120 |     | 
 121 |     |         require(deviation <= poolStrategy[_pool].maxTwapDeviation, "MTF");
 122 |     | 
 123 |     |         int24 tickFloor = _floor(tick, tickSpacing);
 124 |     |         int24 tickCeil = tickFloor + tickSpacing;
 125 |     | 
 126 |     |         baseLower = tickFloor - poolStrategy[_pool].baseThreshold;
 127 |     |         baseUpper = tickFloor + poolStrategy[_pool].baseThreshold;
 128 |     |         bidLower = tickFloor - rangeOrder;
 129 |     |         bidUpper = tickFloor;
 130 |     |         askLower = tickCeil;
 131 |     |         askUpper = tickCeil + rangeOrder;
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      *   @notice This function sets the global multipier value of the range order
 136 |     |      *   @param _rangeTicks: a multiplier value to decide the spread of range order
 137 |     |      **/
 138 | r   |     function setRangeTicks(int24 _rangeTicks) external onlyGovernance {
 139 |     |         require(_rangeTicks > 0, "IRM");
 140 |     |         emit RangeTicksUpdated(rangeTicks, _rangeTicks);
 141 |     |         rangeTicks = _rangeTicks;
 142 |     |     }
 143 |     | 
 144 |     |     /**
 145 |     |      *   @notice This function updates the base range mutiplier
 146 |     |      *   @param _baseMultiplier: a mutiplier value to decide the spread of base range
 147 |     |      **/
 148 | r   |     function setBaseTicks(
 149 |     |         address[] memory _pools,
 150 |     |         uint16[] memory _strategyType,
 151 |     |         int24[] memory _baseMultiplier
 152 |     |     ) external onlyGovernance {
 153 |     |         require(_pools.length == _baseMultiplier.length);
 154 |     |         require(_pools.length == _strategyType.length);
 155 |     | 
 156 |     |         for (uint256 i = 0; i < _pools.length; i++) {
 157 |     |             activePoolStrategy[_pools[i]][_strategyType[i]] = _baseMultiplier[
 158 |     |                 i
 159 |     |             ];
 160 |     |         }
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      *   @notice This function updates the deviation limit of tick spread
 165 |     |      *   @param _twapDeviation: a value to decide the maximum price deviation
 166 |     |      **/
 167 | r   |     function setMaxTwapDeviation(int24 _twapDeviation) external onlyGovernance {
 168 |     |         require(_twapDeviation >= 20, "PF");
 169 |     |         emit MaxTwapDeviationUpdated(
 170 |     |             maxTwapDeviation,
 171 |     |             maxTwapDeviation = _twapDeviation
 172 |     |         );
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      *   @notice This function updates the twap duration
 177 |     |      *   @param _twapDuration: a value for the duration of recalbiration of the twap
 178 |     |      **/
 179 | r   |     function setTwapDuration(uint32 _twapDuration) external onlyGovernance {
 180 |     |         require(_twapDuration >= 100, "TD");
 181 |     |         emit TwapDurationUpdated(twapDuration, twapDuration = _twapDuration);
 182 |     |     }
 183 |     | 
 184 | r   |     function setReadjustMultiplier(int24 _readjustMultipier)
 185 |     |         external
 186 |     |         onlyGovernance
 187 |     |     {
 188 |     |         require(_readjustMultipier > 0, "IREM");
 189 |     |         emit ReadjustMultiplierUpdated(
 190 |     |             readjustMultiplier,
 191 |     |             readjustMultiplier = _readjustMultipier
 192 |     |         );
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      *   @notice This function updates the range,base threshold and twap values specific to a pool
 197 |     |      *   @param params: struct values of PoolStrategy struct, the values can be inspected from interface
 198 |     |      *   @param _pool<: pool address
 199 |     |      **/
 200 | r   |     function changeStrategy(PoolStrategy memory params, address _pool)
 201 |     |         public
 202 |     |         onlyGovernance
 203 |     |     {
 204 |     |         PoolStrategy memory oldStrategy = poolStrategy[_pool];
 205 |     |         validateStrategy(
 206 |     |             params.baseThreshold,
 207 |     |             IUniswapV3Pool(_pool).tickSpacing()
 208 |     |         );
 209 |     | 
 210 |     |         emit StrategyUpdated(
 211 |     |             oldStrategy,
 212 |     |             poolStrategy[_pool] = PoolStrategy({
 213 |     |                 baseThreshold: params.baseThreshold,
 214 |     |                 rangeThreshold: params.rangeThreshold,
 215 |     |                 maxTwapDeviation: params.maxTwapDeviation,
 216 |     |                 readjustThreshold: params.readjustThreshold,
 217 |     |                 twapDuration: params.twapDuration,
 218 |     |                 baseMultiplier: params.baseMultiplier
 219 |     |             })
 220 |     |         );
 221 |     |     }
 222 |     | 
 223 | r   |     function setAllStrategies(
 224 |     |         PoolStrategy[] memory params,
 225 |     |         address[] memory pools
 226 |     |     ) external onlyGovernance {
 227 |     |         require(params.length == pools.length, "IVI");
 228 |     |         for (uint256 i = 0; i < params.length; i++) {
 229 |     |             changeStrategy(params[i], pools[i]);
 230 |     |         }
 231 |     |     }
 232 |     | 
 233 |     |     /**
 234 |     |      *   @notice This function updates the twapDeviation value of pools iteratively
 235 |     |      *   @param _pools: pools addresses
 236 |     |      *   @param _twapDeviations: devaiation values
 237 |     |      **/
 238 | r   |     function setPoolTwapDeviation(
 239 |     |         address[] memory _pools,
 240 |     |         int24[] memory _twapDeviations
 241 |     |     ) external onlyGovernance {
 242 |     |         require(_pools.length == _twapDeviations.length, "IVI");
 243 |     |         for (uint256 i; i < _pools.length; i++) {
 244 |     |             poolStrategy[_pools[i]].maxTwapDeviation = _twapDeviations[i];
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 | r   |     function checkDeviation(address pool) external view override {
 249 | r   |         int24 twap = calculateTwap(pool);
 250 |     |         (int24 tick, ) = getCurrentTick(pool);
 251 |     |         int24 deviation = tick > twap ? tick - twap : twap - tick;
 252 |     | 
 253 |     |         require(deviation <= poolStrategy[pool].maxTwapDeviation, "MTF");
 254 |     |     }
 255 |     | 
 256 | *   |     function getStrategy(address _pool)
 257 |     |         external
 258 |     |         view
 259 |     |         override
 260 | *   |         returns (PoolStrategy memory strategy)
 261 |     |     {
 262 | *   |         strategy = poolStrategy[_pool];
 263 |     |     }
 264 |     | 
 265 |     |     /**
 266 |     |      *   @notice This function returns the readjust threshold of a pool
 267 |     |      *   @param _pool: pool address
 268 |     |      **/
 269 | *   |     function getReadjustThreshold(address _pool)
 270 |     |         public
 271 |     |         view
 272 | *   |         returns (int24 readjustThreshold)
 273 |     |     {
 274 | *   |         readjustThreshold = poolStrategy[_pool].readjustThreshold;
 275 |     |         return readjustThreshold;
 276 |     |     }
 277 |     | 
 278 | *   |     function getBaseThreshold(address _pool, uint16 _strategyType)
 279 |     |         external
 280 |     |         view
 281 |     |         override
 282 | *   |         returns (int24 baseThreshold)
 283 |     |     {
 284 | *   |         baseThreshold = activePoolStrategy[_pool][_strategyType];
 285 |     |     }
 286 |     | 
 287 |     |     /**
 288 |     |      *   @notice This function calculates the current twap of pool
 289 |     |      *   @param pool: pool address
 290 |     |      **/
 291 | r   |     function calculateTwap(address pool) internal view returns (int24 twap) {
 292 | r   |         uint128 inRangeLiquidity = IUniswapV3Pool(pool).liquidity();
 293 |     |         if (inRangeLiquidity == 0) {
 294 |     |             (uint160 sqrtPriceX96, , , , , , ) = IUniswapV3Pool(pool).slot0();
 295 |     |             twap = TickMath.getTickAtSqrtRatio(sqrtPriceX96);
 296 |     |         } else {
 297 |     |             twap = getTwap(pool);
 298 |     |         }
 299 |     |     }
 300 |     | 
 301 |     |     /**
 302 |     |      *   @notice This function fetches the twap of pool from the observation
 303 |     |      *   @param _pool: pool address
 304 |     |      **/
 305 | r   |     function getTwap(address _pool) public view override returns (int24 twap) {
 306 | r   |         IUniswapV3Pool uniswapV3Pool = IUniswapV3Pool(_pool);
 307 |     |         (
 308 |     |             ,
 309 |     |             ,
 310 | r   |             uint16 observationIndex,
 311 | r   |             uint16 observationCardinality,
 312 |     |             ,
 313 |     |             ,
 314 |     | 
 315 | r   |         ) = uniswapV3Pool.slot0();
 316 |     |         (uint32 lastTimeStamp, , , ) = uniswapV3Pool.observations(
 317 |     |             (observationIndex + 1) % observationCardinality
 318 |     |         );
 319 |     |         uint32 timeDiff = uint32(block.timestamp) - lastTimeStamp;
 320 |     |         uint32 duration = poolStrategy[_pool].twapDuration;
 321 |     |         if (duration == 0) {
 322 |     |             duration = twapDuration;
 323 |     |         }
 324 |     |         twap = OracleLibrary.consult(
 325 |     |             _pool,
 326 |     |             timeDiff > duration ? duration : timeDiff
 327 |     |         );
 328 |     |     }
 329 |     | 
 330 |     |     /**
 331 |     |      *   @notice This function calculates the lower tick value from the current tick
 332 |     |      *   @param tick: current tick of the pool
 333 |     |      *   @param tickSpacing: tick spacing according to the fee tier
 334 |     |      **/
 335 |     |     function _floor(int24 tick, int24 tickSpacing)
 336 |     |         internal
 337 |     |         pure
 338 |     |         returns (int24)
 339 |     |     {
 340 |     |         int24 compressed = tick / tickSpacing;
 341 |     |         if (tick < 0 && tick % tickSpacing != 0) compressed--;
 342 |     |         return compressed * tickSpacing;
 343 |     |     }
 344 |     | 
 345 |     |     /**
 346 |     |      *   @notice This function fetches the current tick of the pool
 347 |     |      *   @param pool: pool address
 348 |     |      **/
 349 | r   |     function getCurrentTick(address pool)
 350 |     |         internal
 351 |     |         view
 352 | r   |         returns (int24 tick, int24 tickSpacing)
 353 |     |     {
 354 | r   |         (, tick, , , , , ) = IUniswapV3PoolState(pool).slot0();
 355 |     |         tickSpacing = IUniswapV3Pool(pool).tickSpacing();
 356 |     |     }
 357 |     | 
 358 |     |     /**
 359 |     |      *   @notice This function validates that the updating strategy of the pool during the update
 360 |     |      *   @param _strategy: a value for baseThreshold
 361 |     |      *   @param _tickSpacing: spacing of tick according to fee tier
 362 |     |      **/
 363 |     |     function validateStrategy(int24 _strategy, int24 _tickSpacing)
 364 |     |         internal
 365 |     |         pure
 366 |     |     {
 367 |     |         require(
 368 |     |             _strategy <= TickMath.MAX_TICK &&
 369 |     |                 _strategy % _tickSpacing == 0 &&
 370 |     |                 _strategy > 0,
 371 |     |             "INS"
 372 |     |         );
 373 |     |     }
 374 |     | }
 375 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/base/oracle/libraries/OracleLibrary.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity =0.7.6;
  3 |     | 
  4 |     | import "../../../dependencies/interfaces/IUniswapV3Pool.sol";
  5 |     | import "../../../dependencies/libraries/FullMath.sol";
  6 |     | import "../../../dependencies/libraries/TickMath.sol";
  7 |     | 
  8 |     | library OracleLibrary {
  9 |     |     /// @notice Fetches time-weighted average tick using Uniswap V3 oracle
 10 |     |     /// @param pool Address of Uniswap V3 pool that we want to observe
 11 |     |     /// @param period Number of seconds in the past to start calculating time-weighted average
 12 |     |     /// @return timeWeightedAverageTick The time-weighted average tick from (block.timestamp - period) to block.timestamp
 13 |     |     function consult(address pool, uint32 period)
 14 |     |         internal
 15 |     |         view
 16 |     |         returns (int24 timeWeightedAverageTick)
 17 |     |     {
 18 |     |         require(period != 0, "BP");
 19 |     | 
 20 |     |         uint32[] memory secondAgos = new uint32[](2);
 21 |     |         secondAgos[0] = period;
 22 |     |         secondAgos[1] = 0;
 23 |     | 
 24 |     |         (int56[] memory tickCumulatives, ) = IUniswapV3Pool(pool).observe(
 25 |     |             secondAgos
 26 |     |         );
 27 |     |         int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];
 28 |     | 
 29 |     |         timeWeightedAverageTick = int24(tickCumulativesDelta / period);
 30 |     | 
 31 |     |         // Always round to negative infinity
 32 |     |         if (tickCumulativesDelta < 0 && (tickCumulativesDelta % period != 0))
 33 |     |             timeWeightedAverageTick--;
 34 |     |     }
 35 |     | 
 36 |     |     /// @notice Given a tick and a token amount, calculates the amount of token received in exchange
 37 |     |     /// @param tick Tick value used to calculate the quote
 38 |     |     /// @param baseAmount Amount of token to be converted
 39 |     |     /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination
 40 |     |     /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination
 41 |     |     /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken
 42 |     |     function getQuoteAtTick(
 43 |     |         int24 tick,
 44 |     |         uint128 baseAmount,
 45 |     |         address baseToken,
 46 |     |         address quoteToken
 47 |     |     ) internal pure returns (uint256 quoteAmount) {
 48 |     |         uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
 49 |     | 
 50 |     |         // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself
 51 |     |         if (sqrtRatioX96 <= type(uint128).max) {
 52 |     |             uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;
 53 |     |             quoteAmount = baseToken < quoteToken
 54 |     |                 ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)
 55 |     |                 : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);
 56 |     |         } else {
 57 |     |             uint256 ratioX128 = FullMath.mulDiv(
 58 |     |                 sqrtRatioX96,
 59 |     |                 sqrtRatioX96,
 60 |     |                 1 << 64
 61 |     |             );
 62 |     |             quoteAmount = baseToken < quoteToken
 63 |     |                 ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)
 64 |     |                 : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);
 65 |     |         }
 66 |     |     }
 67 |     | }
 68 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/crytic/testSetup.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.7.6;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import "./testUnipilot.sol";
  6 |     | import "../interfaces/IUnipilotVault.sol";
  7 |     | 
  8 | *r  | 
  9 |     | contract UnipilotFuzz is testUnipiot{
 10 |     |     address t0;
 11 |     |     address t1;
 12 |     |     IUnipilotVault UAV;
 13 |     |     event notmytoken(address);
 14 |     | 
 15 | r   |     function testAddress(
 16 |     |         uint16 _vaultStrategy,
 17 |     |         uint160 _sqrtPriceX96,
 18 |     |         uint24 fee
 19 |     |     ) public {
 20 | r   |         require(t0 != address(0));
 21 | r   |         address vault = UAF.createVault(
 22 | r   |             address(t0),
 23 | r   |             address(t1),
 24 | r   |             fee,
 25 | r   |             _vaultStrategy,
 26 | r   |             _sqrtPriceX96,
 27 |     |             "test",
 28 |     |             "tst"
 29 |     |         );
 30 |     |         if (address(tk1) == address(0)) {
 31 |     |             emit notmytoken(address(tk1));
 32 |     |         } else {
 33 |     |             assert(vault != address(0));
 34 |     |             UAV = IUnipilotVault(vault);
 35 |     |         }
 36 |     |     }
 37 |     | 
 38 | *   |     function gettokens() public {
 39 | *   |         (t0, t1) = createToken(msg.sender);
 40 |     |     }
 41 |     | }
 42 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/crytic/testUnipilot.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.7.6;
   3 |     | pragma abicoder v2;
   4 |     | 
   5 |     | import "../dependencies/UniswapV3Factory.sol";
   6 |     | import "../UnipilotStrategy.sol";
   7 |     | import "../dependencies/WETH.sol";
   8 |     | // import { UnipilotActiveFactory as uniFac } from "../UnipilotActiveFactory.sol";
   9 |     | import { UnipilotActiveFactory } from "../UnipilotActiveFactory.sol";
  10 |     | 
  11 | r   | 
  12 |     | contract indexfund {
  13 |     |     mapping(address => uint256) private balance0;
  14 |     |     mapping(address => uint256) private balance1;
  15 |     | }
  16 | r   | 
  17 |     | contract token {
  18 |     |     // --- Auth ---
  19 |     |     mapping(address => uint256) public wards;
  20 |     | 
  21 |     |     function rely(address usr) external auth {
  22 |     |         wards[usr] = 1;
  23 |     |         emit Rely(usr);
  24 |     |     }
  25 |     | 
  26 |     |     function deny(address usr) external auth {
  27 |     |         wards[usr] = 0;
  28 |     |         emit Deny(usr);
  29 |     |     }
  30 |     | 
  31 |     |     modifier auth() {
  32 |     |         require(wards[msg.sender] == 1, "Dai/not-authorized");
  33 |     |         _;
  34 |     |     }
  35 |     | 
  36 |     |     // --- ERC20 Data ---
  37 |     |     string public constant name = "Dai Stablecoin";
  38 |     |     string public constant symbol = "DAI";
  39 |     |     string public constant version = "2";
  40 |     |     uint8 public constant decimals = 18;
  41 |     |     uint256 public totalSupply;
  42 |     | 
  43 |     |     mapping(address => uint256) public balanceOf;
  44 |     |     mapping(address => mapping(address => uint256)) public allowance;
  45 |     |     mapping(address => uint256) public nonces;
  46 |     | 
  47 |     |     event Approval(
  48 |     |         address indexed owner,
  49 |     |         address indexed spender,
  50 |     |         uint256 value
  51 |     |     );
  52 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  53 |     |     event Rely(address indexed usr);
  54 |     |     event Deny(address indexed usr);
  55 |     | 
  56 |     |     // --- Math ---
  57 |     |     function _add(uint256 x, uint256 y) internal pure returns (uint256 z) {
  58 |     |         require((z = x + y) >= x);
  59 |     |     }
  60 |     | 
  61 |     |     function _sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
  62 |     |         require((z = x - y) <= x);
  63 |     |     }
  64 |     | 
  65 |     |     // --- EIP712 niceties ---
  66 |     |     uint256 public immutable deploymentChainId;
  67 |     |     bytes32 private immutable _DOMAIN_SEPARATOR;
  68 |     |     bytes32 public constant PERMIT_TYPEHASH =
  69 |     |         keccak256(
  70 |     |             "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
  71 |     |         );
  72 |     | 
  73 |     |     constructor(address _sender) {
  74 |     |         wards[msg.sender] = 1;
  75 |     |         _mint(_sender, 100 ether);
  76 |     |         emit Rely(msg.sender);
  77 |     | 
  78 |     |         uint256 chainId;
  79 |     |         assembly {
  80 |     |             chainId := chainid()
  81 |     |         }
  82 |     |         deploymentChainId = chainId;
  83 |     |         _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId);
  84 |     |     }
  85 |     | 
  86 |     |     function _calculateDomainSeparator(
  87 |     |         uint256 chainId
  88 |     |     ) private view returns (bytes32) {
  89 |     |         return
  90 |     |             keccak256(
  91 |     |                 abi.encode(
  92 |     |                     keccak256(
  93 |     |                         "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
  94 |     |                     ),
  95 |     |                     keccak256(bytes(name)),
  96 |     |                     keccak256(bytes(version)),
  97 |     |                     chainId,
  98 |     |                     address(this)
  99 |     |                 )
 100 |     |             );
 101 |     |     }
 102 |     | 
 103 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32) {
 104 |     |         uint256 chainId;
 105 |     |         assembly {
 106 |     |             chainId := chainid()
 107 |     |         }
 108 |     |         return
 109 |     |             chainId == deploymentChainId
 110 |     |                 ? _DOMAIN_SEPARATOR
 111 |     |                 : _calculateDomainSeparator(chainId);
 112 |     |     }
 113 |     | 
 114 |     |     // --- ERC20 Mutations ---
 115 |     |     function transfer(address to, uint256 value) external returns (bool) {
 116 |     |         require(to != address(0) && to != address(this), "Dai/invalid-address");
 117 |     |         uint256 balance = balanceOf[msg.sender];
 118 |     |         require(balance >= value, "Dai/insufficient-balance");
 119 |     | 
 120 |     |         balanceOf[msg.sender] = balance - value;
 121 |     |         balanceOf[to] += value;
 122 |     | 
 123 |     |         emit Transfer(msg.sender, to, value);
 124 |     | 
 125 |     |         return true;
 126 |     |     }
 127 |     | 
 128 |     |     function transferFrom(
 129 |     |         address from,
 130 |     |         address to,
 131 |     |         uint256 value
 132 |     |     ) external returns (bool) {
 133 |     |         require(to != address(0) && to != address(this), "Dai/invalid-address");
 134 |     |         uint256 balance = balanceOf[from];
 135 |     |         require(balance >= value, "Dai/insufficient-balance");
 136 |     | 
 137 |     |         // if (from != msg.sender) {
 138 |     |         //   uint256 allowed = allowance[from][msg.sender];
 139 |     |         //   if (allowed != type(uint256).max) {
 140 |     |         //     require(allowed >= value, "Dai/insufficient-allowance");
 141 |     | 
 142 |     |         //     allowance[from][msg.sender] = allowed - value;
 143 |     |         //   }
 144 |     |         // }
 145 |     | 
 146 |     |         balanceOf[from] = balance - value;
 147 |     |         balanceOf[to] += value;
 148 |     | 
 149 |     |         emit Transfer(from, to, value);
 150 |     | 
 151 |     |         return true;
 152 |     |     }
 153 |     | 
 154 |     |     //   function approve(address spender, uint256 value) external returns (bool) {
 155 |     |     //     allowance[msg.sender][spender] = value;
 156 |     | 
 157 |     |     //     emit Approval(msg.sender, spender, value);
 158 |     | 
 159 |     |     //     return true;
 160 |     |     //   }
 161 |     |     //   function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {
 162 |     |     //     uint256 newValue = _add(allowance[msg.sender][spender], addedValue);
 163 |     |     //     allowance[msg.sender][spender] = newValue;
 164 |     | 
 165 |     |     //     emit Approval(msg.sender, spender, newValue);
 166 |     | 
 167 |     |     //     return true;
 168 |     |     //   }
 169 |     |     //   function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {
 170 |     |     //     uint256 allowed = allowance[msg.sender][spender];
 171 |     |     //     require(allowed >= subtractedValue, "Dai/insufficient-allowance");
 172 |     |     //     allowed = allowed - subtractedValue;
 173 |     |     //     allowance[msg.sender][spender] = allowed;
 174 |     | 
 175 |     |     //     emit Approval(msg.sender, spender, allowed);
 176 |     | 
 177 |     |     //     return true;
 178 |     |     //   }
 179 |     | 
 180 |     |     // --- Mint/Burn ---
 181 |     |     function mint(address to, uint256 value) external auth {
 182 |     |         require(to != address(0) && to != address(this), "Dai/invalid-address");
 183 |     |         balanceOf[to] = balanceOf[to] + value; // note: we don't need an overflow check here b/c balanceOf[to] <= totalSupply and there is an overflow check below
 184 |     |         totalSupply = _add(totalSupply, value);
 185 |     | 
 186 |     |         emit Transfer(address(0), to, value);
 187 |     |     }
 188 |     | 
 189 |     |     function _mint(address to, uint256 value) private {
 190 |     |         require(to != address(0) && to != address(this), "Dai/invalid-address");
 191 |     |         balanceOf[to] = balanceOf[to] + value; // note: we don't need an overflow check here b/c balanceOf[to] <= totalSupply and there is an overflow check below
 192 |     |         totalSupply = _add(totalSupply, value);
 193 |     | 
 194 |     |         emit Transfer(address(0), to, value);
 195 |     |     }
 196 |     | 
 197 |     |     function burn(address from, uint256 value) external {
 198 |     |         uint256 balance = balanceOf[from];
 199 |     |         require(balance >= value, "Dai/insufficient-balance");
 200 |     | 
 201 |     |         // if (from != msg.sender && wards[msg.sender] != 1) {
 202 |     |         //   uint256 allowed = allowance[from][msg.sender];
 203 |     |         //   if (allowed != type(uint256).max) {
 204 |     |         //     require(allowed >= value, "Dai/insufficient-allowance");
 205 |     | 
 206 |     |         //     allowance[from][msg.sender] = allowed - value;
 207 |     |         //   }
 208 |     |         // }
 209 |     | 
 210 |     |         balanceOf[from] = balance - value; // note: we don't need overflow checks b/c require(balance >= value) and balance <= totalSupply
 211 |     |         totalSupply = totalSupply - value;
 212 |     | 
 213 |     |         emit Transfer(from, address(0), value);
 214 |     |     }
 215 |     | 
 216 |     |     // --- Approve by signature ---
 217 |     |     function permit(
 218 |     |         address owner,
 219 |     |         address spender,
 220 |     |         uint256 value,
 221 |     |         uint256 deadline,
 222 |     |         uint8 v,
 223 |     |         bytes32 r,
 224 |     |         bytes32 s
 225 |     |     ) external {
 226 |     |         require(block.timestamp <= deadline, "Dai/permit-expired");
 227 |     | 
 228 |     |         uint256 chainId;
 229 |     |         assembly {
 230 |     |             chainId := chainid()
 231 |     |         }
 232 |     | 
 233 |     |         bytes32 digest = keccak256(
 234 |     |             abi.encodePacked(
 235 |     |                 "\x19\x01",
 236 |     |                 chainId == deploymentChainId
 237 |     |                     ? _DOMAIN_SEPARATOR
 238 |     |                     : _calculateDomainSeparator(chainId),
 239 |     |                 keccak256(
 240 |     |                     abi.encode(
 241 |     |                         PERMIT_TYPEHASH,
 242 |     |                         owner,
 243 |     |                         spender,
 244 |     |                         value,
 245 |     |                         nonces[owner]++,
 246 |     |                         deadline
 247 |     |                     )
 248 |     |                 )
 249 |     |             )
 250 |     |         );
 251 |     | 
 252 |     |         require(
 253 |     |             owner != address(0) && owner == ecrecover(digest, v, r, s),
 254 |     |             "Dai/invalid-permit"
 255 |     |         );
 256 |     | 
 257 |     |         allowance[owner][spender] = value;
 258 |     |         emit Approval(owner, spender, value);
 259 |     |     }
 260 |     | }
 261 |     | 
 262 |     | contract testUnipiot {
 263 |     |     UniswapV3Factory factory;
 264 | *   |     UnipilotActiveFactory public UAF;
 265 |     |     UnipilotStrategy ST;
 266 |     |     indexfund IF;
 267 |     |     WETH9 weth;
 268 | *   |     token public tk1;
 269 | *   |     token public tk2;
 270 |     | 
 271 |     |     constructor() {
 272 |     |         factory = new UniswapV3Factory();
 273 |     |         ST = new UnipilotStrategy(address(this));
 274 |     |         IF = new indexfund();
 275 |     |         weth = new WETH9();
 276 |     |         UAF = new UnipilotActiveFactory(
 277 |     |             address(factory),
 278 |     |             address(this),
 279 |     |             address(ST),
 280 |     |             address(IF),
 281 |     |             address(weth),
 282 |     |             1
 283 |     |         );
 284 |     |     }
 285 |     | 
 286 | *r  |     function createToken(address sender) public returns(address t0, address t1){
 287 | *r  |         tk1 = new token(sender);
 288 | *r  |         tk2 = new token(sender);
 289 | *   |         t1 = address(tk1);
 290 | *   |         t0 = address(tk2);
 291 |     |     }
 292 |     | }
 293 |     | 
 294 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/ERC20Permit.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity >=0.6.5 <0.8.0;
   4 |     | 
   5 |     | // import "../token/ERC20/ERC20.sol";
   6 |     | // import "./IERC20Permit.sol";
   7 |     | // import "../cryptography/ECDSA.sol";
   8 |     | // import "../utils/Counters.sol";
   9 |     | // import "./EIP712.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  13 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  14 |     |  *
  15 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
  16 |     |  * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't
  17 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
  18 |     |  *
  19 |     |  * _Available since v3.4._
  20 |     |  */
  21 |     | 
  22 |     |  abstract contract EIP712 {
  23 |     |     /* solhint-disable var-name-mixedcase */
  24 |     |     // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to
  25 |     |     // invalidate the cached domain separator if the chain id changes.
  26 |     |     bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
  27 |     |     uint256 private immutable _CACHED_CHAIN_ID;
  28 |     | 
  29 |     |     bytes32 private immutable _HASHED_NAME;
  30 |     |     bytes32 private immutable _HASHED_VERSION;
  31 |     |     bytes32 private immutable _TYPE_HASH;
  32 |     |     /* solhint-enable var-name-mixedcase */
  33 |     | 
  34 |     |     /**
  35 |     |      * @dev Initializes the domain separator and parameter caches.
  36 |     |      *
  37 |     |      * The meaning of `name` and `version` is specified in
  38 |     |      * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:
  39 |     |      *
  40 |     |      * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.
  41 |     |      * - `version`: the current major version of the signing domain.
  42 |     |      *
  43 |     |      * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart
  44 |     |      * contract upgrade].
  45 |     |      */
  46 |     |     constructor(string memory name, string memory version) {
  47 |     |         bytes32 hashedName = keccak256(bytes(name));
  48 |     |         bytes32 hashedVersion = keccak256(bytes(version));
  49 |     |         bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
  50 |     |         _HASHED_NAME = hashedName;
  51 |     |         _HASHED_VERSION = hashedVersion;
  52 |     |         _CACHED_CHAIN_ID = _getChainId();
  53 |     |         _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);
  54 |     |         _TYPE_HASH = typeHash;
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Returns the domain separator for the current chain.
  59 |     |      */
  60 |     |     function _domainSeparatorV4() internal view virtual returns (bytes32) {
  61 |     |         if (_getChainId() == _CACHED_CHAIN_ID) {
  62 |     |             return _CACHED_DOMAIN_SEPARATOR;
  63 |     |         } else {
  64 |     |             return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
  65 |     |         }
  66 |     |     }
  67 |     | 
  68 |     |     function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {
  69 |     |         return keccak256(
  70 |     |             abi.encode(
  71 |     |                 typeHash,
  72 |     |                 name,
  73 |     |                 version,
  74 |     |                 _getChainId(),
  75 |     |                 address(this)
  76 |     |             )
  77 |     |         );
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this
  82 |     |      * function returns the hash of the fully encoded EIP712 message for this domain.
  83 |     |      *
  84 |     |      * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:
  85 |     |      *
  86 |     |      * ```solidity
  87 |     |      * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
  88 |     |      *     keccak256("Mail(address to,string contents)"),
  89 |     |      *     mailTo,
  90 |     |      *     keccak256(bytes(mailContents))
  91 |     |      * )));
  92 |     |      * address signer = ECDSA.recover(digest, signature);
  93 |     |      * ```
  94 |     |      */
  95 |     |     function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
  96 |     |         return keccak256(abi.encodePacked("\x19\x01", _domainSeparatorV4(), structHash));
  97 |     |     }
  98 |     | 
  99 |     |     function _getChainId() private view returns (uint256 chainId) {
 100 |     |         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
 101 |     |         // solhint-disable-next-line no-inline-assembly
 102 |     |         assembly {
 103 |     |             chainId := chainid()
 104 |     |         }
 105 |     |     }
 106 |     | }
 107 |     | 
 108 |     | 
 109 |     | library SafeMath {
 110 |     |     /**
 111 |     |      * @dev Returns the addition of two unsigned integers, with an overflow flag.
 112 |     |      *
 113 |     |      * _Available since v3.4._
 114 |     |      */
 115 |     |     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
 116 |     |         uint256 c = a + b;
 117 |     |         if (c < a) return (false, 0);
 118 |     |         return (true, c);
 119 |     |     }
 120 |     | 
 121 |     |     /**
 122 |     |      * @dev Returns the substraction of two unsigned integers, with an overflow flag.
 123 |     |      *
 124 |     |      * _Available since v3.4._
 125 |     |      */
 126 |     |     function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
 127 |     |         if (b > a) return (false, 0);
 128 |     |         return (true, a - b);
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
 133 |     |      *
 134 |     |      * _Available since v3.4._
 135 |     |      */
 136 |     |     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
 137 |     |         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
 138 |     |         // benefit is lost if 'b' is also tested.
 139 |     |         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
 140 |     |         if (a == 0) return (true, 0);
 141 |     |         uint256 c = a * b;
 142 |     |         if (c / a != b) return (false, 0);
 143 |     |         return (true, c);
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @dev Returns the division of two unsigned integers, with a division by zero flag.
 148 |     |      *
 149 |     |      * _Available since v3.4._
 150 |     |      */
 151 |     |     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
 152 |     |         if (b == 0) return (false, 0);
 153 |     |         return (true, a / b);
 154 |     |     }
 155 |     | 
 156 |     |     /**
 157 |     |      * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
 158 |     |      *
 159 |     |      * _Available since v3.4._
 160 |     |      */
 161 |     |     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
 162 |     |         if (b == 0) return (false, 0);
 163 |     |         return (true, a % b);
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Returns the addition of two unsigned integers, reverting on
 168 |     |      * overflow.
 169 |     |      *
 170 |     |      * Counterpart to Solidity's `+` operator.
 171 |     |      *
 172 |     |      * Requirements:
 173 |     |      *
 174 |     |      * - Addition cannot overflow.
 175 |     |      */
 176 |     |     function add(uint256 a, uint256 b) internal pure returns (uint256) {
 177 |     |         uint256 c = a + b;
 178 |     |         require(c >= a, "SafeMath: addition overflow");
 179 |     |         return c;
 180 |     |     }
 181 |     | 
 182 |     |     /**
 183 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on
 184 |     |      * overflow (when the result is negative).
 185 |     |      *
 186 |     |      * Counterpart to Solidity's `-` operator.
 187 |     |      *
 188 |     |      * Requirements:
 189 |     |      *
 190 |     |      * - Subtraction cannot overflow.
 191 |     |      */
 192 |     |     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
 193 |     |         require(b <= a, "SafeMath: subtraction overflow");
 194 |     |         return a - b;
 195 |     |     }
 196 |     | 
 197 |     |     /**
 198 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on
 199 |     |      * overflow.
 200 |     |      *
 201 |     |      * Counterpart to Solidity's `*` operator.
 202 |     |      *
 203 |     |      * Requirements:
 204 |     |      *
 205 |     |      * - Multiplication cannot overflow.
 206 |     |      */
 207 |     |     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
 208 |     |         if (a == 0) return 0;
 209 |     |         uint256 c = a * b;
 210 |     |         require(c / a == b, "SafeMath: multiplication overflow");
 211 |     |         return c;
 212 |     |     }
 213 |     | 
 214 |     |     /**
 215 |     |      * @dev Returns the integer division of two unsigned integers, reverting on
 216 |     |      * division by zero. The result is rounded towards zero.
 217 |     |      *
 218 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 219 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 220 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 221 |     |      *
 222 |     |      * Requirements:
 223 |     |      *
 224 |     |      * - The divisor cannot be zero.
 225 |     |      */
 226 |     |     function div(uint256 a, uint256 b) internal pure returns (uint256) {
 227 |     |         require(b > 0, "SafeMath: division by zero");
 228 |     |         return a / b;
 229 |     |     }
 230 |     | 
 231 |     |     /**
 232 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 233 |     |      * reverting when dividing by zero.
 234 |     |      *
 235 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 236 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 237 |     |      * invalid opcode to revert (consuming all remaining gas).
 238 |     |      *
 239 |     |      * Requirements:
 240 |     |      *
 241 |     |      * - The divisor cannot be zero.
 242 |     |      */
 243 |     |     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
 244 |     |         require(b > 0, "SafeMath: modulo by zero");
 245 |     |         return a % b;
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
 250 |     |      * overflow (when the result is negative).
 251 |     |      *
 252 |     |      * CAUTION: This function is deprecated because it requires allocating memory for the error
 253 |     |      * message unnecessarily. For custom revert reasons use {trySub}.
 254 |     |      *
 255 |     |      * Counterpart to Solidity's `-` operator.
 256 |     |      *
 257 |     |      * Requirements:
 258 |     |      *
 259 |     |      * - Subtraction cannot overflow.
 260 |     |      */
 261 |     |     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
 262 |     |         require(b <= a, errorMessage);
 263 |     |         return a - b;
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Returns the integer division of two unsigned integers, reverting with custom message on
 268 |     |      * division by zero. The result is rounded towards zero.
 269 |     |      *
 270 |     |      * CAUTION: This function is deprecated because it requires allocating memory for the error
 271 |     |      * message unnecessarily. For custom revert reasons use {tryDiv}.
 272 |     |      *
 273 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 274 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 275 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 276 |     |      *
 277 |     |      * Requirements:
 278 |     |      *
 279 |     |      * - The divisor cannot be zero.
 280 |     |      */
 281 |     |     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
 282 |     |         require(b > 0, errorMessage);
 283 |     |         return a / b;
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 288 |     |      * reverting with custom message when dividing by zero.
 289 |     |      *
 290 |     |      * CAUTION: This function is deprecated because it requires allocating memory for the error
 291 |     |      * message unnecessarily. For custom revert reasons use {tryMod}.
 292 |     |      *
 293 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 294 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 295 |     |      * invalid opcode to revert (consuming all remaining gas).
 296 |     |      *
 297 |     |      * Requirements:
 298 |     |      *
 299 |     |      * - The divisor cannot be zero.
 300 |     |      */
 301 |     |     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
 302 |     |         require(b > 0, errorMessage);
 303 |     |         return a % b;
 304 |     |     }
 305 |     | }
 306 |     | 
 307 |     | 
 308 |     |  library Counters {
 309 |     |     using SafeMath for uint256;
 310 |     | 
 311 |     |     struct Counter {
 312 |     |         // This variable should never be directly accessed by users of the library: interactions must be restricted to
 313 |     |         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
 314 |     |         // this feature: see https://github.com/ethereum/solidity/issues/4637
 315 |     |         uint256 _value; // default: 0
 316 |     |     }
 317 |     | 
 318 |     |     function current(Counter storage counter) internal view returns (uint256) {
 319 |     |         return counter._value;
 320 |     |     }
 321 |     | 
 322 |     |     function increment(Counter storage counter) internal {
 323 |     |         // The {SafeMath} overflow check can be skipped here, see the comment at the top
 324 |     |         counter._value += 1;
 325 |     |     }
 326 |     | 
 327 |     |     function decrement(Counter storage counter) internal {
 328 |     |         counter._value = counter._value.sub(1);
 329 |     |     }
 330 |     | }
 331 |     | 
 332 |     | library ECDSA {
 333 |     |     /**
 334 |     |      * @dev Returns the address that signed a hashed message (`hash`) with
 335 |     |      * `signature`. This address can then be used for verification purposes.
 336 |     |      *
 337 |     |      * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
 338 |     |      * this function rejects them by requiring the `s` value to be in the lower
 339 |     |      * half order, and the `v` value to be either 27 or 28.
 340 |     |      *
 341 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
 342 |     |      * verification to be secure: it is possible to craft signatures that
 343 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
 344 |     |      * this is by receiving a hash of the original message (which may otherwise
 345 |     |      * be too long), and then calling {toEthSignedMessageHash} on it.
 346 |     |      */
 347 |     |     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
 348 |     |         // Check the signature length
 349 |     |         if (signature.length != 65) {
 350 |     |             revert("ECDSA: invalid signature length");
 351 |     |         }
 352 |     | 
 353 |     |         // Divide the signature in r, s and v variables
 354 |     |         bytes32 r;
 355 |     |         bytes32 s;
 356 |     |         uint8 v;
 357 |     | 
 358 |     |         // ecrecover takes the signature parameters, and the only way to get them
 359 |     |         // currently is to use assembly.
 360 |     |         // solhint-disable-next-line no-inline-assembly
 361 |     |         assembly {
 362 |     |             r := mload(add(signature, 0x20))
 363 |     |             s := mload(add(signature, 0x40))
 364 |     |             v := byte(0, mload(add(signature, 0x60)))
 365 |     |         }
 366 |     | 
 367 |     |         return recover(hash, v, r, s);
 368 |     |     }
 369 |     | 
 370 |     |     /**
 371 |     |      * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,
 372 |     |      * `r` and `s` signature fields separately.
 373 |     |      */
 374 |     |     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
 375 |     |         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
 376 |     |         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
 377 |     |         // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most
 378 |     |         // signatures from current libraries generate a unique signature with an s-value in the lower half order.
 379 |     |         //
 380 |     |         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
 381 |     |         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
 382 |     |         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
 383 |     |         // these malleable signatures as well.
 384 |     |         require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value");
 385 |     |         require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value");
 386 |     | 
 387 |     |         // If the signature is valid (and not malleable), return the signer address
 388 |     |         address signer = ecrecover(hash, v, r, s);
 389 |     |         require(signer != address(0), "ECDSA: invalid signature");
 390 |     | 
 391 |     |         return signer;
 392 |     |     }
 393 |     | 
 394 |     |     /**
 395 |     |      * @dev Returns an Ethereum Signed Message, created from a `hash`. This
 396 |     |      * replicates the behavior of the
 397 |     |      * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]
 398 |     |      * JSON-RPC method.
 399 |     |      *
 400 |     |      * See {recover}.
 401 |     |      */
 402 |     |     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {
 403 |     |         // 32 is the length in bytes of hash,
 404 |     |         // enforced by the type signature above
 405 |     |         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
 406 |     |     }
 407 |     | }
 408 |     | 
 409 |     |  interface IERC20Permit {
 410 |     |     /**
 411 |     |      * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,
 412 |     |      * given `owner`'s signed approval.
 413 |     |      *
 414 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 415 |     |      * ordering also apply here.
 416 |     |      *
 417 |     |      * Emits an {Approval} event.
 418 |     |      *
 419 |     |      * Requirements:
 420 |     |      *
 421 |     |      * - `spender` cannot be the zero address.
 422 |     |      * - `deadline` must be a timestamp in the future.
 423 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 424 |     |      * over the EIP712-formatted function arguments.
 425 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 426 |     |      *
 427 |     |      * For more information on the signature format, see the
 428 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 429 |     |      * section].
 430 |     |      */
 431 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
 432 |     | 
 433 |     |     /**
 434 |     |      * @dev Returns the current nonce for `owner`. This value must be
 435 |     |      * included whenever a signature is generated for {permit}.
 436 |     |      *
 437 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 438 |     |      * prevents a signature from being used multiple times.
 439 |     |      */
 440 |     |     function nonces(address owner) external view returns (uint256);
 441 |     | 
 442 |     |     /**
 443 |     |      * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.
 444 |     |      */
 445 |     |     // solhint-disable-next-line func-name-mixedcase
 446 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 447 |     | }
 448 |     | 
 449 |     | 
 450 |     |  abstract contract Context {
 451 |     |     function _msgSender() internal view virtual returns (address payable) {
 452 |     |         return msg.sender;
 453 |     |     }
 454 |     | 
 455 |     |     function _msgData() internal view virtual returns (bytes memory) {
 456 |     |         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
 457 |     |         return msg.data;
 458 |     |     }
 459 |     | }
 460 |     | 
 461 |     | interface IERC20 {
 462 |     |     /**
 463 |     |      * @dev Returns the amount of tokens in existence.
 464 |     |      */
 465 |     |     function totalSupply() external view returns (uint256);
 466 |     | 
 467 |     |     /**
 468 |     |      * @dev Returns the amount of tokens owned by `account`.
 469 |     |      */
 470 |     |     function balanceOf(address account) external view returns (uint256);
 471 |     | 
 472 |     |     /**
 473 |     |      * @dev Moves `amount` tokens from the caller's account to `recipient`.
 474 |     |      *
 475 |     |      * Returns a boolean value indicating whether the operation succeeded.
 476 |     |      *
 477 |     |      * Emits a {Transfer} event.
 478 |     |      */
 479 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 480 |     | 
 481 |     |     /**
 482 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 483 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 484 |     |      * zero by default.
 485 |     |      *
 486 |     |      * This value changes when {approve} or {transferFrom} are called.
 487 |     |      */
 488 |     |     function allowance(address owner, address spender) external view returns (uint256);
 489 |     | 
 490 |     |     /**
 491 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 492 |     |      *
 493 |     |      * Returns a boolean value indicating whether the operation succeeded.
 494 |     |      *
 495 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 496 |     |      * that someone may use both the old and the new allowance by unfortunate
 497 |     |      * transaction ordering. One possible solution to mitigate this race
 498 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 499 |     |      * desired value afterwards:
 500 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 501 |     |      *
 502 |     |      * Emits an {Approval} event.
 503 |     |      */
 504 |     |     function approve(address spender, uint256 amount) external returns (bool);
 505 |     | 
 506 |     |     /**
 507 |     |      * @dev Moves `amount` tokens from `sender` to `recipient` using the
 508 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 509 |     |      * allowance.
 510 |     |      *
 511 |     |      * Returns a boolean value indicating whether the operation succeeded.
 512 |     |      *
 513 |     |      * Emits a {Transfer} event.
 514 |     |      */
 515 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
 516 |     | 
 517 |     |     /**
 518 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 519 |     |      * another (`to`).
 520 |     |      *
 521 |     |      * Note that `value` may be zero.
 522 |     |      */
 523 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 524 |     | 
 525 |     |     /**
 526 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 527 |     |      * a call to {approve}. `value` is the new allowance.
 528 |     |      */
 529 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 530 |     | }
 531 |     | 
 532 |     | 
 533 |     | contract ERC20 is Context, IERC20 {
 534 |     |     using SafeMath for uint256;
 535 |     | 
 536 |     |     mapping (address => uint256) private _balances;
 537 |     | 
 538 |     |     mapping (address => mapping (address => uint256)) private _allowances;
 539 |     | 
 540 |     |     uint256 private _totalSupply;
 541 |     | 
 542 |     |     string private _name;
 543 |     |     string private _symbol;
 544 |     |     uint8 private _decimals;
 545 |     | 
 546 |     |     /**
 547 |     |      * @dev Sets the values for {name} and {symbol}, initializes {decimals} with
 548 |     |      * a default value of 18.
 549 |     |      *
 550 |     |      * To select a different value for {decimals}, use {_setupDecimals}.
 551 |     |      *
 552 |     |      * All three of these values are immutable: they can only be set once during
 553 |     |      * construction.
 554 |     |      */
 555 |     |     constructor (string memory name_, string memory symbol_) {
 556 |     |         _name = name_;
 557 |     |         _symbol = symbol_;
 558 |     |         _decimals = 18;
 559 |     |     }
 560 |     | 
 561 |     |     /**
 562 |     |      * @dev Returns the name of the token.
 563 |     |      */
 564 |     |     function name() public view virtual returns (string memory) {
 565 |     |         return _name;
 566 |     |     }
 567 |     | 
 568 |     |     /**
 569 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
 570 |     |      * name.
 571 |     |      */
 572 |     |     function symbol() public view virtual returns (string memory) {
 573 |     |         return _symbol;
 574 |     |     }
 575 |     | 
 576 |     |     /**
 577 |     |      * @dev Returns the number of decimals used to get its user representation.
 578 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
 579 |     |      * be displayed to a user as `5,05` (`505 / 10 ** 2`).
 580 |     |      *
 581 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
 582 |     |      * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is
 583 |     |      * called.
 584 |     |      *
 585 |     |      * NOTE: This information is only used for _display_ purposes: it in
 586 |     |      * no way affects any of the arithmetic of the contract, including
 587 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
 588 |     |      */
 589 |     |     function decimals() public view virtual returns (uint8) {
 590 |     |         return _decimals;
 591 |     |     }
 592 |     | 
 593 |     |     /**
 594 |     |      * @dev See {IERC20-totalSupply}.
 595 |     |      */
 596 |     |     function totalSupply() public view virtual override returns (uint256) {
 597 |     |         return _totalSupply;
 598 |     |     }
 599 |     | 
 600 |     |     /**
 601 |     |      * @dev See {IERC20-balanceOf}.
 602 |     |      */
 603 |     |     function balanceOf(address account) public view virtual override returns (uint256) {
 604 |     |         return _balances[account];
 605 |     |     }
 606 |     | 
 607 |     |     /**
 608 |     |      * @dev See {IERC20-transfer}.
 609 |     |      *
 610 |     |      * Requirements:
 611 |     |      *
 612 |     |      * - `recipient` cannot be the zero address.
 613 |     |      * - the caller must have a balance of at least `amount`.
 614 |     |      */
 615 |     |     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
 616 |     |         _transfer(_msgSender(), recipient, amount);
 617 |     |         return true;
 618 |     |     }
 619 |     | 
 620 |     |     /**
 621 |     |      * @dev See {IERC20-allowance}.
 622 |     |      */
 623 |     |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 624 |     |         return _allowances[owner][spender];
 625 |     |     }
 626 |     | 
 627 |     |     /**
 628 |     |      * @dev See {IERC20-approve}.
 629 |     |      *
 630 |     |      * Requirements:
 631 |     |      *
 632 |     |      * - `spender` cannot be the zero address.
 633 |     |      */
 634 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 635 |     |         _approve(_msgSender(), spender, amount);
 636 |     |         return true;
 637 |     |     }
 638 |     | 
 639 |     |     /**
 640 |     |      * @dev See {IERC20-transferFrom}.
 641 |     |      *
 642 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 643 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 644 |     |      *
 645 |     |      * Requirements:
 646 |     |      *
 647 |     |      * - `sender` and `recipient` cannot be the zero address.
 648 |     |      * - `sender` must have a balance of at least `amount`.
 649 |     |      * - the caller must have allowance for ``sender``'s tokens of at least
 650 |     |      * `amount`.
 651 |     |      */
 652 |     |     function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
 653 |     |         _transfer(sender, recipient, amount);
 654 |     |         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
 655 |     |         return true;
 656 |     |     }
 657 |     | 
 658 |     |     /**
 659 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 660 |     |      *
 661 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 662 |     |      * problems described in {IERC20-approve}.
 663 |     |      *
 664 |     |      * Emits an {Approval} event indicating the updated allowance.
 665 |     |      *
 666 |     |      * Requirements:
 667 |     |      *
 668 |     |      * - `spender` cannot be the zero address.
 669 |     |      */
 670 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 671 |     |         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
 672 |     |         return true;
 673 |     |     }
 674 |     | 
 675 |     |     /**
 676 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 677 |     |      *
 678 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 679 |     |      * problems described in {IERC20-approve}.
 680 |     |      *
 681 |     |      * Emits an {Approval} event indicating the updated allowance.
 682 |     |      *
 683 |     |      * Requirements:
 684 |     |      *
 685 |     |      * - `spender` cannot be the zero address.
 686 |     |      * - `spender` must have allowance for the caller of at least
 687 |     |      * `subtractedValue`.
 688 |     |      */
 689 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 690 |     |         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
 691 |     |         return true;
 692 |     |     }
 693 |     | 
 694 |     |     /**
 695 |     |      * @dev Moves tokens `amount` from `sender` to `recipient`.
 696 |     |      *
 697 |     |      * This is internal function is equivalent to {transfer}, and can be used to
 698 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 699 |     |      *
 700 |     |      * Emits a {Transfer} event.
 701 |     |      *
 702 |     |      * Requirements:
 703 |     |      *
 704 |     |      * - `sender` cannot be the zero address.
 705 |     |      * - `recipient` cannot be the zero address.
 706 |     |      * - `sender` must have a balance of at least `amount`.
 707 |     |      */
 708 |     |     function _transfer(address sender, address recipient, uint256 amount) internal virtual {
 709 |     |         require(sender != address(0), "ERC20: transfer from the zero address");
 710 |     |         require(recipient != address(0), "ERC20: transfer to the zero address");
 711 |     | 
 712 |     |         _beforeTokenTransfer(sender, recipient, amount);
 713 |     | 
 714 |     |         _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
 715 |     |         _balances[recipient] = _balances[recipient].add(amount);
 716 |     |         emit Transfer(sender, recipient, amount);
 717 |     |     }
 718 |     | 
 719 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 720 |     |      * the total supply.
 721 |     |      *
 722 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 723 |     |      *
 724 |     |      * Requirements:
 725 |     |      *
 726 |     |      * - `to` cannot be the zero address.
 727 |     |      */
 728 |     |     function _mint(address account, uint256 amount) internal virtual {
 729 |     |         require(account != address(0), "ERC20: mint to the zero address");
 730 |     | 
 731 |     |         _beforeTokenTransfer(address(0), account, amount);
 732 |     | 
 733 |     |         _totalSupply = _totalSupply.add(amount);
 734 |     |         _balances[account] = _balances[account].add(amount);
 735 |     |         emit Transfer(address(0), account, amount);
 736 |     |     }
 737 |     | 
 738 |     |     /**
 739 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 740 |     |      * total supply.
 741 |     |      *
 742 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 743 |     |      *
 744 |     |      * Requirements:
 745 |     |      *
 746 |     |      * - `account` cannot be the zero address.
 747 |     |      * - `account` must have at least `amount` tokens.
 748 |     |      */
 749 |     |     function _burn(address account, uint256 amount) internal virtual {
 750 |     |         require(account != address(0), "ERC20: burn from the zero address");
 751 |     | 
 752 |     |         _beforeTokenTransfer(account, address(0), amount);
 753 |     | 
 754 |     |         _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
 755 |     |         _totalSupply = _totalSupply.sub(amount);
 756 |     |         emit Transfer(account, address(0), amount);
 757 |     |     }
 758 |     | 
 759 |     |     /**
 760 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 761 |     |      *
 762 |     |      * This internal function is equivalent to `approve`, and can be used to
 763 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 764 |     |      *
 765 |     |      * Emits an {Approval} event.
 766 |     |      *
 767 |     |      * Requirements:
 768 |     |      *
 769 |     |      * - `owner` cannot be the zero address.
 770 |     |      * - `spender` cannot be the zero address.
 771 |     |      */
 772 |     |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 773 |     |         require(owner != address(0), "ERC20: approve from the zero address");
 774 |     |         require(spender != address(0), "ERC20: approve to the zero address");
 775 |     | 
 776 |     |         _allowances[owner][spender] = amount;
 777 |     |         emit Approval(owner, spender, amount);
 778 |     |     }
 779 |     | 
 780 |     |     /**
 781 |     |      * @dev Sets {decimals} to a value other than the default one of 18.
 782 |     |      *
 783 |     |      * WARNING: This function should only be called from the constructor. Most
 784 |     |      * applications that interact with token contracts will not expect
 785 |     |      * {decimals} to ever change, and may work incorrectly if it does.
 786 |     |      */
 787 |     |     function _setupDecimals(uint8 decimals_) internal virtual {
 788 |     |         _decimals = decimals_;
 789 |     |     }
 790 |     | 
 791 |     |     /**
 792 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 793 |     |      * minting and burning.
 794 |     |      *
 795 |     |      * Calling conditions:
 796 |     |      *
 797 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 798 |     |      * will be to transferred to `to`.
 799 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 800 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 801 |     |      * - `from` and `to` are never both zero.
 802 |     |      *
 803 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 804 |     |      */
 805 |     |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
 806 |     | }
 807 |     | 
 808 |     | abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {
 809 |     |     using Counters for Counters.Counter;
 810 |     | 
 811 |     |     mapping (address => Counters.Counter) private _nonces;
 812 |     | 
 813 |     |     // solhint-disable-next-line var-name-mixedcase
 814 |     |     bytes32 private immutable _PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
 815 |     | 
 816 |     |     /**
 817 |     |      * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `"1"`.
 818 |     |      *
 819 |     |      * It's a good idea to use the same `name` that is defined as the ERC20 token name.
 820 |     |      */
 821 |     |     constructor(string memory name) EIP712(name, "1") {
 822 |     |     }
 823 |     | 
 824 |     |     /**
 825 |     |      * @dev See {IERC20Permit-permit}.
 826 |     |      */
 827 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {
 828 |     |         // solhint-disable-next-line not-rely-on-time
 829 |     |         require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
 830 |     | 
 831 |     |         bytes32 structHash = keccak256(
 832 |     |             abi.encode(
 833 |     |                 _PERMIT_TYPEHASH,
 834 |     |                 owner,
 835 |     |                 spender,
 836 |     |                 value,
 837 |     |                 _nonces[owner].current(),
 838 |     |                 deadline
 839 |     |             )
 840 |     |         );
 841 |     | 
 842 |     |         bytes32 hash = _hashTypedDataV4(structHash);
 843 |     | 
 844 |     |         address signer = ECDSA.recover(hash, v, r, s);
 845 |     |         require(signer == owner, "ERC20Permit: invalid signature");
 846 |     | 
 847 |     |         _nonces[owner].increment();
 848 |     |         _approve(owner, spender, value);
 849 |     |     }
 850 |     | 
 851 |     |     /**
 852 |     |      * @dev See {IERC20Permit-nonces}.
 853 |     |      */
 854 |     |     function nonces(address owner) public view override returns (uint256) {
 855 |     |         return _nonces[owner].current();
 856 |     |     }
 857 |     | 
 858 |     |     /**
 859 |     |      * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.
 860 |     |      */
 861 |     |     // solhint-disable-next-line func-name-mixedcase
 862 |     |     function DOMAIN_SEPARATOR() external view override returns (bytes32) {
 863 |     |         return _domainSeparatorV4();
 864 |     |     }
 865 |     | }
 866 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/LiquidityAmounts.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | import './libraries/FullMath.sol';
   5 |     | import './libraries/FixedPoint96.sol';
   6 |     | 
   7 |     | /// @title Liquidity amount functions
   8 |     | /// @notice Provides functions for computing liquidity amounts from token amounts and prices
   9 |     | library LiquidityAmounts {
  10 |     |     /// @notice Downcasts uint256 to uint128
  11 |     |     /// @param x The uint258 to be downcasted
  12 |     |     /// @return y The passed value, downcasted to uint128
  13 |     |     function toUint128(uint256 x) private pure returns (uint128 y) {
  14 |     |         require((y = uint128(x)) == x);
  15 |     |     }
  16 |     | 
  17 |     |     /// @notice Computes the amount of liquidity received for a given amount of token0 and price range
  18 |     |     /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))
  19 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  20 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  21 |     |     /// @param amount0 The amount0 being sent in
  22 |     |     /// @return liquidity The amount of returned liquidity
  23 |     |     function getLiquidityForAmount0(
  24 |     |         uint160 sqrtRatioAX96,
  25 |     |         uint160 sqrtRatioBX96,
  26 |     |         uint256 amount0
  27 |     |     ) internal pure returns (uint128 liquidity) {
  28 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  29 |     |         uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
  30 |     |         return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
  31 |     |     }
  32 |     | 
  33 |     |     /// @notice Computes the amount of liquidity received for a given amount of token1 and price range
  34 |     |     /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).
  35 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  36 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  37 |     |     /// @param amount1 The amount1 being sent in
  38 |     |     /// @return liquidity The amount of returned liquidity
  39 |     |     function getLiquidityForAmount1(
  40 |     |         uint160 sqrtRatioAX96,
  41 |     |         uint160 sqrtRatioBX96,
  42 |     |         uint256 amount1
  43 |     |     ) internal pure returns (uint128 liquidity) {
  44 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  45 |     |         return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
  46 |     |     }
  47 |     | 
  48 |     |     /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current
  49 |     |     /// pool prices and the prices at the tick boundaries
  50 |     |     /// @param sqrtRatioX96 A sqrt price representing the current pool prices
  51 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  52 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  53 |     |     /// @param amount0 The amount of token0 being sent in
  54 |     |     /// @param amount1 The amount of token1 being sent in
  55 |     |     /// @return liquidity The maximum amount of liquidity received
  56 |     |     function getLiquidityForAmounts(
  57 |     |         uint160 sqrtRatioX96,
  58 |     |         uint160 sqrtRatioAX96,
  59 |     |         uint160 sqrtRatioBX96,
  60 |     |         uint256 amount0,
  61 |     |         uint256 amount1
  62 |     |     ) internal pure returns (uint128 liquidity) {
  63 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  64 |     | 
  65 |     |         if (sqrtRatioX96 <= sqrtRatioAX96) {
  66 |     |             liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
  67 |     |         } else if (sqrtRatioX96 < sqrtRatioBX96) {
  68 |     |             uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
  69 |     |             uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
  70 |     | 
  71 |     |             liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
  72 |     |         } else {
  73 |     |             liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /// @notice Computes the amount of token0 for a given amount of liquidity and a price range
  78 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  79 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  80 |     |     /// @param liquidity The liquidity being valued
  81 |     |     /// @return amount0 The amount of token0
  82 |     |     function getAmount0ForLiquidity(
  83 |     |         uint160 sqrtRatioAX96,
  84 |     |         uint160 sqrtRatioBX96,
  85 |     |         uint128 liquidity
  86 |     |     ) internal pure returns (uint256 amount0) {
  87 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  88 |     | 
  89 |     |         return
  90 |     |             FullMath.mulDiv(
  91 |     |                 uint256(liquidity) << FixedPoint96.RESOLUTION,
  92 |     |                 sqrtRatioBX96 - sqrtRatioAX96,
  93 |     |                 sqrtRatioBX96
  94 |     |             ) / sqrtRatioAX96;
  95 |     |     }
  96 |     | 
  97 |     |     /// @notice Computes the amount of token1 for a given amount of liquidity and a price range
  98 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  99 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
 100 |     |     /// @param liquidity The liquidity being valued
 101 |     |     /// @return amount1 The amount of token1
 102 |     |     function getAmount1ForLiquidity(
 103 |     |         uint160 sqrtRatioAX96,
 104 |     |         uint160 sqrtRatioBX96,
 105 |     |         uint128 liquidity
 106 |     |     ) internal pure returns (uint256 amount1) {
 107 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 108 |     | 
 109 |     |         return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
 110 |     |     }
 111 |     | 
 112 |     |     /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current
 113 |     |     /// pool prices and the prices at the tick boundaries
 114 |     |     /// @param sqrtRatioX96 A sqrt price representing the current pool prices
 115 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
 116 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
 117 |     |     /// @param liquidity The liquidity being valued
 118 |     |     /// @return amount0 The amount of token0
 119 |     |     /// @return amount1 The amount of token1
 120 |     |     function getAmountsForLiquidity(
 121 |     |         uint160 sqrtRatioX96,
 122 |     |         uint160 sqrtRatioAX96,
 123 |     |         uint160 sqrtRatioBX96,
 124 |     |         uint128 liquidity
 125 |     |     ) internal pure returns (uint256 amount0, uint256 amount1) {
 126 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 127 |     | 
 128 |     |         if (sqrtRatioX96 <= sqrtRatioAX96) {
 129 |     |             amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
 130 |     |         } else if (sqrtRatioX96 < sqrtRatioBX96) {
 131 |     |             amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
 132 |     |             amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
 133 |     |         } else {
 134 |     |             amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
 135 |     |         }
 136 |     |     }
 137 |     | }
 138 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/NoDelegateCall.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity =0.7.6;
  3 |     | 
  4 |     | /// @title Prevents delegatecall to a contract
  5 |     | /// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract
  6 |     | abstract contract NoDelegateCall {
  7 |     |     /// @dev The original address of this contract
  8 |     |     address private immutable original;
  9 |     | 
 10 |     |     constructor() {
 11 |     |         // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.
 12 |     |         // In other words, this variable won't change when it's checked at runtime.
 13 |     |         original = address(this);
 14 |     |     }
 15 |     | 
 16 |     |     /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,
 17 |     |     ///     and the use of immutable means the address bytes are copied in every place the modifier is used.
 18 | *r  |     function checkNotDelegateCall() private view {
 19 | *r  |         require(address(this) == original);
 20 |     |     }
 21 |     | 
 22 |     |     /// @notice Prevents delegatecall into the modified method
 23 |     |     modifier noDelegateCall() {
 24 | *r  |         checkNotDelegateCall();
 25 | *r  |         _;
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/PositionKey.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | library PositionKey {
  5 |     |     /// @dev Returns the key of the position in the core library
  6 |     |     function compute(
  7 |     |         address owner,
  8 |     |         int24 tickLower,
  9 |     |         int24 tickUpper
 10 |     |     ) internal pure returns (bytes32) {
 11 |     |         return keccak256(abi.encodePacked(owner, tickLower, tickUpper));
 12 |     |     }
 13 |     | }
 14 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/UniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity =0.7.6;
  3 |     | 
  4 |     | import "./interfaces/IUniswapV3Factory.sol";
  5 |     | 
  6 |     | import "./UniswapV3PoolDeployer.sol";
  7 |     | import "./NoDelegateCall.sol";
  8 |     | 
  9 |     | import "./UniswapV3Pool.sol";
 10 |     | 
 11 |     | /// @title Canonical Uniswap V3 factory
 12 | *r  | /// @notice Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees
 13 |     | contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall {
 14 |     |     /// @inheritdoc IUniswapV3Factory
 15 | *   |     address public override owner;
 16 |     | 
 17 |     |     /// @inheritdoc IUniswapV3Factory
 18 | *   |     mapping(uint24 => int24) public override feeAmountTickSpacing;
 19 |     |     /// @inheritdoc IUniswapV3Factory
 20 | *r  |     mapping(address => mapping(address => mapping(uint24 => address))) public override getPool;
 21 |     | 
 22 |     |     constructor() {
 23 |     |         owner = msg.sender;
 24 |     |         emit OwnerChanged(address(0), msg.sender);
 25 |     | 
 26 |     |         feeAmountTickSpacing[500] = 10;
 27 |     |         emit FeeAmountEnabled(500, 10);
 28 |     |         feeAmountTickSpacing[3000] = 60;
 29 |     |         emit FeeAmountEnabled(3000, 60);
 30 |     |         feeAmountTickSpacing[10000] = 200;
 31 |     |         emit FeeAmountEnabled(10000, 200);
 32 |     |     }
 33 |     | 
 34 |     |     /// @inheritdoc IUniswapV3Factory
 35 | *r  |     function createPool(
 36 |     |         address tokenA,
 37 |     |         address tokenB,
 38 |     |         uint24 fee
 39 | *r  |     ) external override noDelegateCall returns (address pool) {
 40 | *r  |         require(tokenA != tokenB);
 41 | *r  |         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
 42 | *r  |         require(token0 != address(0));
 43 | *r  |         int24 tickSpacing = feeAmountTickSpacing[fee];
 44 | *r  |         require(tickSpacing != 0);
 45 | *r  |         require(getPool[token0][token1][fee] == address(0));
 46 | *r  |         pool = deploy(address(this), token0, token1, fee, tickSpacing);
 47 | *r  |         getPool[token0][token1][fee] = pool;
 48 |     |         // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses
 49 | *r  |         getPool[token1][token0][fee] = pool;
 50 | *r  |         emit PoolCreated(token0, token1, fee, tickSpacing, pool);
 51 |     |     }
 52 |     | 
 53 |     |     /// @inheritdoc IUniswapV3Factory
 54 | r   |     function setOwner(address _owner) external override {
 55 | r   |         require(msg.sender == owner);
 56 |     |         emit OwnerChanged(owner, _owner);
 57 |     |         owner = _owner;
 58 |     |     }
 59 |     | 
 60 |     |     /// @inheritdoc IUniswapV3Factory
 61 | r   |     function enableFeeAmount(uint24 fee, int24 tickSpacing) public override {
 62 | r   |         require(msg.sender == owner);
 63 |     |         require(fee < 1000000);
 64 |     |         // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that
 65 |     |         // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick
 66 |     |         // 16384 ticks represents a >5x price change with ticks of 1 bips
 67 |     |         require(tickSpacing > 0 && tickSpacing < 16384);
 68 |     |         require(feeAmountTickSpacing[fee] == 0);
 69 |     | 
 70 |     |         feeAmountTickSpacing[fee] = tickSpacing;
 71 |     |         emit FeeAmountEnabled(fee, tickSpacing);
 72 |     |     }
 73 |     | }
 74 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/UniswapV3Pool.sol
    1 |     | // SPDX-License-Identifier: BUSL-1.1
    2 |     | pragma solidity =0.7.6;
    3 |     | 
    4 |     | import "./interfaces/IUniswapV3Pool.sol";
    5 |     | 
    6 |     | import "./NoDelegateCall.sol";
    7 |     | 
    8 |     | import "./libraries/LowGasSafeMath.sol";
    9 |     | import "./libraries/SafeCast.sol";
   10 |     | import "./libraries/Tick.sol";
   11 |     | import "./libraries/TickBitmap.sol";
   12 |     | import "./libraries/Position.sol";
   13 |     | import "./libraries/Oracle.sol";
   14 |     | 
   15 |     | import "./libraries/FullMath.sol";
   16 |     | import "./libraries/FixedPoint128.sol";
   17 |     | import "./libraries/TransferHelper.sol";
   18 |     | import "./libraries/TickMath.sol";
   19 |     | import "./libraries/LiquidityMath.sol";
   20 |     | import "./libraries/SqrtPriceMath.sol";
   21 |     | import "./libraries/SwapMath.sol";
   22 |     | 
   23 |     | import "./interfaces/IUniswapV3PoolDeployer.sol";
   24 |     | import "./interfaces/IUniswapV3Factory.sol";
   25 |     | import "./interfaces/IERC20Minimal.sol";
   26 |     | import "./interfaces/callback/IUniswapV3MintCallback.sol";
   27 |     | import "./interfaces/callback/IUniswapV3SwapCallback.sol";
   28 |     | import "./interfaces/callback/IUniswapV3FlashCallback.sol";
   29 | r   | 
   30 |     | contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall {
   31 |     |     using LowGasSafeMath for uint256;
   32 |     |     using LowGasSafeMath for int256;
   33 |     |     using SafeCast for uint256;
   34 |     |     using SafeCast for int256;
   35 |     |     using Tick for mapping(int24 => Tick.Info);
   36 |     |     using TickBitmap for mapping(int16 => uint256);
   37 |     |     using Position for mapping(bytes32 => Position.Info);
   38 |     |     using Position for Position.Info;
   39 |     |     using Oracle for Oracle.Observation[65535];
   40 |     | 
   41 |     |     /// @inheritdoc IUniswapV3PoolImmutables
   42 |     |     address public immutable override factory;
   43 |     |     /// @inheritdoc IUniswapV3PoolImmutables
   44 | r   |     address public immutable override token0;
   45 |     |     /// @inheritdoc IUniswapV3PoolImmutables
   46 | r   |     address public immutable override token1;
   47 |     |     /// @inheritdoc IUniswapV3PoolImmutables
   48 | r   |     uint24 public immutable override fee;
   49 |     | 
   50 |     |     /// @inheritdoc IUniswapV3PoolImmutables
   51 | r   |     int24 public immutable override tickSpacing;
   52 |     | 
   53 |     |     /// @inheritdoc IUniswapV3PoolImmutables
   54 |     |     uint128 public immutable override maxLiquidityPerTick;
   55 |     | 
   56 |     |     struct Slot0 {
   57 |     |         // the current price
   58 |     |         uint160 sqrtPriceX96;
   59 |     |         // the current tick
   60 |     |         int24 tick;
   61 |     |         // the most-recently updated index of the observations array
   62 |     |         uint16 observationIndex;
   63 |     |         // the current maximum number of observations that are being stored
   64 |     |         uint16 observationCardinality;
   65 |     |         // the next maximum number of observations to store, triggered in observations.write
   66 |     |         uint16 observationCardinalityNext;
   67 |     |         // the current protocol fee as a percentage of the swap fee taken on withdrawal
   68 |     |         // represented as an integer denominator (1/x)%
   69 |     |         uint8 feeProtocol;
   70 |     |         // whether the pool is locked
   71 |     |         bool unlocked;
   72 |     |     }
   73 |     |     /// @inheritdoc IUniswapV3PoolState
   74 |     |     Slot0 public override slot0;
   75 |     | 
   76 |     |     /// @inheritdoc IUniswapV3PoolState
   77 |     |     uint256 public override feeGrowthGlobal0X128;
   78 |     |     /// @inheritdoc IUniswapV3PoolState
   79 |     |     uint256 public override feeGrowthGlobal1X128;
   80 |     | 
   81 |     |     // accumulated protocol fees in token0/token1 units
   82 |     |     struct ProtocolFees {
   83 |     |         uint128 token0;
   84 |     |         uint128 token1;
   85 |     |     }
   86 |     |     /// @inheritdoc IUniswapV3PoolState
   87 |     |     ProtocolFees public override protocolFees;
   88 |     | 
   89 |     |     /// @inheritdoc IUniswapV3PoolState
   90 |     |     uint128 public override liquidity;
   91 |     | 
   92 |     |     /// @inheritdoc IUniswapV3PoolState
   93 |     |     mapping(int24 => Tick.Info) public override ticks;
   94 |     |     /// @inheritdoc IUniswapV3PoolState
   95 |     |     mapping(int16 => uint256) public override tickBitmap;
   96 |     |     /// @inheritdoc IUniswapV3PoolState
   97 |     |     mapping(bytes32 => Position.Info) public override positions;
   98 |     |     /// @inheritdoc IUniswapV3PoolState
   99 |     |     Oracle.Observation[65535] public override observations;
  100 |     | 
  101 |     |     /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance
  102 |     |     /// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because
  103 |     |     /// we use balance checks to determine the payment status of interactions such as mint, swap and flash.
  104 |     |     modifier lock() {
  105 |     |         require(slot0.unlocked, "LOK");
  106 |     |         slot0.unlocked = false;
  107 |     |         _;
  108 |     |         slot0.unlocked = true;
  109 |     |     }
  110 |     | 
  111 |     |     /// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()
  112 |     |     modifier onlyFactoryOwner() {
  113 |     |         require(msg.sender == IUniswapV3Factory(factory).owner());
  114 |     |         _;
  115 |     |     }
  116 |     | 
  117 |     |     constructor() {
  118 |     |         int24 _tickSpacing;
  119 |     |         (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(
  120 |     |             msg.sender
  121 |     |         ).parameters();
  122 |     |         tickSpacing = _tickSpacing;
  123 |     | 
  124 |     |         maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(
  125 |     |             _tickSpacing
  126 |     |         );
  127 |     |     }
  128 |     | 
  129 |     |     /// @dev Common checks for valid tick inputs.
  130 |     |     function checkTicks(int24 tickLower, int24 tickUpper) private pure {
  131 |     |         require(tickLower < tickUpper, "TLU");
  132 |     |         require(tickLower >= TickMath.MIN_TICK, "TLM");
  133 |     |         require(tickUpper <= TickMath.MAX_TICK, "TUM");
  134 |     |     }
  135 |     | 
  136 |     |     /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.
  137 | r   |     function _blockTimestamp() internal view virtual returns (uint32) {
  138 | r   |         return uint32(block.timestamp); // truncation is desired
  139 |     |     }
  140 |     | 
  141 |     |     /// @dev Get the pool"s balance of token0
  142 |     |     /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
  143 |     |     /// check
  144 |     |     function balance0() private view returns (uint256) {
  145 |     |         (bool success, bytes memory data) = token0.staticcall(
  146 |     |             abi.encodeWithSelector(
  147 |     |                 IERC20Minimal.balanceOf.selector,
  148 |     |                 address(this)
  149 |     |             )
  150 |     |         );
  151 |     |         require(success && data.length >= 32);
  152 |     |         return abi.decode(data, (uint256));
  153 |     |     }
  154 |     | 
  155 |     |     /// @dev Get the pool"s balance of token1
  156 |     |     /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
  157 |     |     /// check
  158 |     |     function balance1() private view returns (uint256) {
  159 |     |         (bool success, bytes memory data) = token1.staticcall(
  160 |     |             abi.encodeWithSelector(
  161 |     |                 IERC20Minimal.balanceOf.selector,
  162 |     |                 address(this)
  163 |     |             )
  164 |     |         );
  165 |     |         require(success && data.length >= 32);
  166 |     |         return abi.decode(data, (uint256));
  167 |     |     }
  168 |     | 
  169 |     |     /// @inheritdoc IUniswapV3PoolDerivedState
  170 |     |     function snapshotCumulativesInside(
  171 |     |         int24 tickLower,
  172 |     |         int24 tickUpper
  173 |     |     )
  174 |     |         external
  175 |     |         view
  176 |     |         override
  177 |     |         noDelegateCall
  178 |     |         returns (
  179 |     |             int56 tickCumulativeInside,
  180 |     |             uint160 secondsPerLiquidityInsideX128,
  181 |     |             uint32 secondsInside
  182 |     |         )
  183 |     |     {
  184 |     |         checkTicks(tickLower, tickUpper);
  185 |     | 
  186 |     |         int56 tickCumulativeLower;
  187 |     |         int56 tickCumulativeUpper;
  188 |     |         uint160 secondsPerLiquidityOutsideLowerX128;
  189 |     |         uint160 secondsPerLiquidityOutsideUpperX128;
  190 |     |         uint32 secondsOutsideLower;
  191 |     |         uint32 secondsOutsideUpper;
  192 |     | 
  193 |     |         {
  194 |     |             Tick.Info storage lower = ticks[tickLower];
  195 |     |             Tick.Info storage upper = ticks[tickUpper];
  196 |     |             bool initializedLower;
  197 |     |             (
  198 |     |                 tickCumulativeLower,
  199 |     |                 secondsPerLiquidityOutsideLowerX128,
  200 |     |                 secondsOutsideLower,
  201 |     |                 initializedLower
  202 |     |             ) = (
  203 |     |                 lower.tickCumulativeOutside,
  204 |     |                 lower.secondsPerLiquidityOutsideX128,
  205 |     |                 lower.secondsOutside,
  206 |     |                 lower.initialized
  207 |     |             );
  208 |     |             require(initializedLower);
  209 |     | 
  210 |     |             bool initializedUpper;
  211 |     |             (
  212 |     |                 tickCumulativeUpper,
  213 |     |                 secondsPerLiquidityOutsideUpperX128,
  214 |     |                 secondsOutsideUpper,
  215 |     |                 initializedUpper
  216 |     |             ) = (
  217 |     |                 upper.tickCumulativeOutside,
  218 |     |                 upper.secondsPerLiquidityOutsideX128,
  219 |     |                 upper.secondsOutside,
  220 |     |                 upper.initialized
  221 |     |             );
  222 |     |             require(initializedUpper);
  223 |     |         }
  224 |     | 
  225 |     |         Slot0 memory _slot0 = slot0;
  226 |     | 
  227 |     |         if (_slot0.tick < tickLower) {
  228 |     |             return (
  229 |     |                 tickCumulativeLower - tickCumulativeUpper,
  230 |     |                 secondsPerLiquidityOutsideLowerX128 -
  231 |     |                     secondsPerLiquidityOutsideUpperX128,
  232 |     |                 secondsOutsideLower - secondsOutsideUpper
  233 |     |             );
  234 |     |         } else if (_slot0.tick < tickUpper) {
  235 |     |             uint32 time = _blockTimestamp();
  236 |     |             (
  237 |     |                 int56 tickCumulative,
  238 |     |                 uint160 secondsPerLiquidityCumulativeX128
  239 |     |             ) = observations.observeSingle(
  240 |     |                     time,
  241 |     |                     0,
  242 |     |                     _slot0.tick,
  243 |     |                     _slot0.observationIndex,
  244 |     |                     liquidity,
  245 |     |                     _slot0.observationCardinality
  246 |     |                 );
  247 |     |             return (
  248 |     |                 tickCumulative - tickCumulativeLower - tickCumulativeUpper,
  249 |     |                 secondsPerLiquidityCumulativeX128 -
  250 |     |                     secondsPerLiquidityOutsideLowerX128 -
  251 |     |                     secondsPerLiquidityOutsideUpperX128,
  252 |     |                 time - secondsOutsideLower - secondsOutsideUpper
  253 |     |             );
  254 |     |         } else {
  255 |     |             return (
  256 |     |                 tickCumulativeUpper - tickCumulativeLower,
  257 |     |                 secondsPerLiquidityOutsideUpperX128 -
  258 |     |                     secondsPerLiquidityOutsideLowerX128,
  259 |     |                 secondsOutsideUpper - secondsOutsideLower
  260 |     |             );
  261 |     |         }
  262 |     |     }
  263 |     | 
  264 |     |     /// @inheritdoc IUniswapV3PoolDerivedState
  265 |     |     function observe(
  266 |     |         uint32[] calldata secondsAgos
  267 |     |     )
  268 |     |         external
  269 |     |         view
  270 |     |         override
  271 |     |         noDelegateCall
  272 |     |         returns (
  273 |     |             int56[] memory tickCumulatives,
  274 |     |             uint160[] memory secondsPerLiquidityCumulativeX128s
  275 |     |         )
  276 |     |     {
  277 |     |         return
  278 |     |             observations.observe(
  279 |     |                 _blockTimestamp(),
  280 |     |                 secondsAgos,
  281 |     |                 slot0.tick,
  282 |     |                 slot0.observationIndex,
  283 |     |                 liquidity,
  284 |     |                 slot0.observationCardinality
  285 |     |             );
  286 |     |     }
  287 |     | 
  288 |     |     /// @inheritdoc IUniswapV3PoolActions
  289 |     |     function increaseObservationCardinalityNext(
  290 |     |         uint16 observationCardinalityNext
  291 |     |     ) external override lock noDelegateCall {
  292 |     |         uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event
  293 |     |         uint16 observationCardinalityNextNew = observations.grow(
  294 |     |             observationCardinalityNextOld,
  295 |     |             observationCardinalityNext
  296 |     |         );
  297 |     |         slot0.observationCardinalityNext = observationCardinalityNextNew;
  298 |     |         if (observationCardinalityNextOld != observationCardinalityNextNew)
  299 |     |             emit IncreaseObservationCardinalityNext(
  300 |     |                 observationCardinalityNextOld,
  301 |     |                 observationCardinalityNextNew
  302 |     |             );
  303 |     |     }
  304 |     | 
  305 |     |     /// @inheritdoc IUniswapV3PoolActions
  306 |     |     /// @dev not locked because it initializes unlocked
  307 | r   |     function initialize(uint160 sqrtPriceX96) external override {
  308 | r   |         require(slot0.sqrtPriceX96 == 0, "AI");
  309 |     | 
  310 | r   |         int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);
  311 |     | 
  312 | r   |         (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(
  313 | r   |             _blockTimestamp()
  314 |     |         );
  315 |     | 
  316 | r   |         slot0 = Slot0({
  317 | r   |             sqrtPriceX96: sqrtPriceX96,
  318 | r   |             tick: tick,
  319 | r   |             observationIndex: 0,
  320 | r   |             observationCardinality: cardinality,
  321 | r   |             observationCardinalityNext: cardinalityNext,
  322 | r   |             feeProtocol: 0,
  323 | r   |             unlocked: true
  324 |     |         });
  325 |     | 
  326 | r   |         emit Initialize(sqrtPriceX96, tick);
  327 |     |     }
  328 |     | 
  329 |     |     struct ModifyPositionParams {
  330 |     |         // the address that owns the position
  331 |     |         address owner;
  332 |     |         // the lower and upper tick of the position
  333 |     |         int24 tickLower;
  334 |     |         int24 tickUpper;
  335 |     |         // any change in liquidity
  336 |     |         int128 liquidityDelta;
  337 |     |     }
  338 |     | 
  339 |     |     /// @dev Effect some changes to a position
  340 |     |     /// @param params the position details and the change to the position"s liquidity to effect
  341 |     |     /// @return position a storage pointer referencing the position with the given owner and tick range
  342 |     |     /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient
  343 |     |     /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient
  344 |     |     function _modifyPosition(
  345 |     |         ModifyPositionParams memory params
  346 |     |     )
  347 |     |         private
  348 |     |         noDelegateCall
  349 |     |         returns (Position.Info storage position, int256 amount0, int256 amount1)
  350 |     |     {
  351 |     |         checkTicks(params.tickLower, params.tickUpper);
  352 |     | 
  353 |     |         Slot0 memory _slot0 = slot0; // SLOAD for gas optimization
  354 |     | 
  355 |     |         position = _updatePosition(
  356 |     |             params.owner,
  357 |     |             params.tickLower,
  358 |     |             params.tickUpper,
  359 |     |             params.liquidityDelta,
  360 |     |             _slot0.tick
  361 |     |         );
  362 |     | 
  363 |     |         if (params.liquidityDelta != 0) {
  364 |     |             if (_slot0.tick < params.tickLower) {
  365 |     |                 // current tick is below the passed range; liquidity can only become in range by crossing from left to
  366 |     |                 // right, when we"ll need _more_ token0 (it"s becoming more valuable) so user must provide it
  367 |     |                 amount0 = SqrtPriceMath.getAmount0Delta(
  368 |     |                     TickMath.getSqrtRatioAtTick(params.tickLower),
  369 |     |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
  370 |     |                     params.liquidityDelta
  371 |     |                 );
  372 |     |             } else if (_slot0.tick < params.tickUpper) {
  373 |     |                 // current tick is inside the passed range
  374 |     |                 uint128 liquidityBefore = liquidity; // SLOAD for gas optimization
  375 |     | 
  376 |     |                 // write an oracle entry
  377 |     |                 (
  378 |     |                     slot0.observationIndex,
  379 |     |                     slot0.observationCardinality
  380 |     |                 ) = observations.write(
  381 |     |                     _slot0.observationIndex,
  382 |     |                     _blockTimestamp(),
  383 |     |                     _slot0.tick,
  384 |     |                     liquidityBefore,
  385 |     |                     _slot0.observationCardinality,
  386 |     |                     _slot0.observationCardinalityNext
  387 |     |                 );
  388 |     | 
  389 |     |                 amount0 = SqrtPriceMath.getAmount0Delta(
  390 |     |                     _slot0.sqrtPriceX96,
  391 |     |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
  392 |     |                     params.liquidityDelta
  393 |     |                 );
  394 |     |                 amount1 = SqrtPriceMath.getAmount1Delta(
  395 |     |                     TickMath.getSqrtRatioAtTick(params.tickLower),
  396 |     |                     _slot0.sqrtPriceX96,
  397 |     |                     params.liquidityDelta
  398 |     |                 );
  399 |     | 
  400 |     |                 liquidity = LiquidityMath.addDelta(
  401 |     |                     liquidityBefore,
  402 |     |                     params.liquidityDelta
  403 |     |                 );
  404 |     |             } else {
  405 |     |                 // current tick is above the passed range; liquidity can only become in range by crossing from right to
  406 |     |                 // left, when we"ll need _more_ token1 (it"s becoming more valuable) so user must provide it
  407 |     |                 amount1 = SqrtPriceMath.getAmount1Delta(
  408 |     |                     TickMath.getSqrtRatioAtTick(params.tickLower),
  409 |     |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
  410 |     |                     params.liquidityDelta
  411 |     |                 );
  412 |     |             }
  413 |     |         }
  414 |     |     }
  415 |     | 
  416 |     |     /// @dev Gets and updates a position with the given liquidity delta
  417 |     |     /// @param owner the owner of the position
  418 |     |     /// @param tickLower the lower tick of the position"s tick range
  419 |     |     /// @param tickUpper the upper tick of the position"s tick range
  420 |     |     /// @param tick the current tick, passed to avoid sloads
  421 |     |     function _updatePosition(
  422 |     |         address owner,
  423 |     |         int24 tickLower,
  424 |     |         int24 tickUpper,
  425 |     |         int128 liquidityDelta,
  426 |     |         int24 tick
  427 |     |     ) private returns (Position.Info storage position) {
  428 |     |         position = positions.get(owner, tickLower, tickUpper);
  429 |     | 
  430 |     |         uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization
  431 |     |         uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization
  432 |     | 
  433 |     |         // if we need to update the ticks, do it
  434 |     |         bool flippedLower;
  435 |     |         bool flippedUpper;
  436 |     |         if (liquidityDelta != 0) {
  437 |     |             uint32 time = _blockTimestamp();
  438 |     |             (
  439 |     |                 int56 tickCumulative,
  440 |     |                 uint160 secondsPerLiquidityCumulativeX128
  441 |     |             ) = observations.observeSingle(
  442 |     |                     time,
  443 |     |                     0,
  444 |     |                     slot0.tick,
  445 |     |                     slot0.observationIndex,
  446 |     |                     liquidity,
  447 |     |                     slot0.observationCardinality
  448 |     |                 );
  449 |     | 
  450 |     |             flippedLower = ticks.update(
  451 |     |                 tickLower,
  452 |     |                 tick,
  453 |     |                 liquidityDelta,
  454 |     |                 _feeGrowthGlobal0X128,
  455 |     |                 _feeGrowthGlobal1X128,
  456 |     |                 secondsPerLiquidityCumulativeX128,
  457 |     |                 tickCumulative,
  458 |     |                 time,
  459 |     |                 false,
  460 |     |                 maxLiquidityPerTick
  461 |     |             );
  462 |     |             flippedUpper = ticks.update(
  463 |     |                 tickUpper,
  464 |     |                 tick,
  465 |     |                 liquidityDelta,
  466 |     |                 _feeGrowthGlobal0X128,
  467 |     |                 _feeGrowthGlobal1X128,
  468 |     |                 secondsPerLiquidityCumulativeX128,
  469 |     |                 tickCumulative,
  470 |     |                 time,
  471 |     |                 true,
  472 |     |                 maxLiquidityPerTick
  473 |     |             );
  474 |     | 
  475 |     |             if (flippedLower) {
  476 |     |                 tickBitmap.flipTick(tickLower, tickSpacing);
  477 |     |             }
  478 |     |             if (flippedUpper) {
  479 |     |                 tickBitmap.flipTick(tickUpper, tickSpacing);
  480 |     |             }
  481 |     |         }
  482 |     | 
  483 |     |         (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks
  484 |     |             .getFeeGrowthInside(
  485 |     |                 tickLower,
  486 |     |                 tickUpper,
  487 |     |                 tick,
  488 |     |                 _feeGrowthGlobal0X128,
  489 |     |                 _feeGrowthGlobal1X128
  490 |     |             );
  491 |     | 
  492 |     |         position.update(
  493 |     |             liquidityDelta,
  494 |     |             feeGrowthInside0X128,
  495 |     |             feeGrowthInside1X128
  496 |     |         );
  497 |     | 
  498 |     |         // clear any tick data that is no longer needed
  499 |     |         if (liquidityDelta < 0) {
  500 |     |             if (flippedLower) {
  501 |     |                 ticks.clear(tickLower);
  502 |     |             }
  503 |     |             if (flippedUpper) {
  504 |     |                 ticks.clear(tickUpper);
  505 |     |             }
  506 |     |         }
  507 |     |     }
  508 |     | 
  509 |     |     /// @inheritdoc IUniswapV3PoolActions
  510 |     |     /// @dev noDelegateCall is applied indirectly via _modifyPosition
  511 |     |     function mint(
  512 |     |         address recipient,
  513 |     |         int24 tickLower,
  514 |     |         int24 tickUpper,
  515 |     |         uint128 amount,
  516 |     |         bytes calldata data
  517 |     |     ) external override lock returns (uint256 amount0, uint256 amount1) {
  518 |     |         require(amount > 0);
  519 |     |         (, int256 amount0Int, int256 amount1Int) = _modifyPosition(
  520 |     |             ModifyPositionParams({
  521 |     |                 owner: recipient,
  522 |     |                 tickLower: tickLower,
  523 |     |                 tickUpper: tickUpper,
  524 |     |                 liquidityDelta: int256(amount).toInt128()
  525 |     |             })
  526 |     |         );
  527 |     | 
  528 |     |         amount0 = uint256(amount0Int);
  529 |     |         amount1 = uint256(amount1Int);
  530 |     | 
  531 |     |         uint256 balance0Before;
  532 |     |         uint256 balance1Before;
  533 |     |         if (amount0 > 0) balance0Before = balance0();
  534 |     |         if (amount1 > 0) balance1Before = balance1();
  535 |     |         IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(
  536 |     |             amount0,
  537 |     |             amount1,
  538 |     |             data
  539 |     |         );
  540 |     |         if (amount0 > 0)
  541 |     |             require(balance0Before.add(amount0) <= balance0(), "M0");
  542 |     |         if (amount1 > 0)
  543 |     |             require(balance1Before.add(amount1) <= balance1(), "M1");
  544 |     | 
  545 |     |         emit Mint(
  546 |     |             msg.sender,
  547 |     |             recipient,
  548 |     |             tickLower,
  549 |     |             tickUpper,
  550 |     |             amount,
  551 |     |             amount0,
  552 |     |             amount1
  553 |     |         );
  554 |     |     }
  555 |     | 
  556 |     |     /// @inheritdoc IUniswapV3PoolActions
  557 |     |     function collect(
  558 |     |         address recipient,
  559 |     |         int24 tickLower,
  560 |     |         int24 tickUpper,
  561 |     |         uint128 amount0Requested,
  562 |     |         uint128 amount1Requested
  563 |     |     ) external override lock returns (uint128 amount0, uint128 amount1) {
  564 |     |         // we don"t need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}
  565 |     |         Position.Info storage position = positions.get(
  566 |     |             msg.sender,
  567 |     |             tickLower,
  568 |     |             tickUpper
  569 |     |         );
  570 |     | 
  571 |     |         amount0 = amount0Requested > position.tokensOwed0
  572 |     |             ? position.tokensOwed0
  573 |     |             : amount0Requested;
  574 |     |         amount1 = amount1Requested > position.tokensOwed1
  575 |     |             ? position.tokensOwed1
  576 |     |             : amount1Requested;
  577 |     | 
  578 |     |         if (amount0 > 0) {
  579 |     |             position.tokensOwed0 -= amount0;
  580 |     |             TransferHelper.safeTransfer(token0, recipient, amount0);
  581 |     |         }
  582 |     |         if (amount1 > 0) {
  583 |     |             position.tokensOwed1 -= amount1;
  584 |     |             TransferHelper.safeTransfer(token1, recipient, amount1);
  585 |     |         }
  586 |     | 
  587 |     |         emit Collect(
  588 |     |             msg.sender,
  589 |     |             recipient,
  590 |     |             tickLower,
  591 |     |             tickUpper,
  592 |     |             amount0,
  593 |     |             amount1
  594 |     |         );
  595 |     |     }
  596 |     | 
  597 |     |     /// @inheritdoc IUniswapV3PoolActions
  598 |     |     /// @dev noDelegateCall is applied indirectly via _modifyPosition
  599 |     |     function burn(
  600 |     |         int24 tickLower,
  601 |     |         int24 tickUpper,
  602 |     |         uint128 amount
  603 |     |     ) external override lock returns (uint256 amount0, uint256 amount1) {
  604 |     |         (
  605 |     |             Position.Info storage position,
  606 |     |             int256 amount0Int,
  607 |     |             int256 amount1Int
  608 |     |         ) = _modifyPosition(
  609 |     |                 ModifyPositionParams({
  610 |     |                     owner: msg.sender,
  611 |     |                     tickLower: tickLower,
  612 |     |                     tickUpper: tickUpper,
  613 |     |                     liquidityDelta: -int256(amount).toInt128()
  614 |     |                 })
  615 |     |             );
  616 |     | 
  617 |     |         amount0 = uint256(-amount0Int);
  618 |     |         amount1 = uint256(-amount1Int);
  619 |     | 
  620 |     |         if (amount0 > 0 || amount1 > 0) {
  621 |     |             (position.tokensOwed0, position.tokensOwed1) = (
  622 |     |                 position.tokensOwed0 + uint128(amount0),
  623 |     |                 position.tokensOwed1 + uint128(amount1)
  624 |     |             );
  625 |     |         }
  626 |     | 
  627 |     |         emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);
  628 |     |     }
  629 |     | 
  630 |     |     struct SwapCache {
  631 |     |         // the protocol fee for the input token
  632 |     |         uint8 feeProtocol;
  633 |     |         // liquidity at the beginning of the swap
  634 |     |         uint128 liquidityStart;
  635 |     |         // the timestamp of the current block
  636 |     |         uint32 blockTimestamp;
  637 |     |         // the current value of the tick accumulator, computed only if we cross an initialized tick
  638 |     |         int56 tickCumulative;
  639 |     |         // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick
  640 |     |         uint160 secondsPerLiquidityCumulativeX128;
  641 |     |         // whether we"ve computed and cached the above two accumulators
  642 |     |         bool computedLatestObservation;
  643 |     |     }
  644 |     | 
  645 |     |     // the top level state of the swap, the results of which are recorded in storage at the end
  646 |     |     struct SwapState {
  647 |     |         // the amount remaining to be swapped in/out of the input/output asset
  648 |     |         int256 amountSpecifiedRemaining;
  649 |     |         // the amount already swapped out/in of the output/input asset
  650 |     |         int256 amountCalculated;
  651 |     |         // current sqrt(price)
  652 |     |         uint160 sqrtPriceX96;
  653 |     |         // the tick associated with the current price
  654 |     |         int24 tick;
  655 |     |         // the global fee growth of the input token
  656 |     |         uint256 feeGrowthGlobalX128;
  657 |     |         // amount of input token paid as protocol fee
  658 |     |         uint128 protocolFee;
  659 |     |         // the current liquidity in range
  660 |     |         uint128 liquidity;
  661 |     |     }
  662 |     | 
  663 |     |     struct StepComputations {
  664 |     |         // the price at the beginning of the step
  665 |     |         uint160 sqrtPriceStartX96;
  666 |     |         // the next tick to swap to from the current tick in the swap direction
  667 |     |         int24 tickNext;
  668 |     |         // whether tickNext is initialized or not
  669 |     |         bool initialized;
  670 |     |         // sqrt(price) for the next tick (1/0)
  671 |     |         uint160 sqrtPriceNextX96;
  672 |     |         // how much is being swapped in in this step
  673 |     |         uint256 amountIn;
  674 |     |         // how much is being swapped out
  675 |     |         uint256 amountOut;
  676 |     |         // how much fee is being paid in
  677 |     |         uint256 feeAmount;
  678 |     |     }
  679 |     | 
  680 |     |     /// @inheritdoc IUniswapV3PoolActions
  681 |     |     function swap(
  682 |     |         address recipient,
  683 |     |         bool zeroForOne,
  684 |     |         int256 amountSpecified,
  685 |     |         uint160 sqrtPriceLimitX96,
  686 |     |         bytes calldata data
  687 |     |     )
  688 |     |         external
  689 |     |         override
  690 |     |         noDelegateCall
  691 |     |         returns (int256 amount0, int256 amount1)
  692 |     |     {
  693 |     |         require(amountSpecified != 0, "AS");
  694 |     | 
  695 |     |         Slot0 memory slot0Start = slot0;
  696 |     | 
  697 |     |         require(slot0Start.unlocked, "LOK");
  698 |     |         require(
  699 |     |             zeroForOne
  700 |     |                 ? sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 &&
  701 |     |                     sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO
  702 |     |                 : sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 &&
  703 |     |                     sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,
  704 |     |             "SPL"
  705 |     |         );
  706 |     | 
  707 |     |         slot0.unlocked = false;
  708 |     | 
  709 |     |         SwapCache memory cache = SwapCache({
  710 |     |             liquidityStart: liquidity,
  711 |     |             blockTimestamp: _blockTimestamp(),
  712 |     |             feeProtocol: zeroForOne
  713 |     |                 ? (slot0Start.feeProtocol % 16)
  714 |     |                 : (slot0Start.feeProtocol >> 4),
  715 |     |             secondsPerLiquidityCumulativeX128: 0,
  716 |     |             tickCumulative: 0,
  717 |     |             computedLatestObservation: false
  718 |     |         });
  719 |     | 
  720 |     |         bool exactInput = amountSpecified > 0;
  721 |     | 
  722 |     |         SwapState memory state = SwapState({
  723 |     |             amountSpecifiedRemaining: amountSpecified,
  724 |     |             amountCalculated: 0,
  725 |     |             sqrtPriceX96: slot0Start.sqrtPriceX96,
  726 |     |             tick: slot0Start.tick,
  727 |     |             feeGrowthGlobalX128: zeroForOne
  728 |     |                 ? feeGrowthGlobal0X128
  729 |     |                 : feeGrowthGlobal1X128,
  730 |     |             protocolFee: 0,
  731 |     |             liquidity: cache.liquidityStart
  732 |     |         });
  733 |     | 
  734 |     |         // continue swapping as long as we haven"t used the entire input/output and haven"t reached the price limit
  735 |     |         while (
  736 |     |             state.amountSpecifiedRemaining != 0 &&
  737 |     |             state.sqrtPriceX96 != sqrtPriceLimitX96
  738 |     |         ) {
  739 |     |             StepComputations memory step;
  740 |     | 
  741 |     |             step.sqrtPriceStartX96 = state.sqrtPriceX96;
  742 |     | 
  743 |     |             (step.tickNext, step.initialized) = tickBitmap
  744 |     |                 .nextInitializedTickWithinOneWord(
  745 |     |                     state.tick,
  746 |     |                     tickSpacing,
  747 |     |                     zeroForOne
  748 |     |                 );
  749 |     | 
  750 |     |             // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds
  751 |     |             if (step.tickNext < TickMath.MIN_TICK) {
  752 |     |                 step.tickNext = TickMath.MIN_TICK;
  753 |     |             } else if (step.tickNext > TickMath.MAX_TICK) {
  754 |     |                 step.tickNext = TickMath.MAX_TICK;
  755 |     |             }
  756 |     | 
  757 |     |             // get the price for the next tick
  758 |     |             step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
  759 |     | 
  760 |     |             // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted
  761 |     |             (
  762 |     |                 state.sqrtPriceX96,
  763 |     |                 step.amountIn,
  764 |     |                 step.amountOut,
  765 |     |                 step.feeAmount
  766 |     |             ) = SwapMath.computeSwapStep(
  767 |     |                 state.sqrtPriceX96,
  768 |     |                 (
  769 |     |                     zeroForOne
  770 |     |                         ? step.sqrtPriceNextX96 < sqrtPriceLimitX96
  771 |     |                         : step.sqrtPriceNextX96 > sqrtPriceLimitX96
  772 |     |                 )
  773 |     |                     ? sqrtPriceLimitX96
  774 |     |                     : step.sqrtPriceNextX96,
  775 |     |                 state.liquidity,
  776 |     |                 state.amountSpecifiedRemaining,
  777 |     |                 fee
  778 |     |             );
  779 |     | 
  780 |     |             if (exactInput) {
  781 |     |                 state.amountSpecifiedRemaining -= (step.amountIn +
  782 |     |                     step.feeAmount).toInt256();
  783 |     |                 state.amountCalculated = state.amountCalculated.sub(
  784 |     |                     step.amountOut.toInt256()
  785 |     |                 );
  786 |     |             } else {
  787 |     |                 state.amountSpecifiedRemaining += step.amountOut.toInt256();
  788 |     |                 state.amountCalculated = state.amountCalculated.add(
  789 |     |                     (step.amountIn + step.feeAmount).toInt256()
  790 |     |                 );
  791 |     |             }
  792 |     | 
  793 |     |             // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee
  794 |     |             if (cache.feeProtocol > 0) {
  795 |     |                 uint256 delta = step.feeAmount / cache.feeProtocol;
  796 |     |                 step.feeAmount -= delta;
  797 |     |                 state.protocolFee += uint128(delta);
  798 |     |             }
  799 |     | 
  800 |     |             // update global fee tracker
  801 |     |             if (state.liquidity > 0)
  802 |     |                 state.feeGrowthGlobalX128 += FullMath.mulDiv(
  803 |     |                     step.feeAmount,
  804 |     |                     FixedPoint128.Q128,
  805 |     |                     state.liquidity
  806 |     |                 );
  807 |     | 
  808 |     |             // shift tick if we reached the next price
  809 |     |             if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {
  810 |     |                 // if the tick is initialized, run the tick transition
  811 |     |                 if (step.initialized) {
  812 |     |                     // check for the placeholder value, which we replace with the actual value the first time the swap
  813 |     |                     // crosses an initialized tick
  814 |     |                     if (!cache.computedLatestObservation) {
  815 |     |                         (
  816 |     |                             cache.tickCumulative,
  817 |     |                             cache.secondsPerLiquidityCumulativeX128
  818 |     |                         ) = observations.observeSingle(
  819 |     |                             cache.blockTimestamp,
  820 |     |                             0,
  821 |     |                             slot0Start.tick,
  822 |     |                             slot0Start.observationIndex,
  823 |     |                             cache.liquidityStart,
  824 |     |                             slot0Start.observationCardinality
  825 |     |                         );
  826 |     |                         cache.computedLatestObservation = true;
  827 |     |                     }
  828 |     |                     int128 liquidityNet = ticks.cross(
  829 |     |                         step.tickNext,
  830 |     |                         (
  831 |     |                             zeroForOne
  832 |     |                                 ? state.feeGrowthGlobalX128
  833 |     |                                 : feeGrowthGlobal0X128
  834 |     |                         ),
  835 |     |                         (
  836 |     |                             zeroForOne
  837 |     |                                 ? feeGrowthGlobal1X128
  838 |     |                                 : state.feeGrowthGlobalX128
  839 |     |                         ),
  840 |     |                         cache.secondsPerLiquidityCumulativeX128,
  841 |     |                         cache.tickCumulative,
  842 |     |                         cache.blockTimestamp
  843 |     |                     );
  844 |     |                     // if we"re moving leftward, we interpret liquidityNet as the opposite sign
  845 |     |                     // safe because liquidityNet cannot be type(int128).min
  846 |     |                     if (zeroForOne) liquidityNet = -liquidityNet;
  847 |     | 
  848 |     |                     state.liquidity = LiquidityMath.addDelta(
  849 |     |                         state.liquidity,
  850 |     |                         liquidityNet
  851 |     |                     );
  852 |     |                 }
  853 |     | 
  854 |     |                 state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
  855 |     |             } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {
  856 |     |                 // recompute unless we"re on a lower tick boundary (i.e. already transitioned ticks), and haven"t moved
  857 |     |                 state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
  858 |     |             }
  859 |     |         }
  860 |     | 
  861 |     |         // update tick and write an oracle entry if the tick change
  862 |     |         if (state.tick != slot0Start.tick) {
  863 |     |             (
  864 |     |                 uint16 observationIndex,
  865 |     |                 uint16 observationCardinality
  866 |     |             ) = observations.write(
  867 |     |                     slot0Start.observationIndex,
  868 |     |                     cache.blockTimestamp,
  869 |     |                     slot0Start.tick,
  870 |     |                     cache.liquidityStart,
  871 |     |                     slot0Start.observationCardinality,
  872 |     |                     slot0Start.observationCardinalityNext
  873 |     |                 );
  874 |     |             (
  875 |     |                 slot0.sqrtPriceX96,
  876 |     |                 slot0.tick,
  877 |     |                 slot0.observationIndex,
  878 |     |                 slot0.observationCardinality
  879 |     |             ) = (
  880 |     |                 state.sqrtPriceX96,
  881 |     |                 state.tick,
  882 |     |                 observationIndex,
  883 |     |                 observationCardinality
  884 |     |             );
  885 |     |         } else {
  886 |     |             // otherwise just update the price
  887 |     |             slot0.sqrtPriceX96 = state.sqrtPriceX96;
  888 |     |         }
  889 |     | 
  890 |     |         // update liquidity if it changed
  891 |     |         if (cache.liquidityStart != state.liquidity)
  892 |     |             liquidity = state.liquidity;
  893 |     | 
  894 |     |         // update fee growth global and, if necessary, protocol fees
  895 |     |         // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees
  896 |     |         if (zeroForOne) {
  897 |     |             feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;
  898 |     |             if (state.protocolFee > 0) protocolFees.token0 += state.protocolFee;
  899 |     |         } else {
  900 |     |             feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;
  901 |     |             if (state.protocolFee > 0) protocolFees.token1 += state.protocolFee;
  902 |     |         }
  903 |     | 
  904 |     |         (amount0, amount1) = zeroForOne == exactInput
  905 |     |             ? (
  906 |     |                 amountSpecified - state.amountSpecifiedRemaining,
  907 |     |                 state.amountCalculated
  908 |     |             )
  909 |     |             : (
  910 |     |                 state.amountCalculated,
  911 |     |                 amountSpecified - state.amountSpecifiedRemaining
  912 |     |             );
  913 |     | 
  914 |     |         // do the transfers and collect payment
  915 |     |         if (zeroForOne) {
  916 |     |             if (amount1 < 0)
  917 |     |                 TransferHelper.safeTransfer(
  918 |     |                     token1,
  919 |     |                     recipient,
  920 |     |                     uint256(-amount1)
  921 |     |                 );
  922 |     | 
  923 |     |             uint256 balance0Before = balance0();
  924 |     |             IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
  925 |     |                 amount0,
  926 |     |                 amount1,
  927 |     |                 data
  928 |     |             );
  929 |     |             require(balance0Before.add(uint256(amount0)) <= balance0(), "IIA");
  930 |     |         } else {
  931 |     |             if (amount0 < 0)
  932 |     |                 TransferHelper.safeTransfer(
  933 |     |                     token0,
  934 |     |                     recipient,
  935 |     |                     uint256(-amount0)
  936 |     |                 );
  937 |     | 
  938 |     |             uint256 balance1Before = balance1();
  939 |     |             IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(
  940 |     |                 amount0,
  941 |     |                 amount1,
  942 |     |                 data
  943 |     |             );
  944 |     |             require(balance1Before.add(uint256(amount1)) <= balance1(), "IIA");
  945 |     |         }
  946 |     | 
  947 |     |         emit Swap(
  948 |     |             msg.sender,
  949 |     |             recipient,
  950 |     |             amount0,
  951 |     |             amount1,
  952 |     |             state.sqrtPriceX96,
  953 |     |             state.liquidity,
  954 |     |             state.tick
  955 |     |         );
  956 |     |         slot0.unlocked = true;
  957 |     |     }
  958 |     | 
  959 |     |     /// @inheritdoc IUniswapV3PoolActions
  960 |     |     function flash(
  961 |     |         address recipient,
  962 |     |         uint256 amount0,
  963 |     |         uint256 amount1,
  964 |     |         bytes calldata data
  965 |     |     ) external override lock noDelegateCall {
  966 |     |         uint128 _liquidity = liquidity;
  967 |     |         require(_liquidity > 0, "L");
  968 |     | 
  969 |     |         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);
  970 |     |         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);
  971 |     |         uint256 balance0Before = balance0();
  972 |     |         uint256 balance1Before = balance1();
  973 |     | 
  974 |     |         if (amount0 > 0)
  975 |     |             TransferHelper.safeTransfer(token0, recipient, amount0);
  976 |     |         if (amount1 > 0)
  977 |     |             TransferHelper.safeTransfer(token1, recipient, amount1);
  978 |     | 
  979 |     |         IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(
  980 |     |             fee0,
  981 |     |             fee1,
  982 |     |             data
  983 |     |         );
  984 |     | 
  985 |     |         uint256 balance0After = balance0();
  986 |     |         uint256 balance1After = balance1();
  987 |     | 
  988 |     |         require(balance0Before.add(fee0) <= balance0After, "F0");
  989 |     |         require(balance1Before.add(fee1) <= balance1After, "F1");
  990 |     | 
  991 |     |         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee
  992 |     |         uint256 paid0 = balance0After - balance0Before;
  993 |     |         uint256 paid1 = balance1After - balance1Before;
  994 |     | 
  995 |     |         if (paid0 > 0) {
  996 |     |             uint8 feeProtocol0 = slot0.feeProtocol % 16;
  997 |     |             uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;
  998 |     |             if (uint128(fees0) > 0) protocolFees.token0 += uint128(fees0);
  999 |     |             feeGrowthGlobal0X128 += FullMath.mulDiv(
 1000 |     |                 paid0 - fees0,
 1001 |     |                 FixedPoint128.Q128,
 1002 |     |                 _liquidity
 1003 |     |             );
 1004 |     |         }
 1005 |     |         if (paid1 > 0) {
 1006 |     |             uint8 feeProtocol1 = slot0.feeProtocol >> 4;
 1007 |     |             uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;
 1008 |     |             if (uint128(fees1) > 0) protocolFees.token1 += uint128(fees1);
 1009 |     |             feeGrowthGlobal1X128 += FullMath.mulDiv(
 1010 |     |                 paid1 - fees1,
 1011 |     |                 FixedPoint128.Q128,
 1012 |     |                 _liquidity
 1013 |     |             );
 1014 |     |         }
 1015 |     | 
 1016 |     |         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);
 1017 |     |     }
 1018 |     | 
 1019 |     |     /// @inheritdoc IUniswapV3PoolOwnerActions
 1020 |     |     function setFeeProtocol(
 1021 |     |         uint8 feeProtocol0,
 1022 |     |         uint8 feeProtocol1
 1023 |     |     ) external override lock onlyFactoryOwner {
 1024 |     |         require(
 1025 |     |             (feeProtocol0 == 0 || (feeProtocol0 >= 4 && feeProtocol0 <= 10)) &&
 1026 |     |                 (feeProtocol1 == 0 || (feeProtocol1 >= 4 && feeProtocol1 <= 10))
 1027 |     |         );
 1028 |     |         uint8 feeProtocolOld = slot0.feeProtocol;
 1029 |     |         slot0.feeProtocol = feeProtocol0 + (feeProtocol1 << 4);
 1030 |     |         emit SetFeeProtocol(
 1031 |     |             feeProtocolOld % 16,
 1032 |     |             feeProtocolOld >> 4,
 1033 |     |             feeProtocol0,
 1034 |     |             feeProtocol1
 1035 |     |         );
 1036 |     |     }
 1037 |     | 
 1038 |     |     /// @inheritdoc IUniswapV3PoolOwnerActions
 1039 |     |     function collectProtocol(
 1040 |     |         address recipient,
 1041 |     |         uint128 amount0Requested,
 1042 |     |         uint128 amount1Requested
 1043 |     |     )
 1044 |     |         external
 1045 |     |         override
 1046 |     |         lock
 1047 |     |         onlyFactoryOwner
 1048 |     |         returns (uint128 amount0, uint128 amount1)
 1049 |     |     {
 1050 |     |         amount0 = amount0Requested > protocolFees.token0
 1051 |     |             ? protocolFees.token0
 1052 |     |             : amount0Requested;
 1053 |     |         amount1 = amount1Requested > protocolFees.token1
 1054 |     |             ? protocolFees.token1
 1055 |     |             : amount1Requested;
 1056 |     | 
 1057 |     |         if (amount0 > 0) {
 1058 |     |             if (amount0 == protocolFees.token0) amount0--; // ensure that the slot is not cleared, for gas savings
 1059 |     |             protocolFees.token0 -= amount0;
 1060 |     |             TransferHelper.safeTransfer(token0, recipient, amount0);
 1061 |     |         }
 1062 |     |         if (amount1 > 0) {
 1063 |     |             if (amount1 == protocolFees.token1) amount1--; // ensure that the slot is not cleared, for gas savings
 1064 |     |             protocolFees.token1 -= amount1;
 1065 |     |             TransferHelper.safeTransfer(token1, recipient, amount1);
 1066 |     |         }
 1067 |     | 
 1068 |     |         emit CollectProtocol(msg.sender, recipient, amount0, amount1);
 1069 |     |     }
 1070 |     | }
 1071 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/UniswapV3PoolDeployer.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity =0.7.6;
  3 |     | 
  4 |     | import "./interfaces/IUniswapV3PoolDeployer.sol";
  5 |     | 
  6 |     | import "./UniswapV3Pool.sol";
  7 |     | 
  8 |     | contract UniswapV3PoolDeployer is IUniswapV3PoolDeployer {
  9 |     |     struct Parameters {
 10 |     |         address factory;
 11 |     |         address token0;
 12 |     |         address token1;
 13 |     |         uint24 fee;
 14 |     |         int24 tickSpacing;
 15 |     |     }
 16 |     | 
 17 |     |     /// @inheritdoc IUniswapV3PoolDeployer
 18 | *r  |     Parameters public override parameters;
 19 |     | 
 20 |     |     /// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then
 21 |     |     /// clearing it after deploying the pool.
 22 |     |     /// @param factory The contract address of the Uniswap V3 factory
 23 |     |     /// @param token0 The first token of the pool by address sort order
 24 |     |     /// @param token1 The second token of the pool by address sort order
 25 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 26 |     |     /// @param tickSpacing The spacing between usable ticks
 27 | *r  |     function deploy(
 28 |     |         address factory,
 29 |     |         address token0,
 30 |     |         address token1,
 31 |     |         uint24 fee,
 32 |     |         int24 tickSpacing
 33 | *r  |     ) internal returns (address pool) {
 34 | *r  |         parameters = Parameters({factory: factory, token0: token0, token1: token1, fee: fee, tickSpacing: tickSpacing});
 35 | *r  |         pool = address(new UniswapV3Pool{salt: keccak256(abi.encode(token0, token1, fee))}());
 36 | *r  |         delete parameters;
 37 |     |     }
 38 |     | }
 39 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/WETH.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.4.0 <0.8.0;
  3 | *r  | 
  4 |     | contract WETH9 {
  5 | *r  |     string public name     = "Wrapped Ether";
  6 | *   |     string public symbol   = "WETH";
  7 | *r  |     uint8  public decimals = 18;
  8 |     | 
  9 |     |     event  Approval(address indexed src, address indexed guy, uint wad);
 10 |     |     event  Transfer(address indexed src, address indexed dst, uint wad);
 11 |     |     event  Deposit(address indexed dst, uint wad);
 12 |     |     event  Withdrawal(address indexed src, uint wad);
 13 |     | 
 14 | *r  |     mapping (address => uint)                       public  balanceOf;
 15 | *r  |     mapping (address => mapping (address => uint))  public  allowance;
 16 |     | 
 17 |     |     // function() public payable {
 18 |     |     //     deposit();
 19 |     |     // }
 20 | *   |     function deposit() public payable {
 21 | *   |         balanceOf[msg.sender] += msg.value;
 22 | *   |         Deposit(msg.sender, msg.value);
 23 |     |     }
 24 | *r  |     function withdraw(uint wad) public {
 25 | *r  |         require(balanceOf[msg.sender] >= wad);
 26 | *   |         balanceOf[msg.sender] -= wad;
 27 | *   |         msg.sender.transfer(wad);
 28 | *   |         Withdrawal(msg.sender, wad);
 29 |     |     }
 30 |     | 
 31 | *r  |     function totalSupply() public view returns (uint) {
 32 | *   |         return address(this).balance;
 33 |     |     }
 34 |     | 
 35 | *   |     function approve(address guy, uint wad) public returns (bool) {
 36 | *   |         allowance[msg.sender][guy] = wad;
 37 | *   |         Approval(msg.sender, guy, wad);
 38 | *   |         return true;
 39 |     |     }
 40 |     | 
 41 | *r  |     function transfer(address dst, uint wad) public returns (bool) {
 42 | *r  |         return transferFrom(msg.sender, dst, wad);
 43 |     |     }
 44 |     | 
 45 | *r  |     function transferFrom(address src, address dst, uint wad)
 46 |     |         public
 47 | *r  |         returns (bool)
 48 |     |     {
 49 | *r  |         require(balanceOf[src] >= wad);
 50 |     | 
 51 | *   |         if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
 52 | *   |             require(allowance[src][msg.sender] >= wad);
 53 | *   |             allowance[src][msg.sender] -= wad;
 54 |     |         }
 55 |     | 
 56 | *   |         balanceOf[src] -= wad;
 57 | *   |         balanceOf[dst] += wad;
 58 |     | 
 59 | *   |         Transfer(src, dst, wad);
 60 |     | 
 61 | *   |         return true;
 62 |     |     }
 63 |     | }
 64 |     | 
 65 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/IERC20Minimal.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Minimal ERC20 interface for Uniswap
  5 |     | /// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3
  6 |     | interface IERC20Minimal {
  7 |     |     /// @notice Returns the balance of a token
  8 |     |     /// @param account The account for which to look up the number of tokens it has, i.e. its balance
  9 |     |     /// @return The number of tokens held by the account
 10 |     |     function balanceOf(address account) external view returns (uint256);
 11 |     | 
 12 |     |     /// @notice Transfers the amount of token from the `msg.sender` to the recipient
 13 |     |     /// @param recipient The account that will receive the amount transferred
 14 |     |     /// @param amount The number of tokens to send from the sender to the recipient
 15 |     |     /// @return Returns true for a successful transfer, false for an unsuccessful transfer
 16 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 17 |     | 
 18 |     |     /// @notice Returns the current allowance given to a spender by an owner
 19 |     |     /// @param owner The account of the token owner
 20 |     |     /// @param spender The account of the token spender
 21 |     |     /// @return The current allowance granted by `owner` to `spender`
 22 |     |     function allowance(address owner, address spender) external view returns (uint256);
 23 |     | 
 24 |     |     /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`
 25 |     |     /// @param spender The account which will be allowed to spend a given amount of the owners tokens
 26 |     |     /// @param amount The amount of tokens allowed to be used by `spender`
 27 |     |     /// @return Returns true for a successful approval, false for unsuccessful
 28 |     |     function approve(address spender, uint256 amount) external returns (bool);
 29 |     | 
 30 |     |     /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`
 31 |     |     /// @param sender The account from which the transfer will be initiated
 32 |     |     /// @param recipient The recipient of the transfer
 33 |     |     /// @param amount The amount of the transfer
 34 |     |     /// @return Returns true for a successful transfer, false for unsuccessful
 35 |     |     function transferFrom(
 36 |     |         address sender,
 37 |     |         address recipient,
 38 |     |         uint256 amount
 39 |     |     ) external returns (bool);
 40 |     | 
 41 |     |     /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.
 42 |     |     /// @param from The account from which the tokens were sent, i.e. the balance decreased
 43 |     |     /// @param to The account to which the tokens were sent, i.e. the balance increased
 44 |     |     /// @param value The amount of tokens that were transferred
 45 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 46 |     | 
 47 |     |     /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.
 48 |     |     /// @param owner The account that approved spending of its tokens
 49 |     |     /// @param spender The account for which the spending allowance was modified
 50 |     |     /// @param value The new allowance from the owner to the spender
 51 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 52 |     | }
 53 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/IUniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title The interface for the Uniswap V3 Factory
  5 |     | /// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
  6 |     | interface IUniswapV3Factory {
  7 |     |     /// @notice Emitted when the owner of the factory is changed
  8 |     |     /// @param oldOwner The owner before the owner was changed
  9 |     |     /// @param newOwner The owner after the owner was changed
 10 |     |     event OwnerChanged(address indexed oldOwner, address indexed newOwner);
 11 |     | 
 12 |     |     /// @notice Emitted when a pool is created
 13 |     |     /// @param token0 The first token of the pool by address sort order
 14 |     |     /// @param token1 The second token of the pool by address sort order
 15 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 16 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks
 17 |     |     /// @param pool The address of the created pool
 18 |     |     event PoolCreated(
 19 |     |         address indexed token0,
 20 |     |         address indexed token1,
 21 |     |         uint24 indexed fee,
 22 |     |         int24 tickSpacing,
 23 |     |         address pool
 24 |     |     );
 25 |     | 
 26 |     |     /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
 27 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip
 28 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
 29 |     |     event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
 30 |     | 
 31 |     |     /// @notice Returns the current owner of the factory
 32 |     |     /// @dev Can be changed by the current owner via setOwner
 33 |     |     /// @return The address of the factory owner
 34 |     |     function owner() external view returns (address);
 35 |     | 
 36 |     |     /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
 37 |     |     /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
 38 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
 39 |     |     /// @return The tick spacing
 40 |     |     function feeAmountTickSpacing(uint24 fee) external view returns (int24);
 41 |     | 
 42 |     |     /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
 43 |     |     /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
 44 |     |     /// @param tokenA The contract address of either token0 or token1
 45 |     |     /// @param tokenB The contract address of the other token
 46 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 47 |     |     /// @return pool The pool address
 48 |     |     function getPool(
 49 |     |         address tokenA,
 50 |     |         address tokenB,
 51 |     |         uint24 fee
 52 |     |     ) external view returns (address pool);
 53 |     | 
 54 |     |     /// @notice Creates a pool for the given two tokens and fee
 55 |     |     /// @param tokenA One of the two tokens in the desired pool
 56 |     |     /// @param tokenB The other of the two tokens in the desired pool
 57 |     |     /// @param fee The desired fee for the pool
 58 |     |     /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
 59 |     |     /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
 60 |     |     /// are invalid.
 61 |     |     /// @return pool The address of the newly created pool
 62 |     |     function createPool(
 63 |     |         address tokenA,
 64 |     |         address tokenB,
 65 |     |         uint24 fee
 66 |     |     ) external returns (address pool);
 67 |     | 
 68 |     |     /// @notice Updates the owner of the factory
 69 |     |     /// @dev Must be called by the current owner
 70 |     |     /// @param _owner The new owner of the factory
 71 |     |     function setOwner(address _owner) external;
 72 |     | 
 73 |     |     /// @notice Enables a fee amount with the given tickSpacing
 74 |     |     /// @dev Fee amounts may never be removed once enabled
 75 |     |     /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
 76 |     |     /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
 77 |     |     function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
 78 |     | }
 79 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | import "./pool/IUniswapV3PoolImmutables.sol";
  5 |     | import "./pool/IUniswapV3PoolState.sol";
  6 |     | import "./pool/IUniswapV3PoolDerivedState.sol";
  7 |     | import "./pool/IUniswapV3PoolActions.sol";
  8 |     | import "./pool/IUniswapV3PoolOwnerActions.sol";
  9 |     | import "./pool/IUniswapV3PoolEvents.sol";
 10 |     | 
 11 |     | /// @title The interface for a Uniswap V3 Pool
 12 |     | /// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
 13 |     | /// to the ERC20 specification
 14 |     | /// @dev The pool interface is broken up into many smaller pieces
 15 |     | interface IUniswapV3Pool is
 16 |     |     IUniswapV3PoolImmutables,
 17 |     |     IUniswapV3PoolState,
 18 |     |     IUniswapV3PoolDerivedState,
 19 |     |     IUniswapV3PoolActions,
 20 |     |     IUniswapV3PoolOwnerActions,
 21 |     |     IUniswapV3PoolEvents
 22 |     | {
 23 |     | 
 24 |     | }
 25 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/IUniswapV3PoolDeployer.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title An interface for a contract that is capable of deploying Uniswap V3 Pools
  5 |     | /// @notice A contract that constructs a pool must implement this to pass arguments to the pool
  6 |     | /// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash
  7 |     | /// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain
  8 |     | interface IUniswapV3PoolDeployer {
  9 |     |     /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.
 10 |     |     /// @dev Called by the pool constructor to fetch the parameters of the pool
 11 |     |     /// Returns factory The factory address
 12 |     |     /// Returns token0 The first token of the pool by address sort order
 13 |     |     /// Returns token1 The second token of the pool by address sort order
 14 |     |     /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 15 |     |     /// Returns tickSpacing The minimum number of ticks between initialized ticks
 16 |     |     function parameters()
 17 |     |         external
 18 |     |         view
 19 |     |         returns (
 20 |     |             address factory,
 21 |     |             address token0,
 22 |     |             address token1,
 23 |     |             uint24 fee,
 24 |     |             int24 tickSpacing
 25 |     |         );
 26 |     | }
 27 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/callback/IUniswapV3FlashCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#flash
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface
  6 |     | interface IUniswapV3FlashCallback {
  7 |     |     /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.
  8 |     |     /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// @param fee0 The fee amount in token0 due to the pool by the end of the flash
 11 |     |     /// @param fee1 The fee amount in token1 due to the pool by the end of the flash
 12 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call
 13 |     |     function uniswapV3FlashCallback(
 14 |     |         uint256 fee0,
 15 |     |         uint256 fee1,
 16 |     |         bytes calldata data
 17 |     |     ) external;
 18 |     | }
 19 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/callback/IUniswapV3MintCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#mint
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface
  6 |     | interface IUniswapV3MintCallback {
  7 |     |     /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity
 11 |     |     /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity
 12 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call
 13 |     |     function uniswapV3MintCallback(
 14 |     |         uint256 amount0Owed,
 15 |     |         uint256 amount1Owed,
 16 |     |         bytes calldata data
 17 |     |     ) external;
 18 |     | }
 19 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/callback/IUniswapV3SwapCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#swap
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface
  6 |     | interface IUniswapV3SwapCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 11 |     |     /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by
 12 |     |     /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.
 13 |     |     /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by
 14 |     |     /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.
 15 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call
 16 |     |     function uniswapV3SwapCallback(
 17 |     |         int256 amount0Delta,
 18 |     |         int256 amount1Delta,
 19 |     |         bytes calldata data
 20 |     |     ) external;
 21 |     | }
 22 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolActions.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Permissionless pool actions
   5 |     | /// @notice Contains pool methods that can be called by anyone
   6 |     | interface IUniswapV3PoolActions {
   7 |     |     /// @notice Sets the initial price for the pool
   8 |     |     /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
   9 |     |     /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
  10 |     |     function initialize(uint160 sqrtPriceX96) external;
  11 |     | 
  12 |     |     /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
  13 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
  14 |     |     /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
  15 |     |     /// on tickLower, tickUpper, the amount of liquidity, and the current price.
  16 |     |     /// @param recipient The address for which the liquidity will be created
  17 |     |     /// @param tickLower The lower tick of the position in which to add liquidity
  18 |     |     /// @param tickUpper The upper tick of the position in which to add liquidity
  19 |     |     /// @param amount The amount of liquidity to mint
  20 |     |     /// @param data Any data that should be passed through to the callback
  21 |     |     /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
  22 |     |     /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
  23 |     |     function mint(
  24 |     |         address recipient,
  25 |     |         int24 tickLower,
  26 |     |         int24 tickUpper,
  27 |     |         uint128 amount,
  28 |     |         bytes calldata data
  29 |     |     ) external returns (uint256 amount0, uint256 amount1);
  30 |     | 
  31 |     |     /// @notice Collects tokens owed to a position
  32 |     |     /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
  33 |     |     /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
  34 |     |     /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
  35 |     |     /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
  36 |     |     /// @param recipient The address which should receive the fees collected
  37 |     |     /// @param tickLower The lower tick of the position for which to collect fees
  38 |     |     /// @param tickUpper The upper tick of the position for which to collect fees
  39 |     |     /// @param amount0Requested How much token0 should be withdrawn from the fees owed
  40 |     |     /// @param amount1Requested How much token1 should be withdrawn from the fees owed
  41 |     |     /// @return amount0 The amount of fees collected in token0
  42 |     |     /// @return amount1 The amount of fees collected in token1
  43 |     |     function collect(
  44 |     |         address recipient,
  45 |     |         int24 tickLower,
  46 |     |         int24 tickUpper,
  47 |     |         uint128 amount0Requested,
  48 |     |         uint128 amount1Requested
  49 |     |     ) external returns (uint128 amount0, uint128 amount1);
  50 |     | 
  51 |     |     /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
  52 |     |     /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
  53 |     |     /// @dev Fees must be collected separately via a call to #collect
  54 |     |     /// @param tickLower The lower tick of the position for which to burn liquidity
  55 |     |     /// @param tickUpper The upper tick of the position for which to burn liquidity
  56 |     |     /// @param amount How much liquidity to burn
  57 |     |     /// @return amount0 The amount of token0 sent to the recipient
  58 |     |     /// @return amount1 The amount of token1 sent to the recipient
  59 |     |     function burn(
  60 |     |         int24 tickLower,
  61 |     |         int24 tickUpper,
  62 |     |         uint128 amount
  63 |     |     ) external returns (uint256 amount0, uint256 amount1);
  64 |     | 
  65 |     |     /// @notice Swap token0 for token1, or token1 for token0
  66 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
  67 |     |     /// @param recipient The address to receive the output of the swap
  68 |     |     /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
  69 |     |     /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
  70 |     |     /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
  71 |     |     /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
  72 |     |     /// @param data Any data to be passed through to the callback
  73 |     |     /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
  74 |     |     /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
  75 |     |     function swap(
  76 |     |         address recipient,
  77 |     |         bool zeroForOne,
  78 |     |         int256 amountSpecified,
  79 |     |         uint160 sqrtPriceLimitX96,
  80 |     |         bytes calldata data
  81 |     |     ) external returns (int256 amount0, int256 amount1);
  82 |     | 
  83 |     |     /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
  84 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
  85 |     |     /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
  86 |     |     /// with 0 amount{0,1} and sending the donation amount(s) from the callback
  87 |     |     /// @param recipient The address which will receive the token0 and token1 amounts
  88 |     |     /// @param amount0 The amount of token0 to send
  89 |     |     /// @param amount1 The amount of token1 to send
  90 |     |     /// @param data Any data to be passed through to the callback
  91 |     |     function flash(
  92 |     |         address recipient,
  93 |     |         uint256 amount0,
  94 |     |         uint256 amount1,
  95 |     |         bytes calldata data
  96 |     |     ) external;
  97 |     | 
  98 |     |     /// @notice Increase the maximum number of price and liquidity observations that this pool will store
  99 |     |     /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
 100 |     |     /// the input observationCardinalityNext.
 101 |     |     /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
 102 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
 103 |     | }
 104 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolDerivedState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Pool state that is not stored
  5 |     | /// @notice Contains view functions to provide information about the pool that is computed rather than stored on the
  6 |     | /// blockchain. The functions here may have variable gas costs.
  7 |     | interface IUniswapV3PoolDerivedState {
  8 |     |     /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
  9 |     |     /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
 10 |     |     /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
 11 |     |     /// you must call it with secondsAgos = [3600, 0].
 12 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 13 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 14 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 15 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 16 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 17 |     |     /// timestamp
 18 |     |     function observe(uint32[] calldata secondsAgos)
 19 |     |         external
 20 |     |         view
 21 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
 22 |     | 
 23 |     |     /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range
 24 |     |     /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
 25 |     |     /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
 26 |     |     /// snapshot is taken and the second snapshot is taken.
 27 |     |     /// @param tickLower The lower tick of the range
 28 |     |     /// @param tickUpper The upper tick of the range
 29 |     |     /// @return tickCumulativeInside The snapshot of the tick accumulator for the range
 30 |     |     /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range
 31 |     |     /// @return secondsInside The snapshot of seconds per liquidity for the range
 32 |     |     function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
 33 |     |         external
 34 |     |         view
 35 |     |         returns (
 36 |     |             int56 tickCumulativeInside,
 37 |     |             uint160 secondsPerLiquidityInsideX128,
 38 |     |             uint32 secondsInside
 39 |     |         );
 40 |     | }
 41 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolEvents.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Events emitted by a pool
   5 |     | /// @notice Contains all events emitted by the pool
   6 |     | interface IUniswapV3PoolEvents {
   7 |     |     /// @notice Emitted exactly once by a pool when #initialize is first called on the pool
   8 |     |     /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize
   9 |     |     /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96
  10 |     |     /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool
  11 |     |     event Initialize(uint160 sqrtPriceX96, int24 tick);
  12 |     | 
  13 |     |     /// @notice Emitted when liquidity is minted for a given position
  14 |     |     /// @param sender The address that minted the liquidity
  15 |     |     /// @param owner The owner of the position and recipient of any minted liquidity
  16 |     |     /// @param tickLower The lower tick of the position
  17 |     |     /// @param tickUpper The upper tick of the position
  18 |     |     /// @param amount The amount of liquidity minted to the position range
  19 |     |     /// @param amount0 How much token0 was required for the minted liquidity
  20 |     |     /// @param amount1 How much token1 was required for the minted liquidity
  21 |     |     event Mint(
  22 |     |         address sender,
  23 |     |         address indexed owner,
  24 |     |         int24 indexed tickLower,
  25 |     |         int24 indexed tickUpper,
  26 |     |         uint128 amount,
  27 |     |         uint256 amount0,
  28 |     |         uint256 amount1
  29 |     |     );
  30 |     | 
  31 |     |     /// @notice Emitted when fees are collected by the owner of a position
  32 |     |     /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees
  33 |     |     /// @param owner The owner of the position for which fees are collected
  34 |     |     /// @param tickLower The lower tick of the position
  35 |     |     /// @param tickUpper The upper tick of the position
  36 |     |     /// @param amount0 The amount of token0 fees collected
  37 |     |     /// @param amount1 The amount of token1 fees collected
  38 |     |     event Collect(
  39 |     |         address indexed owner,
  40 |     |         address recipient,
  41 |     |         int24 indexed tickLower,
  42 |     |         int24 indexed tickUpper,
  43 |     |         uint128 amount0,
  44 |     |         uint128 amount1
  45 |     |     );
  46 |     | 
  47 |     |     /// @notice Emitted when a position's liquidity is removed
  48 |     |     /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect
  49 |     |     /// @param owner The owner of the position for which liquidity is removed
  50 |     |     /// @param tickLower The lower tick of the position
  51 |     |     /// @param tickUpper The upper tick of the position
  52 |     |     /// @param amount The amount of liquidity to remove
  53 |     |     /// @param amount0 The amount of token0 withdrawn
  54 |     |     /// @param amount1 The amount of token1 withdrawn
  55 |     |     event Burn(
  56 |     |         address indexed owner,
  57 |     |         int24 indexed tickLower,
  58 |     |         int24 indexed tickUpper,
  59 |     |         uint128 amount,
  60 |     |         uint256 amount0,
  61 |     |         uint256 amount1
  62 |     |     );
  63 |     | 
  64 |     |     /// @notice Emitted by the pool for any swaps between token0 and token1
  65 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  66 |     |     /// @param recipient The address that received the output of the swap
  67 |     |     /// @param amount0 The delta of the token0 balance of the pool
  68 |     |     /// @param amount1 The delta of the token1 balance of the pool
  69 |     |     /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96
  70 |     |     /// @param liquidity The liquidity of the pool after the swap
  71 |     |     /// @param tick The log base 1.0001 of price of the pool after the swap
  72 |     |     event Swap(
  73 |     |         address indexed sender,
  74 |     |         address indexed recipient,
  75 |     |         int256 amount0,
  76 |     |         int256 amount1,
  77 |     |         uint160 sqrtPriceX96,
  78 |     |         uint128 liquidity,
  79 |     |         int24 tick
  80 |     |     );
  81 |     | 
  82 |     |     /// @notice Emitted by the pool for any flashes of token0/token1
  83 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  84 |     |     /// @param recipient The address that received the tokens from flash
  85 |     |     /// @param amount0 The amount of token0 that was flashed
  86 |     |     /// @param amount1 The amount of token1 that was flashed
  87 |     |     /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee
  88 |     |     /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee
  89 |     |     event Flash(
  90 |     |         address indexed sender,
  91 |     |         address indexed recipient,
  92 |     |         uint256 amount0,
  93 |     |         uint256 amount1,
  94 |     |         uint256 paid0,
  95 |     |         uint256 paid1
  96 |     |     );
  97 |     | 
  98 |     |     /// @notice Emitted by the pool for increases to the number of observations that can be stored
  99 |     |     /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index
 100 |     |     /// just before a mint/swap/burn.
 101 |     |     /// @param observationCardinalityNextOld The previous value of the next observation cardinality
 102 |     |     /// @param observationCardinalityNextNew The updated value of the next observation cardinality
 103 |     |     event IncreaseObservationCardinalityNext(
 104 |     |         uint16 observationCardinalityNextOld,
 105 |     |         uint16 observationCardinalityNextNew
 106 |     |     );
 107 |     | 
 108 |     |     /// @notice Emitted when the protocol fee is changed by the pool
 109 |     |     /// @param feeProtocol0Old The previous value of the token0 protocol fee
 110 |     |     /// @param feeProtocol1Old The previous value of the token1 protocol fee
 111 |     |     /// @param feeProtocol0New The updated value of the token0 protocol fee
 112 |     |     /// @param feeProtocol1New The updated value of the token1 protocol fee
 113 |     |     event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
 114 |     | 
 115 |     |     /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner
 116 |     |     /// @param sender The address that collects the protocol fees
 117 |     |     /// @param recipient The address that receives the collected protocol fees
 118 |     |     /// @param amount0 The amount of token0 protocol fees that is withdrawn
 119 |     |     /// @param amount0 The amount of token1 protocol fees that is withdrawn
 120 |     |     event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
 121 |     | }
 122 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolImmutables.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Pool state that never changes
  5 |     | /// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
  6 |     | interface IUniswapV3PoolImmutables {
  7 |     |     /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
  8 |     |     /// @return The contract address
  9 |     |     function factory() external view returns (address);
 10 |     | 
 11 |     |     /// @notice The first of the two tokens of the pool, sorted by address
 12 |     |     /// @return The token contract address
 13 |     |     function token0() external view returns (address);
 14 |     | 
 15 |     |     /// @notice The second of the two tokens of the pool, sorted by address
 16 |     |     /// @return The token contract address
 17 |     |     function token1() external view returns (address);
 18 |     | 
 19 |     |     /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
 20 |     |     /// @return The fee
 21 |     |     function fee() external view returns (uint24);
 22 |     | 
 23 |     |     /// @notice The pool tick spacing
 24 |     |     /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
 25 |     |     /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
 26 |     |     /// This value is an int24 to avoid casting even though it is always positive.
 27 |     |     /// @return The tick spacing
 28 |     |     function tickSpacing() external view returns (int24);
 29 |     | 
 30 |     |     /// @notice The maximum amount of position liquidity that can use any tick in the range
 31 |     |     /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
 32 |     |     /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
 33 |     |     /// @return The max amount of liquidity per tick
 34 |     |     function maxLiquidityPerTick() external view returns (uint128);
 35 |     | }
 36 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolOwnerActions.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Permissioned pool actions
  5 |     | /// @notice Contains pool methods that may only be called by the factory owner
  6 |     | interface IUniswapV3PoolOwnerActions {
  7 |     |     /// @notice Set the denominator of the protocol's % share of the fees
  8 |     |     /// @param feeProtocol0 new protocol fee for token0 of the pool
  9 |     |     /// @param feeProtocol1 new protocol fee for token1 of the pool
 10 |     |     function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
 11 |     | 
 12 |     |     /// @notice Collect the protocol fee accrued to the pool
 13 |     |     /// @param recipient The address to which collected protocol fees should be sent
 14 |     |     /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1
 15 |     |     /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0
 16 |     |     /// @return amount0 The protocol fee collected in token0
 17 |     |     /// @return amount1 The protocol fee collected in token1
 18 |     |     function collectProtocol(
 19 |     |         address recipient,
 20 |     |         uint128 amount0Requested,
 21 |     |         uint128 amount1Requested
 22 |     |     ) external returns (uint128 amount0, uint128 amount1);
 23 |     | }
 24 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/interfaces/pool/IUniswapV3PoolState.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | /// @title Pool state that can change
   5 |     | /// @notice These methods compose the pool's state, and can change with any frequency including multiple times
   6 |     | /// per transaction
   7 |     | interface IUniswapV3PoolState {
   8 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
   9 |     |     /// when accessed externally.
  10 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
  11 |     |     /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
  12 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
  13 |     |     /// boundary.
  14 |     |     /// observationIndex The index of the last oracle observation that was written,
  15 |     |     /// observationCardinality The current maximum number of observations stored in the pool,
  16 |     |     /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
  17 |     |     /// feeProtocol The protocol fee for both tokens of the pool.
  18 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
  19 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
  20 |     |     /// unlocked Whether the pool is currently locked to reentrancy
  21 |     |     function slot0()
  22 |     |         external
  23 |     |         view
  24 |     |         returns (
  25 |     |             uint160 sqrtPriceX96,
  26 |     |             int24 tick,
  27 |     |             uint16 observationIndex,
  28 |     |             uint16 observationCardinality,
  29 |     |             uint16 observationCardinalityNext,
  30 |     |             uint8 feeProtocol,
  31 |     |             bool unlocked
  32 |     |         );
  33 |     | 
  34 |     |     /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
  35 |     |     /// @dev This value can overflow the uint256
  36 |     |     function feeGrowthGlobal0X128() external view returns (uint256);
  37 |     | 
  38 |     |     /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
  39 |     |     /// @dev This value can overflow the uint256
  40 |     |     function feeGrowthGlobal1X128() external view returns (uint256);
  41 |     | 
  42 |     |     /// @notice The amounts of token0 and token1 that are owed to the protocol
  43 |     |     /// @dev Protocol fees will never exceed uint128 max in either token
  44 |     |     function protocolFees() external view returns (uint128 token0, uint128 token1);
  45 |     | 
  46 |     |     /// @notice The currently in range liquidity available to the pool
  47 |     |     /// @dev This value has no relationship to the total liquidity across all ticks
  48 |     |     function liquidity() external view returns (uint128);
  49 |     | 
  50 |     |     /// @notice Look up information about a specific tick in the pool
  51 |     |     /// @param tick The tick to look up
  52 |     |     /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
  53 |     |     /// tick upper,
  54 |     |     /// liquidityNet how much liquidity changes when the pool price crosses the tick,
  55 |     |     /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
  56 |     |     /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
  57 |     |     /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
  58 |     |     /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
  59 |     |     /// secondsOutside the seconds spent on the other side of the tick from the current tick,
  60 |     |     /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
  61 |     |     /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
  62 |     |     /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
  63 |     |     /// a specific position.
  64 |     |     function ticks(int24 tick)
  65 |     |         external
  66 |     |         view
  67 |     |         returns (
  68 |     |             uint128 liquidityGross,
  69 |     |             int128 liquidityNet,
  70 |     |             uint256 feeGrowthOutside0X128,
  71 |     |             uint256 feeGrowthOutside1X128,
  72 |     |             int56 tickCumulativeOutside,
  73 |     |             uint160 secondsPerLiquidityOutsideX128,
  74 |     |             uint32 secondsOutside,
  75 |     |             bool initialized
  76 |     |         );
  77 |     | 
  78 |     |     /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
  79 |     |     function tickBitmap(int16 wordPosition) external view returns (uint256);
  80 |     | 
  81 |     |     /// @notice Returns the information about a position by the position's key
  82 |     |     /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
  83 |     |     /// @return _liquidity The amount of liquidity in the position,
  84 |     |     /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
  85 |     |     /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
  86 |     |     /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
  87 |     |     /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
  88 |     |     function positions(bytes32 key)
  89 |     |         external
  90 |     |         view
  91 |     |         returns (
  92 |     |             uint128 _liquidity,
  93 |     |             uint256 feeGrowthInside0LastX128,
  94 |     |             uint256 feeGrowthInside1LastX128,
  95 |     |             uint128 tokensOwed0,
  96 |     |             uint128 tokensOwed1
  97 |     |         );
  98 |     | 
  99 |     |     /// @notice Returns data about a specific observation index
 100 |     |     /// @param index The element of the observations array to fetch
 101 |     |     /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
 102 |     |     /// ago, rather than at a specific index in the array.
 103 |     |     /// @return blockTimestamp The timestamp of the observation,
 104 |     |     /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
 105 |     |     /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
 106 |     |     /// Returns initialized whether the observation has been initialized and the values are safe to use
 107 |     |     function observations(uint256 index)
 108 |     |         external
 109 |     |         view
 110 |     |         returns (
 111 |     |             uint32 blockTimestamp,
 112 |     |             int56 tickCumulative,
 113 |     |             uint160 secondsPerLiquidityCumulativeX128,
 114 |     |             bool initialized
 115 |     |         );
 116 |     | }
 117 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/BitMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title BitMath
  5 |     | /// @dev This library provides functionality for computing bit properties of an unsigned integer
  6 |     | library BitMath {
  7 |     |     /// @notice Returns the index of the most significant bit of the number,
  8 |     |     ///     where the least significant bit is at index 0 and the most significant bit is at index 255
  9 |     |     /// @dev The function satisfies the property:
 10 |     |     ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)
 11 |     |     /// @param x the value for which to compute the most significant bit, must be greater than 0
 12 |     |     /// @return r the index of the most significant bit
 13 |     |     function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {
 14 |     |         require(x > 0);
 15 |     | 
 16 |     |         if (x >= 0x100000000000000000000000000000000) {
 17 |     |             x >>= 128;
 18 |     |             r += 128;
 19 |     |         }
 20 |     |         if (x >= 0x10000000000000000) {
 21 |     |             x >>= 64;
 22 |     |             r += 64;
 23 |     |         }
 24 |     |         if (x >= 0x100000000) {
 25 |     |             x >>= 32;
 26 |     |             r += 32;
 27 |     |         }
 28 |     |         if (x >= 0x10000) {
 29 |     |             x >>= 16;
 30 |     |             r += 16;
 31 |     |         }
 32 |     |         if (x >= 0x100) {
 33 |     |             x >>= 8;
 34 |     |             r += 8;
 35 |     |         }
 36 |     |         if (x >= 0x10) {
 37 |     |             x >>= 4;
 38 |     |             r += 4;
 39 |     |         }
 40 |     |         if (x >= 0x4) {
 41 |     |             x >>= 2;
 42 |     |             r += 2;
 43 |     |         }
 44 |     |         if (x >= 0x2) r += 1;
 45 |     |     }
 46 |     | 
 47 |     |     /// @notice Returns the index of the least significant bit of the number,
 48 |     |     ///     where the least significant bit is at index 0 and the most significant bit is at index 255
 49 |     |     /// @dev The function satisfies the property:
 50 |     |     ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)
 51 |     |     /// @param x the value for which to compute the least significant bit, must be greater than 0
 52 |     |     /// @return r the index of the least significant bit
 53 |     |     function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {
 54 |     |         require(x > 0);
 55 |     | 
 56 |     |         r = 255;
 57 |     |         if (x & type(uint128).max > 0) {
 58 |     |             r -= 128;
 59 |     |         } else {
 60 |     |             x >>= 128;
 61 |     |         }
 62 |     |         if (x & type(uint64).max > 0) {
 63 |     |             r -= 64;
 64 |     |         } else {
 65 |     |             x >>= 64;
 66 |     |         }
 67 |     |         if (x & type(uint32).max > 0) {
 68 |     |             r -= 32;
 69 |     |         } else {
 70 |     |             x >>= 32;
 71 |     |         }
 72 |     |         if (x & type(uint16).max > 0) {
 73 |     |             r -= 16;
 74 |     |         } else {
 75 |     |             x >>= 16;
 76 |     |         }
 77 |     |         if (x & type(uint8).max > 0) {
 78 |     |             r -= 8;
 79 |     |         } else {
 80 |     |             x >>= 8;
 81 |     |         }
 82 |     |         if (x & 0xf > 0) {
 83 |     |             r -= 4;
 84 |     |         } else {
 85 |     |             x >>= 4;
 86 |     |         }
 87 |     |         if (x & 0x3 > 0) {
 88 |     |             r -= 2;
 89 |     |         } else {
 90 |     |             x >>= 2;
 91 |     |         }
 92 |     |         if (x & 0x1 > 0) r -= 1;
 93 |     |     }
 94 |     | }
 95 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/FixedPoint128.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.4.0;
  3 |     | 
  4 |     | /// @title FixedPoint128
  5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
  6 |     | library FixedPoint128 {
  7 |     |     uint256 internal constant Q128 = 0x100000000000000000000000000000000;
  8 |     | }
  9 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/FixedPoint96.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.4.0;
  3 |     | 
  4 |     | /// @title FixedPoint96
  5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
  6 |     | /// @dev Used in SqrtPriceMath.sol
  7 |     | library FixedPoint96 {
  8 |     |     uint8 internal constant RESOLUTION = 96;
  9 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
 10 |     | }
 11 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/FullMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.4.0 <0.8.0;
   3 |     | 
   4 |     | /// @title Contains 512-bit math functions
   5 |     | /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
   6 |     | /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
   7 |     | library FullMath {
   8 |     |     /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
   9 |     |     /// @param a The multiplicand
  10 |     |     /// @param b The multiplier
  11 |     |     /// @param denominator The divisor
  12 |     |     /// @return result The 256-bit result
  13 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
  14 |     |     function mulDiv(
  15 |     |         uint256 a,
  16 |     |         uint256 b,
  17 |     |         uint256 denominator
  18 |     |     ) internal pure returns (uint256 result) {
  19 |     |         // 512-bit multiply [prod1 prod0] = a * b
  20 |     |         // Compute the product mod 2**256 and mod 2**256 - 1
  21 |     |         // then use the Chinese Remainder Theorem to reconstruct
  22 |     |         // the 512 bit result. The result is stored in two 256
  23 |     |         // variables such that product = prod1 * 2**256 + prod0
  24 |     |         uint256 prod0; // Least significant 256 bits of the product
  25 |     |         uint256 prod1; // Most significant 256 bits of the product
  26 |     |         assembly {
  27 |     |             let mm := mulmod(a, b, not(0))
  28 |     |             prod0 := mul(a, b)
  29 |     |             prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  30 |     |         }
  31 |     | 
  32 |     |         // Handle non-overflow cases, 256 by 256 division
  33 |     |         if (prod1 == 0) {
  34 |     |             require(denominator > 0);
  35 |     |             assembly {
  36 |     |                 result := div(prod0, denominator)
  37 |     |             }
  38 |     |             return result;
  39 |     |         }
  40 |     | 
  41 |     |         // Make sure the result is less than 2**256.
  42 |     |         // Also prevents denominator == 0
  43 |     |         require(denominator > prod1);
  44 |     | 
  45 |     |         ///////////////////////////////////////////////
  46 |     |         // 512 by 256 division.
  47 |     |         ///////////////////////////////////////////////
  48 |     | 
  49 |     |         // Make division exact by subtracting the remainder from [prod1 prod0]
  50 |     |         // Compute remainder using mulmod
  51 |     |         uint256 remainder;
  52 |     |         assembly {
  53 |     |             remainder := mulmod(a, b, denominator)
  54 |     |         }
  55 |     |         // Subtract 256 bit number from 512 bit number
  56 |     |         assembly {
  57 |     |             prod1 := sub(prod1, gt(remainder, prod0))
  58 |     |             prod0 := sub(prod0, remainder)
  59 |     |         }
  60 |     | 
  61 |     |         // Factor powers of two out of denominator
  62 |     |         // Compute largest power of two divisor of denominator.
  63 |     |         // Always >= 1.
  64 |     |         uint256 twos = -denominator & denominator;
  65 |     |         // Divide denominator by power of two
  66 |     |         assembly {
  67 |     |             denominator := div(denominator, twos)
  68 |     |         }
  69 |     | 
  70 |     |         // Divide [prod1 prod0] by the factors of two
  71 |     |         assembly {
  72 |     |             prod0 := div(prod0, twos)
  73 |     |         }
  74 |     |         // Shift in bits from prod1 into prod0. For this we need
  75 |     |         // to flip `twos` such that it is 2**256 / twos.
  76 |     |         // If twos is zero, then it becomes one
  77 |     |         assembly {
  78 |     |             twos := add(div(sub(0, twos), twos), 1)
  79 |     |         }
  80 |     |         prod0 |= prod1 * twos;
  81 |     | 
  82 |     |         // Invert denominator mod 2**256
  83 |     |         // Now that denominator is an odd number, it has an inverse
  84 |     |         // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  85 |     |         // Compute the inverse by starting with a seed that is correct
  86 |     |         // correct for four bits. That is, denominator * inv = 1 mod 2**4
  87 |     |         uint256 inv = (3 * denominator) ^ 2;
  88 |     |         // Now use Newton-Raphson iteration to improve the precision.
  89 |     |         // Thanks to Hensel's lifting lemma, this also works in modular
  90 |     |         // arithmetic, doubling the correct bits in each step.
  91 |     |         inv *= 2 - denominator * inv; // inverse mod 2**8
  92 |     |         inv *= 2 - denominator * inv; // inverse mod 2**16
  93 |     |         inv *= 2 - denominator * inv; // inverse mod 2**32
  94 |     |         inv *= 2 - denominator * inv; // inverse mod 2**64
  95 |     |         inv *= 2 - denominator * inv; // inverse mod 2**128
  96 |     |         inv *= 2 - denominator * inv; // inverse mod 2**256
  97 |     | 
  98 |     |         // Because the division is now exact we can divide by multiplying
  99 |     |         // with the modular inverse of denominator. This will give us the
 100 |     |         // correct result modulo 2**256. Since the precoditions guarantee
 101 |     |         // that the outcome is less than 2**256, this is the final result.
 102 |     |         // We don't need to compute the high bits of the result and prod1
 103 |     |         // is no longer required.
 104 |     |         result = prod0 * inv;
 105 |     |         return result;
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
 109 |     |     /// @param a The multiplicand
 110 |     |     /// @param b The multiplier
 111 |     |     /// @param denominator The divisor
 112 |     |     /// @return result The 256-bit result
 113 |     |     function mulDivRoundingUp(
 114 |     |         uint256 a,
 115 |     |         uint256 b,
 116 |     |         uint256 denominator
 117 |     |     ) internal pure returns (uint256 result) {
 118 |     |         result = mulDiv(a, b, denominator);
 119 |     |         if (mulmod(a, b, denominator) > 0) {
 120 |     |             require(result < type(uint256).max);
 121 |     |             result++;
 122 |     |         }
 123 |     |     }
 124 |     | }
 125 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/LiquidityMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Math library for liquidity
  5 |     | library LiquidityMath {
  6 |     |     /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows
  7 |     |     /// @param x The liquidity before change
  8 |     |     /// @param y The delta by which liquidity should be changed
  9 |     |     /// @return z The liquidity delta
 10 |     |     function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {
 11 |     |         if (y < 0) {
 12 |     |             require((z = x - uint128(-y)) < x, 'LS');
 13 |     |         } else {
 14 |     |             require((z = x + uint128(y)) >= x, 'LA');
 15 |     |         }
 16 |     |     }
 17 |     | }
 18 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/LowGasSafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.7.0;
  3 |     | 
  4 |     | /// @title Optimized overflow and underflow safe math operations
  5 |     | /// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost
  6 |     | library LowGasSafeMath {
  7 |     |     /// @notice Returns x + y, reverts if sum overflows uint256
  8 |     |     /// @param x The augend
  9 |     |     /// @param y The addend
 10 |     |     /// @return z The sum of x and y
 11 |     |     function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
 12 |     |         require((z = x + y) >= x);
 13 |     |     }
 14 |     | 
 15 |     |     /// @notice Returns x - y, reverts if underflows
 16 |     |     /// @param x The minuend
 17 |     |     /// @param y The subtrahend
 18 |     |     /// @return z The difference of x and y
 19 |     |     function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
 20 |     |         require((z = x - y) <= x);
 21 |     |     }
 22 |     | 
 23 |     |     /// @notice Returns x * y, reverts if overflows
 24 |     |     /// @param x The multiplicand
 25 |     |     /// @param y The multiplier
 26 |     |     /// @return z The product of x and y
 27 |     |     function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
 28 |     |         require(x == 0 || (z = x * y) / x == y);
 29 |     |     }
 30 |     | 
 31 |     |     /// @notice Returns x + y, reverts if overflows or underflows
 32 |     |     /// @param x The augend
 33 |     |     /// @param y The addend
 34 |     |     /// @return z The sum of x and y
 35 |     |     function add(int256 x, int256 y) internal pure returns (int256 z) {
 36 |     |         require((z = x + y) >= x == (y >= 0));
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Returns x - y, reverts if overflows or underflows
 40 |     |     /// @param x The minuend
 41 |     |     /// @param y The subtrahend
 42 |     |     /// @return z The difference of x and y
 43 |     |     function sub(int256 x, int256 y) internal pure returns (int256 z) {
 44 |     |         require((z = x - y) <= x == (y >= 0));
 45 |     |     }
 46 |     | }
 47 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/Oracle.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.5.0 <0.8.0;
   3 |     | 
   4 |     | /// @title Oracle
   5 |     | /// @notice Provides price and liquidity data useful for a wide variety of system designs
   6 |     | /// @dev Instances of stored oracle data, "observations", are collected in the oracle array
   7 |     | /// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the
   8 |     | /// maximum length of the oracle array. New slots will be added when the array is fully populated.
   9 |     | /// Observations are overwritten when the full length of the oracle array is populated.
  10 |     | /// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()
  11 |     | library Oracle {
  12 |     |     struct Observation {
  13 |     |         // the block timestamp of the observation
  14 |     |         uint32 blockTimestamp;
  15 |     |         // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
  16 |     |         int56 tickCumulative;
  17 |     |         // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
  18 |     |         uint160 secondsPerLiquidityCumulativeX128;
  19 |     |         // whether or not the observation is initialized
  20 |     |         bool initialized;
  21 |     |     }
  22 |     | 
  23 |     |     /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values
  24 |     |     /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows
  25 |     |     /// @param last The specified observation to be transformed
  26 |     |     /// @param blockTimestamp The timestamp of the new observation
  27 |     |     /// @param tick The active tick at the time of the new observation
  28 |     |     /// @param liquidity The total in-range liquidity at the time of the new observation
  29 |     |     /// @return Observation The newly populated observation
  30 |     |     function transform(
  31 |     |         Observation memory last,
  32 |     |         uint32 blockTimestamp,
  33 |     |         int24 tick,
  34 |     |         uint128 liquidity
  35 |     |     ) private pure returns (Observation memory) {
  36 |     |         uint32 delta = blockTimestamp - last.blockTimestamp;
  37 |     |         return
  38 |     |             Observation({
  39 |     |                 blockTimestamp: blockTimestamp,
  40 |     |                 tickCumulative: last.tickCumulative + int56(tick) * delta,
  41 |     |                 secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +
  42 |     |                     ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),
  43 |     |                 initialized: true
  44 |     |             });
  45 |     |     }
  46 |     | 
  47 |     |     /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array
  48 |     |     /// @param self The stored oracle array
  49 |     |     /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32
  50 |     |     /// @return cardinality The number of populated elements in the oracle array
  51 |     |     /// @return cardinalityNext The new length of the oracle array, independent of population
  52 | r   |     function initialize(Observation[65535] storage self, uint32 time)
  53 |     |         internal
  54 | r   |         returns (uint16 cardinality, uint16 cardinalityNext)
  55 |     |     {
  56 | r   |         self[0] = Observation({
  57 | r   |             blockTimestamp: time,
  58 | r   |             tickCumulative: 0,
  59 | r   |             secondsPerLiquidityCumulativeX128: 0,
  60 | r   |             initialized: true
  61 |     |         });
  62 | r   |         return (1, 1);
  63 |     |     }
  64 |     | 
  65 |     |     /// @notice Writes an oracle observation to the array
  66 |     |     /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.
  67 |     |     /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality
  68 |     |     /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.
  69 |     |     /// @param self The stored oracle array
  70 |     |     /// @param index The index of the observation that was most recently written to the observations array
  71 |     |     /// @param blockTimestamp The timestamp of the new observation
  72 |     |     /// @param tick The active tick at the time of the new observation
  73 |     |     /// @param liquidity The total in-range liquidity at the time of the new observation
  74 |     |     /// @param cardinality The number of populated elements in the oracle array
  75 |     |     /// @param cardinalityNext The new length of the oracle array, independent of population
  76 |     |     /// @return indexUpdated The new index of the most recently written element in the oracle array
  77 |     |     /// @return cardinalityUpdated The new cardinality of the oracle array
  78 |     |     function write(
  79 |     |         Observation[65535] storage self,
  80 |     |         uint16 index,
  81 |     |         uint32 blockTimestamp,
  82 |     |         int24 tick,
  83 |     |         uint128 liquidity,
  84 |     |         uint16 cardinality,
  85 |     |         uint16 cardinalityNext
  86 |     |     ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
  87 |     |         Observation memory last = self[index];
  88 |     | 
  89 |     |         // early return if we've already written an observation this block
  90 |     |         if (last.blockTimestamp == blockTimestamp) return (index, cardinality);
  91 |     | 
  92 |     |         // if the conditions are right, we can bump the cardinality
  93 |     |         if (cardinalityNext > cardinality && index == (cardinality - 1)) {
  94 |     |             cardinalityUpdated = cardinalityNext;
  95 |     |         } else {
  96 |     |             cardinalityUpdated = cardinality;
  97 |     |         }
  98 |     | 
  99 |     |         indexUpdated = (index + 1) % cardinalityUpdated;
 100 |     |         self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);
 101 |     |     }
 102 |     | 
 103 |     |     /// @notice Prepares the oracle array to store up to `next` observations
 104 |     |     /// @param self The stored oracle array
 105 |     |     /// @param current The current next cardinality of the oracle array
 106 |     |     /// @param next The proposed next cardinality which will be populated in the oracle array
 107 |     |     /// @return next The next cardinality which will be populated in the oracle array
 108 |     |     function grow(
 109 |     |         Observation[65535] storage self,
 110 |     |         uint16 current,
 111 |     |         uint16 next
 112 |     |     ) internal returns (uint16) {
 113 |     |         require(current > 0, 'I');
 114 |     |         // no-op if the passed next value isn't greater than the current next value
 115 |     |         if (next <= current) return current;
 116 |     |         // store in each slot to prevent fresh SSTOREs in swaps
 117 |     |         // this data will not be used because the initialized boolean is still false
 118 |     |         for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;
 119 |     |         return next;
 120 |     |     }
 121 |     | 
 122 |     |     /// @notice comparator for 32-bit timestamps
 123 |     |     /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time
 124 |     |     /// @param time A timestamp truncated to 32 bits
 125 |     |     /// @param a A comparison timestamp from which to determine the relative position of `time`
 126 |     |     /// @param b From which to determine the relative position of `time`
 127 |     |     /// @return bool Whether `a` is chronologically <= `b`
 128 |     |     function lte(
 129 |     |         uint32 time,
 130 |     |         uint32 a,
 131 |     |         uint32 b
 132 |     |     ) private pure returns (bool) {
 133 |     |         // if there hasn't been overflow, no need to adjust
 134 |     |         if (a <= time && b <= time) return a <= b;
 135 |     | 
 136 |     |         uint256 aAdjusted = a > time ? a : a + 2**32;
 137 |     |         uint256 bAdjusted = b > time ? b : b + 2**32;
 138 |     | 
 139 |     |         return aAdjusted <= bAdjusted;
 140 |     |     }
 141 |     | 
 142 |     |     /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
 143 |     |     /// The result may be the same observation, or adjacent observations.
 144 |     |     /// @dev The answer must be contained in the array, used when the target is located within the stored observation
 145 |     |     /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
 146 |     |     /// @param self The stored oracle array
 147 |     |     /// @param time The current block.timestamp
 148 |     |     /// @param target The timestamp at which the reserved observation should be for
 149 |     |     /// @param index The index of the observation that was most recently written to the observations array
 150 |     |     /// @param cardinality The number of populated elements in the oracle array
 151 |     |     /// @return beforeOrAt The observation recorded before, or at, the target
 152 |     |     /// @return atOrAfter The observation recorded at, or after, the target
 153 |     |     function binarySearch(
 154 |     |         Observation[65535] storage self,
 155 |     |         uint32 time,
 156 |     |         uint32 target,
 157 |     |         uint16 index,
 158 |     |         uint16 cardinality
 159 |     |     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
 160 |     |         uint256 l = (index + 1) % cardinality; // oldest observation
 161 |     |         uint256 r = l + cardinality - 1; // newest observation
 162 |     |         uint256 i;
 163 |     |         while (true) {
 164 |     |             i = (l + r) / 2;
 165 |     | 
 166 |     |             beforeOrAt = self[i % cardinality];
 167 |     | 
 168 |     |             // we've landed on an uninitialized tick, keep searching higher (more recently)
 169 |     |             if (!beforeOrAt.initialized) {
 170 |     |                 l = i + 1;
 171 |     |                 continue;
 172 |     |             }
 173 |     | 
 174 |     |             atOrAfter = self[(i + 1) % cardinality];
 175 |     | 
 176 |     |             bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);
 177 |     | 
 178 |     |             // check if we've found the answer!
 179 |     |             if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;
 180 |     | 
 181 |     |             if (!targetAtOrAfter) r = i - 1;
 182 |     |             else l = i + 1;
 183 |     |         }
 184 |     |     }
 185 |     | 
 186 |     |     /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied
 187 |     |     /// @dev Assumes there is at least 1 initialized observation.
 188 |     |     /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.
 189 |     |     /// @param self The stored oracle array
 190 |     |     /// @param time The current block.timestamp
 191 |     |     /// @param target The timestamp at which the reserved observation should be for
 192 |     |     /// @param tick The active tick at the time of the returned or simulated observation
 193 |     |     /// @param index The index of the observation that was most recently written to the observations array
 194 |     |     /// @param liquidity The total pool liquidity at the time of the call
 195 |     |     /// @param cardinality The number of populated elements in the oracle array
 196 |     |     /// @return beforeOrAt The observation which occurred at, or before, the given timestamp
 197 |     |     /// @return atOrAfter The observation which occurred at, or after, the given timestamp
 198 |     |     function getSurroundingObservations(
 199 |     |         Observation[65535] storage self,
 200 |     |         uint32 time,
 201 |     |         uint32 target,
 202 |     |         int24 tick,
 203 |     |         uint16 index,
 204 |     |         uint128 liquidity,
 205 |     |         uint16 cardinality
 206 |     |     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
 207 |     |         // optimistically set before to the newest observation
 208 |     |         beforeOrAt = self[index];
 209 |     | 
 210 |     |         // if the target is chronologically at or after the newest observation, we can early return
 211 |     |         if (lte(time, beforeOrAt.blockTimestamp, target)) {
 212 |     |             if (beforeOrAt.blockTimestamp == target) {
 213 |     |                 // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
 214 |     |                 return (beforeOrAt, atOrAfter);
 215 |     |             } else {
 216 |     |                 // otherwise, we need to transform
 217 |     |                 return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));
 218 |     |             }
 219 |     |         }
 220 |     | 
 221 |     |         // now, set before to the oldest observation
 222 |     |         beforeOrAt = self[(index + 1) % cardinality];
 223 |     |         if (!beforeOrAt.initialized) beforeOrAt = self[0];
 224 |     | 
 225 |     |         // ensure that the target is chronologically at or after the oldest observation
 226 |     |         require(lte(time, beforeOrAt.blockTimestamp, target), 'OLD');
 227 |     | 
 228 |     |         // if we've reached this point, we have to binary search
 229 |     |         return binarySearch(self, time, target, index, cardinality);
 230 |     |     }
 231 |     | 
 232 |     |     /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.
 233 |     |     /// 0 may be passed as `secondsAgo' to return the current cumulative values.
 234 |     |     /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values
 235 |     |     /// at exactly the timestamp between the two observations.
 236 |     |     /// @param self The stored oracle array
 237 |     |     /// @param time The current block timestamp
 238 |     |     /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation
 239 |     |     /// @param tick The current tick
 240 |     |     /// @param index The index of the observation that was most recently written to the observations array
 241 |     |     /// @param liquidity The current in-range pool liquidity
 242 |     |     /// @param cardinality The number of populated elements in the oracle array
 243 |     |     /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`
 244 |     |     /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`
 245 |     |     function observeSingle(
 246 |     |         Observation[65535] storage self,
 247 |     |         uint32 time,
 248 |     |         uint32 secondsAgo,
 249 |     |         int24 tick,
 250 |     |         uint16 index,
 251 |     |         uint128 liquidity,
 252 |     |         uint16 cardinality
 253 |     |     ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {
 254 |     |         if (secondsAgo == 0) {
 255 |     |             Observation memory last = self[index];
 256 |     |             if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);
 257 |     |             return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);
 258 |     |         }
 259 |     | 
 260 |     |         uint32 target = time - secondsAgo;
 261 |     | 
 262 |     |         (Observation memory beforeOrAt, Observation memory atOrAfter) =
 263 |     |             getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);
 264 |     | 
 265 |     |         if (target == beforeOrAt.blockTimestamp) {
 266 |     |             // we're at the left boundary
 267 |     |             return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);
 268 |     |         } else if (target == atOrAfter.blockTimestamp) {
 269 |     |             // we're at the right boundary
 270 |     |             return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);
 271 |     |         } else {
 272 |     |             // we're in the middle
 273 |     |             uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;
 274 |     |             uint32 targetDelta = target - beforeOrAt.blockTimestamp;
 275 |     |             return (
 276 |     |                 beforeOrAt.tickCumulative +
 277 |     |                     ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / observationTimeDelta) *
 278 |     |                     targetDelta,
 279 |     |                 beforeOrAt.secondsPerLiquidityCumulativeX128 +
 280 |     |                     uint160(
 281 |     |                         (uint256(
 282 |     |                             atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128
 283 |     |                         ) * targetDelta) / observationTimeDelta
 284 |     |                     )
 285 |     |             );
 286 |     |         }
 287 |     |     }
 288 |     | 
 289 |     |     /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`
 290 |     |     /// @dev Reverts if `secondsAgos` > oldest observation
 291 |     |     /// @param self The stored oracle array
 292 |     |     /// @param time The current block.timestamp
 293 |     |     /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation
 294 |     |     /// @param tick The current tick
 295 |     |     /// @param index The index of the observation that was most recently written to the observations array
 296 |     |     /// @param liquidity The current in-range pool liquidity
 297 |     |     /// @param cardinality The number of populated elements in the oracle array
 298 |     |     /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`
 299 |     |     /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`
 300 |     |     function observe(
 301 |     |         Observation[65535] storage self,
 302 |     |         uint32 time,
 303 |     |         uint32[] memory secondsAgos,
 304 |     |         int24 tick,
 305 |     |         uint16 index,
 306 |     |         uint128 liquidity,
 307 |     |         uint16 cardinality
 308 |     |     ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {
 309 |     |         require(cardinality > 0, 'I');
 310 |     | 
 311 |     |         tickCumulatives = new int56[](secondsAgos.length);
 312 |     |         secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
 313 |     |         for (uint256 i = 0; i < secondsAgos.length; i++) {
 314 |     |             (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(
 315 |     |                 self,
 316 |     |                 time,
 317 |     |                 secondsAgos[i],
 318 |     |                 tick,
 319 |     |                 index,
 320 |     |                 liquidity,
 321 |     |                 cardinality
 322 |     |             );
 323 |     |         }
 324 |     |     }
 325 |     | }
 326 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/Position.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.5.0 <0.8.0;
  3 |     | 
  4 |     | import './FullMath.sol';
  5 |     | import './FixedPoint128.sol';
  6 |     | import './LiquidityMath.sol';
  7 |     | 
  8 |     | /// @title Position
  9 |     | /// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary
 10 |     | /// @dev Positions store additional state for tracking fees owed to the position
 11 |     | library Position {
 12 |     |     // info stored for each user's position
 13 |     |     struct Info {
 14 |     |         // the amount of liquidity owned by this position
 15 |     |         uint128 liquidity;
 16 |     |         // fee growth per unit of liquidity as of the last update to liquidity or fees owed
 17 |     |         uint256 feeGrowthInside0LastX128;
 18 |     |         uint256 feeGrowthInside1LastX128;
 19 |     |         // the fees owed to the position owner in token0/token1
 20 |     |         uint128 tokensOwed0;
 21 |     |         uint128 tokensOwed1;
 22 |     |     }
 23 |     | 
 24 |     |     /// @notice Returns the Info struct of a position, given an owner and position boundaries
 25 |     |     /// @param self The mapping containing all user positions
 26 |     |     /// @param owner The address of the position owner
 27 |     |     /// @param tickLower The lower tick boundary of the position
 28 |     |     /// @param tickUpper The upper tick boundary of the position
 29 |     |     /// @return position The position info struct of the given owners' position
 30 |     |     function get(
 31 |     |         mapping(bytes32 => Info) storage self,
 32 |     |         address owner,
 33 |     |         int24 tickLower,
 34 |     |         int24 tickUpper
 35 |     |     ) internal view returns (Position.Info storage position) {
 36 |     |         position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Credits accumulated fees to a user's position
 40 |     |     /// @param self The individual position to update
 41 |     |     /// @param liquidityDelta The change in pool liquidity as a result of the position update
 42 |     |     /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
 43 |     |     /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
 44 |     |     function update(
 45 |     |         Info storage self,
 46 |     |         int128 liquidityDelta,
 47 |     |         uint256 feeGrowthInside0X128,
 48 |     |         uint256 feeGrowthInside1X128
 49 |     |     ) internal {
 50 |     |         Info memory _self = self;
 51 |     | 
 52 |     |         uint128 liquidityNext;
 53 |     |         if (liquidityDelta == 0) {
 54 |     |             require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions
 55 |     |             liquidityNext = _self.liquidity;
 56 |     |         } else {
 57 |     |             liquidityNext = LiquidityMath.addDelta(_self.liquidity, liquidityDelta);
 58 |     |         }
 59 |     | 
 60 |     |         // calculate accumulated fees
 61 |     |         uint128 tokensOwed0 =
 62 |     |             uint128(
 63 |     |                 FullMath.mulDiv(
 64 |     |                     feeGrowthInside0X128 - _self.feeGrowthInside0LastX128,
 65 |     |                     _self.liquidity,
 66 |     |                     FixedPoint128.Q128
 67 |     |                 )
 68 |     |             );
 69 |     |         uint128 tokensOwed1 =
 70 |     |             uint128(
 71 |     |                 FullMath.mulDiv(
 72 |     |                     feeGrowthInside1X128 - _self.feeGrowthInside1LastX128,
 73 |     |                     _self.liquidity,
 74 |     |                     FixedPoint128.Q128
 75 |     |                 )
 76 |     |             );
 77 |     | 
 78 |     |         // update the position
 79 |     |         if (liquidityDelta != 0) self.liquidity = liquidityNext;
 80 |     |         self.feeGrowthInside0LastX128 = feeGrowthInside0X128;
 81 |     |         self.feeGrowthInside1LastX128 = feeGrowthInside1X128;
 82 |     |         if (tokensOwed0 > 0 || tokensOwed1 > 0) {
 83 |     |             // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
 84 |     |             self.tokensOwed0 += tokensOwed0;
 85 |     |             self.tokensOwed1 += tokensOwed1;
 86 |     |         }
 87 |     |     }
 88 |     | }
 89 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/SafeCast.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Safe casting methods
  5 |     | /// @notice Contains methods for safely casting between types
  6 |     | library SafeCast {
  7 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
  8 |     |     /// @param y The uint256 to be downcasted
  9 |     |     /// @return z The downcasted integer, now type uint160
 10 |     |     function toUint160(uint256 y) internal pure returns (uint160 z) {
 11 |     |         require((z = uint160(y)) == y);
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 15 |     |     /// @param y The int256 to be downcasted
 16 |     |     /// @return z The downcasted integer, now type int128
 17 |     |     function toInt128(int256 y) internal pure returns (int128 z) {
 18 |     |         require((z = int128(y)) == y);
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Cast a uint256 to a int256, revert on overflow
 22 |     |     /// @param y The uint256 to be casted
 23 |     |     /// @return z The casted integer, now type int256
 24 |     |     function toInt256(uint256 y) internal pure returns (int256 z) {
 25 |     |         require(y < 2**255);
 26 |     |         z = int256(y);
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/SqrtPriceMath.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | import './LowGasSafeMath.sol';
   5 |     | import './SafeCast.sol';
   6 |     | 
   7 |     | import './FullMath.sol';
   8 |     | import './UnsafeMath.sol';
   9 |     | import './FixedPoint96.sol';
  10 |     | 
  11 |     | /// @title Functions based on Q64.96 sqrt price and liquidity
  12 |     | /// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas
  13 |     | library SqrtPriceMath {
  14 |     |     using LowGasSafeMath for uint256;
  15 |     |     using SafeCast for uint256;
  16 |     | 
  17 |     |     /// @notice Gets the next sqrt price given a delta of token0
  18 |     |     /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least
  19 |     |     /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the
  20 |     |     /// price less in order to not send too much output.
  21 |     |     /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),
  22 |     |     /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).
  23 |     |     /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta
  24 |     |     /// @param liquidity The amount of usable liquidity
  25 |     |     /// @param amount How much of token0 to add or remove from virtual reserves
  26 |     |     /// @param add Whether to add or remove the amount of token0
  27 |     |     /// @return The price after adding or removing amount, depending on add
  28 |     |     function getNextSqrtPriceFromAmount0RoundingUp(
  29 |     |         uint160 sqrtPX96,
  30 |     |         uint128 liquidity,
  31 |     |         uint256 amount,
  32 |     |         bool add
  33 |     |     ) internal pure returns (uint160) {
  34 |     |         // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price
  35 |     |         if (amount == 0) return sqrtPX96;
  36 |     |         uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
  37 |     | 
  38 |     |         if (add) {
  39 |     |             uint256 product;
  40 |     |             if ((product = amount * sqrtPX96) / amount == sqrtPX96) {
  41 |     |                 uint256 denominator = numerator1 + product;
  42 |     |                 if (denominator >= numerator1)
  43 |     |                     // always fits in 160 bits
  44 |     |                     return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));
  45 |     |             }
  46 |     | 
  47 |     |             return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));
  48 |     |         } else {
  49 |     |             uint256 product;
  50 |     |             // if the product overflows, we know the denominator underflows
  51 |     |             // in addition, we must check that the denominator does not underflow
  52 |     |             require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);
  53 |     |             uint256 denominator = numerator1 - product;
  54 |     |             return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     /// @notice Gets the next sqrt price given a delta of token1
  59 |     |     /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least
  60 |     |     /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the
  61 |     |     /// price less in order to not send too much output.
  62 |     |     /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity
  63 |     |     /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta
  64 |     |     /// @param liquidity The amount of usable liquidity
  65 |     |     /// @param amount How much of token1 to add, or remove, from virtual reserves
  66 |     |     /// @param add Whether to add, or remove, the amount of token1
  67 |     |     /// @return The price after adding or removing `amount`
  68 |     |     function getNextSqrtPriceFromAmount1RoundingDown(
  69 |     |         uint160 sqrtPX96,
  70 |     |         uint128 liquidity,
  71 |     |         uint256 amount,
  72 |     |         bool add
  73 |     |     ) internal pure returns (uint160) {
  74 |     |         // if we're adding (subtracting), rounding down requires rounding the quotient down (up)
  75 |     |         // in both cases, avoid a mulDiv for most inputs
  76 |     |         if (add) {
  77 |     |             uint256 quotient =
  78 |     |                 (
  79 |     |                     amount <= type(uint160).max
  80 |     |                         ? (amount << FixedPoint96.RESOLUTION) / liquidity
  81 |     |                         : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)
  82 |     |                 );
  83 |     | 
  84 |     |             return uint256(sqrtPX96).add(quotient).toUint160();
  85 |     |         } else {
  86 |     |             uint256 quotient =
  87 |     |                 (
  88 |     |                     amount <= type(uint160).max
  89 |     |                         ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)
  90 |     |                         : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)
  91 |     |                 );
  92 |     | 
  93 |     |             require(sqrtPX96 > quotient);
  94 |     |             // always fits 160 bits
  95 |     |             return uint160(sqrtPX96 - quotient);
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /// @notice Gets the next sqrt price given an input amount of token0 or token1
 100 |     |     /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds
 101 |     |     /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount
 102 |     |     /// @param liquidity The amount of usable liquidity
 103 |     |     /// @param amountIn How much of token0, or token1, is being swapped in
 104 |     |     /// @param zeroForOne Whether the amount in is token0 or token1
 105 |     |     /// @return sqrtQX96 The price after adding the input amount to token0 or token1
 106 |     |     function getNextSqrtPriceFromInput(
 107 |     |         uint160 sqrtPX96,
 108 |     |         uint128 liquidity,
 109 |     |         uint256 amountIn,
 110 |     |         bool zeroForOne
 111 |     |     ) internal pure returns (uint160 sqrtQX96) {
 112 |     |         require(sqrtPX96 > 0);
 113 |     |         require(liquidity > 0);
 114 |     | 
 115 |     |         // round to make sure that we don't pass the target price
 116 |     |         return
 117 |     |             zeroForOne
 118 |     |                 ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)
 119 |     |                 : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
 120 |     |     }
 121 |     | 
 122 |     |     /// @notice Gets the next sqrt price given an output amount of token0 or token1
 123 |     |     /// @dev Throws if price or liquidity are 0 or the next price is out of bounds
 124 |     |     /// @param sqrtPX96 The starting price before accounting for the output amount
 125 |     |     /// @param liquidity The amount of usable liquidity
 126 |     |     /// @param amountOut How much of token0, or token1, is being swapped out
 127 |     |     /// @param zeroForOne Whether the amount out is token0 or token1
 128 |     |     /// @return sqrtQX96 The price after removing the output amount of token0 or token1
 129 |     |     function getNextSqrtPriceFromOutput(
 130 |     |         uint160 sqrtPX96,
 131 |     |         uint128 liquidity,
 132 |     |         uint256 amountOut,
 133 |     |         bool zeroForOne
 134 |     |     ) internal pure returns (uint160 sqrtQX96) {
 135 |     |         require(sqrtPX96 > 0);
 136 |     |         require(liquidity > 0);
 137 |     | 
 138 |     |         // round to make sure that we pass the target price
 139 |     |         return
 140 |     |             zeroForOne
 141 |     |                 ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)
 142 |     |                 : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
 143 |     |     }
 144 |     | 
 145 |     |     /// @notice Gets the amount0 delta between two prices
 146 |     |     /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),
 147 |     |     /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))
 148 |     |     /// @param sqrtRatioAX96 A sqrt price
 149 |     |     /// @param sqrtRatioBX96 Another sqrt price
 150 |     |     /// @param liquidity The amount of usable liquidity
 151 |     |     /// @param roundUp Whether to round the amount up or down
 152 |     |     /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices
 153 |     |     function getAmount0Delta(
 154 |     |         uint160 sqrtRatioAX96,
 155 |     |         uint160 sqrtRatioBX96,
 156 |     |         uint128 liquidity,
 157 |     |         bool roundUp
 158 |     |     ) internal pure returns (uint256 amount0) {
 159 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 160 |     | 
 161 |     |         uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
 162 |     |         uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;
 163 |     | 
 164 |     |         require(sqrtRatioAX96 > 0);
 165 |     | 
 166 |     |         return
 167 |     |             roundUp
 168 |     |                 ? UnsafeMath.divRoundingUp(
 169 |     |                     FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),
 170 |     |                     sqrtRatioAX96
 171 |     |                 )
 172 |     |                 : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;
 173 |     |     }
 174 |     | 
 175 |     |     /// @notice Gets the amount1 delta between two prices
 176 |     |     /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))
 177 |     |     /// @param sqrtRatioAX96 A sqrt price
 178 |     |     /// @param sqrtRatioBX96 Another sqrt price
 179 |     |     /// @param liquidity The amount of usable liquidity
 180 |     |     /// @param roundUp Whether to round the amount up, or down
 181 |     |     /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices
 182 |     |     function getAmount1Delta(
 183 |     |         uint160 sqrtRatioAX96,
 184 |     |         uint160 sqrtRatioBX96,
 185 |     |         uint128 liquidity,
 186 |     |         bool roundUp
 187 |     |     ) internal pure returns (uint256 amount1) {
 188 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 189 |     | 
 190 |     |         return
 191 |     |             roundUp
 192 |     |                 ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)
 193 |     |                 : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
 194 |     |     }
 195 |     | 
 196 |     |     /// @notice Helper that gets signed token0 delta
 197 |     |     /// @param sqrtRatioAX96 A sqrt price
 198 |     |     /// @param sqrtRatioBX96 Another sqrt price
 199 |     |     /// @param liquidity The change in liquidity for which to compute the amount0 delta
 200 |     |     /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices
 201 |     |     function getAmount0Delta(
 202 |     |         uint160 sqrtRatioAX96,
 203 |     |         uint160 sqrtRatioBX96,
 204 |     |         int128 liquidity
 205 |     |     ) internal pure returns (int256 amount0) {
 206 |     |         return
 207 |     |             liquidity < 0
 208 |     |                 ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
 209 |     |                 : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
 210 |     |     }
 211 |     | 
 212 |     |     /// @notice Helper that gets signed token1 delta
 213 |     |     /// @param sqrtRatioAX96 A sqrt price
 214 |     |     /// @param sqrtRatioBX96 Another sqrt price
 215 |     |     /// @param liquidity The change in liquidity for which to compute the amount1 delta
 216 |     |     /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices
 217 |     |     function getAmount1Delta(
 218 |     |         uint160 sqrtRatioAX96,
 219 |     |         uint160 sqrtRatioBX96,
 220 |     |         int128 liquidity
 221 |     |     ) internal pure returns (int256 amount1) {
 222 |     |         return
 223 |     |             liquidity < 0
 224 |     |                 ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
 225 |     |                 : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
 226 |     |     }
 227 |     | }
 228 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/SwapMath.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | import './FullMath.sol';
   5 |     | import './SqrtPriceMath.sol';
   6 |     | 
   7 |     | /// @title Computes the result of a swap within ticks
   8 |     | /// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.
   9 |     | library SwapMath {
  10 |     |     /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap
  11 |     |     /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive
  12 |     |     /// @param sqrtRatioCurrentX96 The current sqrt price of the pool
  13 |     |     /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred
  14 |     |     /// @param liquidity The usable liquidity
  15 |     |     /// @param amountRemaining How much input or output amount is remaining to be swapped in/out
  16 |     |     /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip
  17 |     |     /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target
  18 |     |     /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap
  19 |     |     /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap
  20 |     |     /// @return feeAmount The amount of input that will be taken as a fee
  21 |     |     function computeSwapStep(
  22 |     |         uint160 sqrtRatioCurrentX96,
  23 |     |         uint160 sqrtRatioTargetX96,
  24 |     |         uint128 liquidity,
  25 |     |         int256 amountRemaining,
  26 |     |         uint24 feePips
  27 |     |     )
  28 |     |         internal
  29 |     |         pure
  30 |     |         returns (
  31 |     |             uint160 sqrtRatioNextX96,
  32 |     |             uint256 amountIn,
  33 |     |             uint256 amountOut,
  34 |     |             uint256 feeAmount
  35 |     |         )
  36 |     |     {
  37 |     |         bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;
  38 |     |         bool exactIn = amountRemaining >= 0;
  39 |     | 
  40 |     |         if (exactIn) {
  41 |     |             uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);
  42 |     |             amountIn = zeroForOne
  43 |     |                 ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)
  44 |     |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
  45 |     |             if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;
  46 |     |             else
  47 |     |                 sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(
  48 |     |                     sqrtRatioCurrentX96,
  49 |     |                     liquidity,
  50 |     |                     amountRemainingLessFee,
  51 |     |                     zeroForOne
  52 |     |                 );
  53 |     |         } else {
  54 |     |             amountOut = zeroForOne
  55 |     |                 ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)
  56 |     |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
  57 |     |             if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;
  58 |     |             else
  59 |     |                 sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(
  60 |     |                     sqrtRatioCurrentX96,
  61 |     |                     liquidity,
  62 |     |                     uint256(-amountRemaining),
  63 |     |                     zeroForOne
  64 |     |                 );
  65 |     |         }
  66 |     | 
  67 |     |         bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;
  68 |     | 
  69 |     |         // get the input/output amounts
  70 |     |         if (zeroForOne) {
  71 |     |             amountIn = max && exactIn
  72 |     |                 ? amountIn
  73 |     |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
  74 |     |             amountOut = max && !exactIn
  75 |     |                 ? amountOut
  76 |     |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
  77 |     |         } else {
  78 |     |             amountIn = max && exactIn
  79 |     |                 ? amountIn
  80 |     |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);
  81 |     |             amountOut = max && !exactIn
  82 |     |                 ? amountOut
  83 |     |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);
  84 |     |         }
  85 |     | 
  86 |     |         // cap the output amount to not exceed the remaining output amount
  87 |     |         if (!exactIn && amountOut > uint256(-amountRemaining)) {
  88 |     |             amountOut = uint256(-amountRemaining);
  89 |     |         }
  90 |     | 
  91 |     |         if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {
  92 |     |             // we didn't reach the target, so take the remainder of the maximum input as fee
  93 |     |             feeAmount = uint256(amountRemaining) - amountIn;
  94 |     |         } else {
  95 |     |             feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);
  96 |     |         }
  97 |     |     }
  98 |     | }
  99 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/Tick.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.5.0 <0.8.0;
   3 |     | 
   4 |     | import './LowGasSafeMath.sol';
   5 |     | import './SafeCast.sol';
   6 |     | 
   7 |     | import './TickMath.sol';
   8 |     | import './LiquidityMath.sol';
   9 |     | 
  10 |     | /// @title Tick
  11 |     | /// @notice Contains functions for managing tick processes and relevant calculations
  12 |     | library Tick {
  13 |     |     using LowGasSafeMath for int256;
  14 |     |     using SafeCast for int256;
  15 |     | 
  16 |     |     // info stored for each initialized individual tick
  17 |     |     struct Info {
  18 |     |         // the total position liquidity that references this tick
  19 |     |         uint128 liquidityGross;
  20 |     |         // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
  21 |     |         int128 liquidityNet;
  22 |     |         // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
  23 |     |         // only has relative meaning, not absolute — the value depends on when the tick is initialized
  24 |     |         uint256 feeGrowthOutside0X128;
  25 |     |         uint256 feeGrowthOutside1X128;
  26 |     |         // the cumulative tick value on the other side of the tick
  27 |     |         int56 tickCumulativeOutside;
  28 |     |         // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
  29 |     |         // only has relative meaning, not absolute — the value depends on when the tick is initialized
  30 |     |         uint160 secondsPerLiquidityOutsideX128;
  31 |     |         // the seconds spent on the other side of the tick (relative to the current tick)
  32 |     |         // only has relative meaning, not absolute — the value depends on when the tick is initialized
  33 |     |         uint32 secondsOutside;
  34 |     |         // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0
  35 |     |         // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
  36 |     |         bool initialized;
  37 |     |     }
  38 |     | 
  39 |     |     /// @notice Derives max liquidity per tick from given tick spacing
  40 |     |     /// @dev Executed within the pool constructor
  41 |     |     /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`
  42 |     |     ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...
  43 |     |     /// @return The max liquidity per tick
  44 |     |     function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {
  45 |     |         int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;
  46 |     |         int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;
  47 |     |         uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;
  48 |     |         return type(uint128).max / numTicks;
  49 |     |     }
  50 |     | 
  51 |     |     /// @notice Retrieves fee growth data
  52 |     |     /// @param self The mapping containing all tick information for initialized ticks
  53 |     |     /// @param tickLower The lower tick boundary of the position
  54 |     |     /// @param tickUpper The upper tick boundary of the position
  55 |     |     /// @param tickCurrent The current tick
  56 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
  57 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
  58 |     |     /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
  59 |     |     /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
  60 |     |     function getFeeGrowthInside(
  61 |     |         mapping(int24 => Tick.Info) storage self,
  62 |     |         int24 tickLower,
  63 |     |         int24 tickUpper,
  64 |     |         int24 tickCurrent,
  65 |     |         uint256 feeGrowthGlobal0X128,
  66 |     |         uint256 feeGrowthGlobal1X128
  67 |     |     ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {
  68 |     |         Info storage lower = self[tickLower];
  69 |     |         Info storage upper = self[tickUpper];
  70 |     | 
  71 |     |         // calculate fee growth below
  72 |     |         uint256 feeGrowthBelow0X128;
  73 |     |         uint256 feeGrowthBelow1X128;
  74 |     |         if (tickCurrent >= tickLower) {
  75 |     |             feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;
  76 |     |             feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;
  77 |     |         } else {
  78 |     |             feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;
  79 |     |             feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;
  80 |     |         }
  81 |     | 
  82 |     |         // calculate fee growth above
  83 |     |         uint256 feeGrowthAbove0X128;
  84 |     |         uint256 feeGrowthAbove1X128;
  85 |     |         if (tickCurrent < tickUpper) {
  86 |     |             feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;
  87 |     |             feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;
  88 |     |         } else {
  89 |     |             feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;
  90 |     |             feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;
  91 |     |         }
  92 |     | 
  93 |     |         feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;
  94 |     |         feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;
  95 |     |     }
  96 |     | 
  97 |     |     /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa
  98 |     |     /// @param self The mapping containing all tick information for initialized ticks
  99 |     |     /// @param tick The tick that will be updated
 100 |     |     /// @param tickCurrent The current tick
 101 |     |     /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)
 102 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
 103 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
 104 |     |     /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool
 105 |     |     /// @param tickCumulative The tick * time elapsed since the pool was first initialized
 106 |     |     /// @param time The current block timestamp cast to a uint32
 107 |     |     /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick
 108 |     |     /// @param maxLiquidity The maximum liquidity allocation for a single tick
 109 |     |     /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa
 110 |     |     function update(
 111 |     |         mapping(int24 => Tick.Info) storage self,
 112 |     |         int24 tick,
 113 |     |         int24 tickCurrent,
 114 |     |         int128 liquidityDelta,
 115 |     |         uint256 feeGrowthGlobal0X128,
 116 |     |         uint256 feeGrowthGlobal1X128,
 117 |     |         uint160 secondsPerLiquidityCumulativeX128,
 118 |     |         int56 tickCumulative,
 119 |     |         uint32 time,
 120 |     |         bool upper,
 121 |     |         uint128 maxLiquidity
 122 |     |     ) internal returns (bool flipped) {
 123 |     |         Tick.Info storage info = self[tick];
 124 |     | 
 125 |     |         uint128 liquidityGrossBefore = info.liquidityGross;
 126 |     |         uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);
 127 |     | 
 128 |     |         require(liquidityGrossAfter <= maxLiquidity, 'LO');
 129 |     | 
 130 |     |         flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);
 131 |     | 
 132 |     |         if (liquidityGrossBefore == 0) {
 133 |     |             // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
 134 |     |             if (tick <= tickCurrent) {
 135 |     |                 info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;
 136 |     |                 info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;
 137 |     |                 info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;
 138 |     |                 info.tickCumulativeOutside = tickCumulative;
 139 |     |                 info.secondsOutside = time;
 140 |     |             }
 141 |     |             info.initialized = true;
 142 |     |         }
 143 |     | 
 144 |     |         info.liquidityGross = liquidityGrossAfter;
 145 |     | 
 146 |     |         // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
 147 |     |         info.liquidityNet = upper
 148 |     |             ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()
 149 |     |             : int256(info.liquidityNet).add(liquidityDelta).toInt128();
 150 |     |     }
 151 |     | 
 152 |     |     /// @notice Clears tick data
 153 |     |     /// @param self The mapping containing all initialized tick information for initialized ticks
 154 |     |     /// @param tick The tick that will be cleared
 155 |     |     function clear(mapping(int24 => Tick.Info) storage self, int24 tick) internal {
 156 |     |         delete self[tick];
 157 |     |     }
 158 |     | 
 159 |     |     /// @notice Transitions to next tick as needed by price movement
 160 |     |     /// @param self The mapping containing all tick information for initialized ticks
 161 |     |     /// @param tick The destination tick of the transition
 162 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
 163 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
 164 |     |     /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity
 165 |     |     /// @param tickCumulative The tick * time elapsed since the pool was first initialized
 166 |     |     /// @param time The current block.timestamp
 167 |     |     /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)
 168 |     |     function cross(
 169 |     |         mapping(int24 => Tick.Info) storage self,
 170 |     |         int24 tick,
 171 |     |         uint256 feeGrowthGlobal0X128,
 172 |     |         uint256 feeGrowthGlobal1X128,
 173 |     |         uint160 secondsPerLiquidityCumulativeX128,
 174 |     |         int56 tickCumulative,
 175 |     |         uint32 time
 176 |     |     ) internal returns (int128 liquidityNet) {
 177 |     |         Tick.Info storage info = self[tick];
 178 |     |         info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;
 179 |     |         info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;
 180 |     |         info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;
 181 |     |         info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;
 182 |     |         info.secondsOutside = time - info.secondsOutside;
 183 |     |         liquidityNet = info.liquidityNet;
 184 |     |     }
 185 |     | }
 186 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/TickBitmap.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | import './BitMath.sol';
  5 |     | 
  6 |     | /// @title Packed tick initialized state library
  7 |     | /// @notice Stores a packed mapping of tick index to its initialized state
  8 |     | /// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.
  9 |     | library TickBitmap {
 10 |     |     /// @notice Computes the position in the mapping where the initialized bit for a tick lives
 11 |     |     /// @param tick The tick for which to compute the position
 12 |     |     /// @return wordPos The key in the mapping containing the word in which the bit is stored
 13 |     |     /// @return bitPos The bit position in the word where the flag is stored
 14 |     |     function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {
 15 |     |         wordPos = int16(tick >> 8);
 16 |     |         bitPos = uint8(tick % 256);
 17 |     |     }
 18 |     | 
 19 |     |     /// @notice Flips the initialized state for a given tick from false to true, or vice versa
 20 |     |     /// @param self The mapping in which to flip the tick
 21 |     |     /// @param tick The tick to flip
 22 |     |     /// @param tickSpacing The spacing between usable ticks
 23 |     |     function flipTick(
 24 |     |         mapping(int16 => uint256) storage self,
 25 |     |         int24 tick,
 26 |     |         int24 tickSpacing
 27 |     |     ) internal {
 28 |     |         require(tick % tickSpacing == 0); // ensure that the tick is spaced
 29 |     |         (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);
 30 |     |         uint256 mask = 1 << bitPos;
 31 |     |         self[wordPos] ^= mask;
 32 |     |     }
 33 |     | 
 34 |     |     /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either
 35 |     |     /// to the left (less than or equal to) or right (greater than) of the given tick
 36 |     |     /// @param self The mapping in which to compute the next initialized tick
 37 |     |     /// @param tick The starting tick
 38 |     |     /// @param tickSpacing The spacing between usable ticks
 39 |     |     /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)
 40 |     |     /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick
 41 |     |     /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks
 42 |     |     function nextInitializedTickWithinOneWord(
 43 |     |         mapping(int16 => uint256) storage self,
 44 |     |         int24 tick,
 45 |     |         int24 tickSpacing,
 46 |     |         bool lte
 47 |     |     ) internal view returns (int24 next, bool initialized) {
 48 |     |         int24 compressed = tick / tickSpacing;
 49 |     |         if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity
 50 |     | 
 51 |     |         if (lte) {
 52 |     |             (int16 wordPos, uint8 bitPos) = position(compressed);
 53 |     |             // all the 1s at or to the right of the current bitPos
 54 |     |             uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);
 55 |     |             uint256 masked = self[wordPos] & mask;
 56 |     | 
 57 |     |             // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word
 58 |     |             initialized = masked != 0;
 59 |     |             // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
 60 |     |             next = initialized
 61 |     |                 ? (compressed - int24(bitPos - BitMath.mostSignificantBit(masked))) * tickSpacing
 62 |     |                 : (compressed - int24(bitPos)) * tickSpacing;
 63 |     |         } else {
 64 |     |             // start from the word of the next tick, since the current tick state doesn't matter
 65 |     |             (int16 wordPos, uint8 bitPos) = position(compressed + 1);
 66 |     |             // all the 1s at or to the left of the bitPos
 67 |     |             uint256 mask = ~((1 << bitPos) - 1);
 68 |     |             uint256 masked = self[wordPos] & mask;
 69 |     | 
 70 |     |             // if there are no initialized ticks to the left of the current tick, return leftmost in the word
 71 |     |             initialized = masked != 0;
 72 |     |             // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
 73 |     |             next = initialized
 74 |     |                 ? (compressed + 1 + int24(BitMath.leastSignificantBit(masked) - bitPos)) * tickSpacing
 75 |     |                 : (compressed + 1 + int24(type(uint8).max - bitPos)) * tickSpacing;
 76 |     |         }
 77 |     |     }
 78 |     | }
 79 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/TickMath.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0 <0.8.0;
   3 |     | 
   4 |     | /// @title Math library for computing sqrt prices from ticks and vice versa
   5 |     | /// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
   6 |     | /// prices between 2**-128 and 2**128
   7 |     | library TickMath {
   8 |     |     /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
   9 | r   |     int24 internal constant MIN_TICK = -887272;
  10 |     |     /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
  11 | r   |     int24 internal constant MAX_TICK = -MIN_TICK;
  12 |     | 
  13 |     |     /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
  14 | r   |     uint160 internal constant MIN_SQRT_RATIO = 4295128739;
  15 |     |     /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
  16 | r   |     uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
  17 |     | 
  18 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96
  19 |     |     /// @dev Throws if |tick| > max tick
  20 |     |     /// @param tick The input tick for the above formula
  21 |     |     /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
  22 |     |     /// at the given tick
  23 | r   |     function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
  24 | r   |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
  25 | r   |         require(absTick <= uint256(MAX_TICK), 'T');
  26 |     | 
  27 | r   |         uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
  28 | r   |         if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
  29 | r   |         if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
  30 | r   |         if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
  31 | r   |         if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
  32 | r   |         if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
  33 | r   |         if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
  34 | r   |         if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
  35 | r   |         if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
  36 | r   |         if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
  37 | r   |         if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
  38 | r   |         if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
  39 | r   |         if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
  40 | r   |         if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
  41 | r   |         if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
  42 | r   |         if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
  43 | r   |         if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
  44 | r   |         if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
  45 | r   |         if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
  46 | r   |         if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
  47 |     | 
  48 | r   |         if (tick > 0) ratio = type(uint256).max / ratio;
  49 |     | 
  50 |     |         // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
  51 |     |         // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
  52 |     |         // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
  53 | r   |         sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
  54 |     |     }
  55 |     | 
  56 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
  57 |     |     /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
  58 |     |     /// ever return.
  59 |     |     /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
  60 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
  61 | r   |     function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
  62 |     |         // second inequality must be < because the price can never reach the price at the max tick
  63 | r   |         require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
  64 | r   |         uint256 ratio = uint256(sqrtPriceX96) << 32;
  65 |     | 
  66 | r   |         uint256 r = ratio;
  67 | r   |         uint256 msb = 0;
  68 |     | 
  69 | r   |         assembly {
  70 | r   |             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
  71 | r   |             msb := or(msb, f)
  72 | r   |             r := shr(f, r)
  73 |     |         }
  74 | r   |         assembly {
  75 | r   |             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
  76 | r   |             msb := or(msb, f)
  77 | r   |             r := shr(f, r)
  78 |     |         }
  79 | r   |         assembly {
  80 | r   |             let f := shl(5, gt(r, 0xFFFFFFFF))
  81 | r   |             msb := or(msb, f)
  82 | r   |             r := shr(f, r)
  83 |     |         }
  84 | r   |         assembly {
  85 | r   |             let f := shl(4, gt(r, 0xFFFF))
  86 | r   |             msb := or(msb, f)
  87 | r   |             r := shr(f, r)
  88 |     |         }
  89 | r   |         assembly {
  90 | r   |             let f := shl(3, gt(r, 0xFF))
  91 | r   |             msb := or(msb, f)
  92 | r   |             r := shr(f, r)
  93 |     |         }
  94 | r   |         assembly {
  95 | r   |             let f := shl(2, gt(r, 0xF))
  96 | r   |             msb := or(msb, f)
  97 | r   |             r := shr(f, r)
  98 |     |         }
  99 | r   |         assembly {
 100 | r   |             let f := shl(1, gt(r, 0x3))
 101 | r   |             msb := or(msb, f)
 102 | r   |             r := shr(f, r)
 103 |     |         }
 104 | r   |         assembly {
 105 | r   |             let f := gt(r, 0x1)
 106 | r   |             msb := or(msb, f)
 107 |     |         }
 108 |     | 
 109 | r   |         if (msb >= 128) r = ratio >> (msb - 127);
 110 |     |         else r = ratio << (127 - msb);
 111 |     | 
 112 | r   |         int256 log_2 = (int256(msb) - 128) << 64;
 113 |     | 
 114 | r   |         assembly {
 115 | r   |             r := shr(127, mul(r, r))
 116 | r   |             let f := shr(128, r)
 117 | r   |             log_2 := or(log_2, shl(63, f))
 118 | r   |             r := shr(f, r)
 119 |     |         }
 120 | r   |         assembly {
 121 | r   |             r := shr(127, mul(r, r))
 122 | r   |             let f := shr(128, r)
 123 | r   |             log_2 := or(log_2, shl(62, f))
 124 | r   |             r := shr(f, r)
 125 |     |         }
 126 | r   |         assembly {
 127 | r   |             r := shr(127, mul(r, r))
 128 | r   |             let f := shr(128, r)
 129 | r   |             log_2 := or(log_2, shl(61, f))
 130 | r   |             r := shr(f, r)
 131 |     |         }
 132 | r   |         assembly {
 133 | r   |             r := shr(127, mul(r, r))
 134 | r   |             let f := shr(128, r)
 135 | r   |             log_2 := or(log_2, shl(60, f))
 136 | r   |             r := shr(f, r)
 137 |     |         }
 138 | r   |         assembly {
 139 | r   |             r := shr(127, mul(r, r))
 140 | r   |             let f := shr(128, r)
 141 | r   |             log_2 := or(log_2, shl(59, f))
 142 | r   |             r := shr(f, r)
 143 |     |         }
 144 | r   |         assembly {
 145 | r   |             r := shr(127, mul(r, r))
 146 | r   |             let f := shr(128, r)
 147 | r   |             log_2 := or(log_2, shl(58, f))
 148 | r   |             r := shr(f, r)
 149 |     |         }
 150 | r   |         assembly {
 151 | r   |             r := shr(127, mul(r, r))
 152 | r   |             let f := shr(128, r)
 153 | r   |             log_2 := or(log_2, shl(57, f))
 154 | r   |             r := shr(f, r)
 155 |     |         }
 156 | r   |         assembly {
 157 | r   |             r := shr(127, mul(r, r))
 158 | r   |             let f := shr(128, r)
 159 | r   |             log_2 := or(log_2, shl(56, f))
 160 | r   |             r := shr(f, r)
 161 |     |         }
 162 | r   |         assembly {
 163 | r   |             r := shr(127, mul(r, r))
 164 | r   |             let f := shr(128, r)
 165 | r   |             log_2 := or(log_2, shl(55, f))
 166 | r   |             r := shr(f, r)
 167 |     |         }
 168 | r   |         assembly {
 169 | r   |             r := shr(127, mul(r, r))
 170 | r   |             let f := shr(128, r)
 171 | r   |             log_2 := or(log_2, shl(54, f))
 172 | r   |             r := shr(f, r)
 173 |     |         }
 174 | r   |         assembly {
 175 | r   |             r := shr(127, mul(r, r))
 176 | r   |             let f := shr(128, r)
 177 | r   |             log_2 := or(log_2, shl(53, f))
 178 | r   |             r := shr(f, r)
 179 |     |         }
 180 | r   |         assembly {
 181 | r   |             r := shr(127, mul(r, r))
 182 | r   |             let f := shr(128, r)
 183 | r   |             log_2 := or(log_2, shl(52, f))
 184 | r   |             r := shr(f, r)
 185 |     |         }
 186 | r   |         assembly {
 187 | r   |             r := shr(127, mul(r, r))
 188 | r   |             let f := shr(128, r)
 189 | r   |             log_2 := or(log_2, shl(51, f))
 190 | r   |             r := shr(f, r)
 191 |     |         }
 192 | r   |         assembly {
 193 | r   |             r := shr(127, mul(r, r))
 194 | r   |             let f := shr(128, r)
 195 | r   |             log_2 := or(log_2, shl(50, f))
 196 |     |         }
 197 |     | 
 198 | r   |         int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 199 |     | 
 200 | r   |         int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
 201 | r   |         int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
 202 |     | 
 203 | r   |         tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
 204 |     |     }
 205 |     | }
 206 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/TransferHelper.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.6.0;
  3 |     | 
  4 |     | import '../interfaces/IERC20Minimal.sol';
  5 |     | 
  6 |     | /// @title TransferHelper
  7 |     | /// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false
  8 |     | library TransferHelper {
  9 |     |     /// @notice Transfers tokens from msg.sender to a recipient
 10 |     |     /// @dev Calls transfer on token contract, errors with TF if transfer fails
 11 |     |     /// @param token The contract address of the token which will be transferred
 12 |     |     /// @param to The recipient of the transfer
 13 |     |     /// @param value The value of the transfer
 14 |     |     function safeTransfer(
 15 |     |         address token,
 16 |     |         address to,
 17 |     |         uint256 value
 18 |     |     ) internal {
 19 |     |         (bool success, bytes memory data) =
 20 |     |             token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value));
 21 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TF');
 22 |     |     }
 23 |     | }
 24 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/dependencies/libraries/UnsafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Math functions that do not check inputs or outputs
  5 |     | /// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks
  6 |     | library UnsafeMath {
  7 |     |     /// @notice Returns ceil(x / y)
  8 |     |     /// @dev division by 0 has unspecified behavior, and must be checked externally
  9 |     |     /// @param x The dividend
 10 |     |     /// @param y The divisor
 11 |     |     /// @return z The quotient, ceil(x / y)
 12 |     |     function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
 13 |     |         assembly {
 14 |     |             z := add(div(x, y), gt(mod(x, y), 0))
 15 |     |         }
 16 |     |     }
 17 |     | }
 18 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/interfaces/IUnipilotFactory.sol
  1 |     | //SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.7.6;
  3 |     | 
  4 |     | /// @title The interface for the Unipilot Factory
  5 |     | interface IUnipilotFactory {
  6 |     |     /// @notice Emitted when a vault is created
  7 |     |     /// @param _tokenA The first token of the pool by address sort order
  8 |     |     /// @param _tokenB The second token of the pool by address sort order
  9 |     |     /// @param _fee The fee tier for which the vault is created
 10 |     |     /// @param _vault The address of the vault that is created
 11 |     |     event VaultCreated(
 12 |     |         address indexed _tokenA,
 13 |     |         address indexed _tokenB,
 14 |     |         uint16 _strategyType,
 15 |     |         uint24 _fee,
 16 |     |         address indexed _vault
 17 |     |     );
 18 |     | 
 19 |     |     /// @notice Emitted when the governance of the factory is changed
 20 |     |     /// @param _oldGovernance The governance before the governance was changed
 21 |     |     /// @param _newGovernance The governance after the governance was changed
 22 |     |     event GovernanceChanged(
 23 |     |         address indexed _oldGovernance,
 24 |     |         address indexed _newGovernance
 25 |     |     );
 26 |     | 
 27 |     |     /// @notice Creates a vault for the given two tokens and fee
 28 |     |     /// @param _tokenA The first token of the pool by address sort order
 29 |     |     /// @param _tokenB The second token of the pool by address sort order
 30 |     |     /// @param _fee The desired fee for the unipilot vault
 31 |     |     /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0.
 32 |     |     /// The call will revert if the vault already exists, the fee is invalid, or the token arguments
 33 |     |     /// are invalid.
 34 |     |     /// @return _vault The address of the newly created pool
 35 |     |     function createVault(
 36 |     |         address _tokenA,
 37 |     |         address _tokenB,
 38 |     |         uint24 _fee,
 39 |     |         uint16 _vaultStrategy,
 40 |     |         uint160 _sqrtPriceX96,
 41 |     |         string memory _name,
 42 |     |         string memory _symbol
 43 |     |     ) external returns (address _vault);
 44 |     | 
 45 |     |     /// @notice Used to give addresses of governance, strategy, indexFund
 46 |     |     /// @return governance address, strategy address, indexFund address
 47 |     |     function getUnipilotDetails()
 48 |     |         external
 49 |     |         view
 50 |     |         returns (
 51 |     |             address,
 52 |     |             address,
 53 |     |             address,
 54 |     |             uint8,
 55 |     |             uint8
 56 |     |         );
 57 |     | }
 58 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/interfaces/IUnipilotStrategy.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.7.6;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | interface IUnipilotStrategy {
  6 |     |     struct PoolStrategy {
  7 |     |         int24 baseThreshold;
  8 |     |         int24 rangeThreshold;
  9 |     |         int24 maxTwapDeviation;
 10 |     |         int24 readjustThreshold;
 11 |     |         uint32 twapDuration;
 12 |     |         int24 baseMultiplier;
 13 |     |     }
 14 |     | 
 15 |     |     event GovernanceUpdated(address oldGovernance, address newGovernance);
 16 |     |     event StrategyUpdated(PoolStrategy oldStrategy, PoolStrategy newStrategy);
 17 |     |     event MaxTwapDeviationUpdated(int24 oldDeviation, int24 newDeviation);
 18 |     |     event BaseTicksUpdated(int24 oldBaseTicks, int24 newBaseTicks);
 19 |     |     event RangeTicksUpdated(int24 oldRangeTicks, int24 newRangeTicks);
 20 |     |     event TwapDurationUpdated(uint32 oldDuration, uint32 newDuration);
 21 |     |     event ReadjustMultiplierUpdated(int24 oldMultiplier, int24 newMultiplier);
 22 |     | 
 23 |     |     function getTicks(address _pool)
 24 |     |         external
 25 |     |         returns (
 26 |     |             int24 baseLower,
 27 |     |             int24 baseUpper,
 28 |     |             int24 bidLower,
 29 |     |             int24 bidUpper,
 30 |     |             int24 askLower,
 31 |     |             int24 askUpper
 32 |     |         );
 33 |     | 
 34 |     |     function getTwap(address _pool) external view returns (int24);
 35 |     | 
 36 |     |     function getStrategy(address _pool)
 37 |     |         external
 38 |     |         view
 39 |     |         returns (PoolStrategy memory strategy);
 40 |     | 
 41 |     |     function getBaseThreshold(address _pool, uint16 _strategyType)
 42 |     |         external
 43 |     |         view
 44 |     |         returns (int24 baseThreshold);
 45 |     | 
 46 |     |     function twapDuration() external view returns (uint32);
 47 |     | 
 48 |     |     function maxTwapDeviation() external view returns (int24);
 49 |     | 
 50 |     |     function checkDeviation(address pool) external view;
 51 |     | }
 52 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/interfaces/IUnipilotVault.sol
   1 |     | //SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.7.6;
   3 |     | 
   4 |     | interface IUnipilotVault {
   5 |     |     struct ReadjustVars {
   6 |     |         uint256 fees0;
   7 |     |         uint256 fees1;
   8 |     |         int24 currentTick;
   9 |     |         int24 tickLower;
  10 |     |         int24 tickUpper;
  11 |     |         uint256 amount0Desired;
  12 |     |         uint256 amount1Desired;
  13 |     |         uint128 liquidity;
  14 |     |         uint256 amount0;
  15 |     |         uint256 amount1;
  16 |     |         bool zeroForOne;
  17 |     |         int256 amountSpecified;
  18 |     |         uint160 exactSqrtPriceImpact;
  19 |     |         uint160 sqrtPriceLimitX96;
  20 |     |     }
  21 |     | 
  22 |     |     struct TicksData {
  23 |     |         int24 baseTickLower;
  24 |     |         int24 baseTickUpper;
  25 |     |         int24 rangeTickLower;
  26 |     |         int24 rangeTickUpper;
  27 |     |     }
  28 |     | 
  29 |     |     struct Tick {
  30 |     |         int24 baseTickLower;
  31 |     |         int24 baseTickUpper;
  32 |     |         int24 bidTickLower;
  33 |     |         int24 bidTickUpper;
  34 |     |         int24 rangeTickLower;
  35 |     |         int24 rangeTickUpper;
  36 |     |     }
  37 |     | 
  38 |     |     struct Cache {
  39 |     |         uint256 totalSupply;
  40 |     |         uint256 liquidityShare;
  41 |     |     }
  42 |     | 
  43 |     |     event Deposit(
  44 |     |         address indexed depositor,
  45 |     |         address indexed recipient,
  46 |     |         uint256 amount0,
  47 |     |         uint256 amount1,
  48 |     |         uint256 lpShares
  49 |     |     );
  50 |     | 
  51 |     |     event FeesSnapshot(bool isReadjustLiquidity, uint256 fees0, uint256 fees1);
  52 |     | 
  53 |     |     event Withdraw(
  54 |     |         address indexed recipient,
  55 |     |         uint256 shares,
  56 |     |         uint256 amount0,
  57 |     |         uint256 amount1
  58 |     |     );
  59 |     | 
  60 |     |     event PullLiquidity(
  61 |     |         uint256 reserves0,
  62 |     |         uint256 reserves1,
  63 |     |         uint256 fees0,
  64 |     |         uint256 fees1
  65 |     |     );
  66 |     | 
  67 |     |     event CompoundFees(uint256 amount0, uint256 amount1);
  68 |     | 
  69 |     |     /// @notice Deposits tokens in proportion to the Unipilot's current holdings & mints them
  70 |     |     /// `Unipilot`s LP token.
  71 |     |     /// @param amount0Desired Max amount of token0 to deposit
  72 |     |     /// @param amount1Desired Max amount of token1 to deposit
  73 |     |     /// @param recipient Recipient of shares
  74 |     |     /// @return lpShares Number of shares minted
  75 |     |     /// @return amount0 Amount of token0 deposited in vault
  76 |     |     /// @return amount1 Amount of token1 deposited in vault
  77 |     |     function deposit(
  78 |     |         uint256 amount0Desired,
  79 |     |         uint256 amount1Desired,
  80 |     |         address recipient
  81 |     |     )
  82 |     |         external
  83 |     |         payable
  84 |     |         returns (
  85 |     |             uint256 lpShares,
  86 |     |             uint256 amount0,
  87 |     |             uint256 amount1
  88 |     |         );
  89 |     | 
  90 |     |     /// @notice Withdraws the desired shares from the vault with accumulated user fees and transfers to recipient.
  91 |     |     /// @param recipient Recipient of tokens
  92 |     |     /// @param refundAsETH whether to recieve in WETH or ETH (only valid for WETH/ALT pairs)
  93 |     |     /// @return amount0 Amount of token0 sent to recipient
  94 |     |     /// @return amount1 Amount of token1 sent to recipient
  95 |     |     function withdraw(
  96 |     |         uint256 liquidity,
  97 |     |         address recipient,
  98 |     |         bool refundAsETH
  99 |     |     ) external returns (uint256 amount0, uint256 amount1);
 100 |     | 
 101 |     |     /// @notice Pull in tokens from sender. Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.
 102 |     |     /// @dev In the implementation you must pay to the pool for the minted liquidity.
 103 |     |     /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity
 104 |     |     /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity
 105 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call
 106 |     |     function uniswapV3MintCallback(
 107 |     |         uint256 amount0Owed,
 108 |     |         uint256 amount1Owed,
 109 |     |         bytes calldata data
 110 |     |     ) external;
 111 |     | 
 112 |     |     /// @notice Called to `msg.sender` after minting swaping from IUniswapV3Pool#swap.
 113 |     |     /// @dev In the implementation you must pay to the pool for swap.
 114 |     |     /// @param amount0Delta The amount of token0 due to the pool for the swap
 115 |     |     /// @param amount1Delta The amount of token1 due to the pool for the swap
 116 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call
 117 |     |     function uniswapV3SwapCallback(
 118 |     |         int256 amount0Delta,
 119 |     |         int256 amount1Delta,
 120 |     |         bytes calldata data
 121 |     |     ) external;
 122 |     | 
 123 |     |     /// @notice Burns all position(s), collects any fees accrued and updates Unipilot's position(s)
 124 |     |     /// @dev mints all amounts to this position(s) (including earned fees)
 125 |     |     /// @dev For active vaults it can be called by the governance or operator,
 126 |     |     /// swaps imbalanced token and add all liquidity in base position.
 127 |     |     /// @dev For passive vaults it can be called by any user.
 128 |     |     /// Two positions are placed - a base position and a limit position. The base
 129 |     |     /// position is placed first with as much liquidity as possible. This position
 130 |     |     /// should use up all of one token, leaving only the other one. This excess
 131 |     |     /// amount is then placed as a single-sided bid or ask position.
 132 |     |     function readjustLiquidity(uint8 swapBP) external;
 133 |     | }
 134 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/interfaces/external/IWETH9.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity =0.7.6;
  3 |     | 
  4 |     | // import "./IERC20.sol";
  5 |     | 
  6 |     | interface IWETH9 {
  7 |     |     /**
  8 |     |      * @dev Returns the amount of tokens in existence.
  9 |     |      */
 10 |     |     function totalSupply() external view returns (uint256);
 11 |     | 
 12 |     |     /**
 13 |     |      * @dev Returns the amount of tokens owned by `account`.
 14 |     |      */
 15 |     |     function balanceOf(address account) external view returns (uint256);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Moves `amount` tokens from the caller's account to `recipient`.
 19 |     |      *
 20 |     |      * Returns a boolean value indicating whether the operation succeeded.
 21 |     |      *
 22 |     |      * Emits a {Transfer} event.
 23 |     |      */
 24 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 25 |     | 
 26 |     |     /**
 27 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 28 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 29 |     |      * zero by default.
 30 |     |      *
 31 |     |      * This value changes when {approve} or {transferFrom} are called.
 32 |     |      */
 33 |     |     function allowance(address owner, address spender) external view returns (uint256);
 34 |     | 
 35 |     |     /**
 36 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 37 |     |      *
 38 |     |      * Returns a boolean value indicating whether the operation succeeded.
 39 |     |      *
 40 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 41 |     |      * that someone may use both the old and the new allowance by unfortunate
 42 |     |      * transaction ordering. One possible solution to mitigate this race
 43 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 44 |     |      * desired value afterwards:
 45 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 46 |     |      *
 47 |     |      * Emits an {Approval} event.
 48 |     |      */
 49 |     |     function approve(address spender, uint256 amount) external returns (bool);
 50 |     | 
 51 |     |     /**
 52 |     |      * @dev Moves `amount` tokens from `sender` to `recipient` using the
 53 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 54 |     |      * allowance.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * Emits a {Transfer} event.
 59 |     |      */
 60 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
 61 |     | 
 62 |     |     /**
 63 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 64 |     |      * another (`to`).
 65 |     |      *
 66 |     |      * Note that `value` may be zero.
 67 |     |      */
 68 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 69 |     | 
 70 |     |     /**
 71 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 72 |     |      * a call to {approve}. `value` is the new allowance.
 73 |     |      */
 74 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 75 |     | 
 76 |     |      function deposit() external payable;
 77 |     | 
 78 |     |     /// @notice Withdraw wrapped ether to get ether
 79 |     |     function withdraw(uint256) external;
 80 |     | }
 81 |     | 
 82 |     | /// @title Interface for WETH9
 83 |     | // interface IWETH9 is IERC20 {
 84 |     | //     /// @notice Deposit ether to get wrapped ether
 85 |     | //     function deposit() external payable;
 86 |     | 
 87 |     | //     /// @notice Withdraw wrapped ether to get ether
 88 |     | //     function withdraw(uint256) external;
 89 |     | // }
 90 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/libraries/SafeCastExtended.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.7.0;
   4 |     | 
   5 |     | /**
   6 |     |  * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
   7 |     |  * checks.
   8 |     |  *
   9 |     |  * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
  10 |     |  * easily result in undesired exploitation or bugs, since developers usually
  11 |     |  * assume that overflows raise errors. `SafeCast` restores this intuition by
  12 |     |  * reverting the transaction when such an operation overflows.
  13 |     |  *
  14 |     |  * Using this library instead of the unchecked operations eliminates an entire
  15 |     |  * class of bugs, so it's recommended to use it always.
  16 |     |  *
  17 |     |  * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
  18 |     |  * all math on `uint256` and `int256` and then downcasting.
  19 |     |  */
  20 |     | library SafeCastExtended {
  21 |     |     /**
  22 |     |      * @dev Returns the downcasted uint128 from uint256, reverting on
  23 |     |      * overflow (when the input is greater than largest uint128).
  24 |     |      *
  25 |     |      * Counterpart to Solidity's `uint128` operator.
  26 |     |      *
  27 |     |      * Requirements:
  28 |     |      *
  29 |     |      * - input must fit into 128 bits
  30 |     |      */
  31 |     |     function toUint128(uint256 value) internal pure returns (uint128) {
  32 |     |         require(value < 2**128, "SafeCast: value doesn't fit in 128 bits");
  33 |     |         return uint128(value);
  34 |     |     }
  35 |     | 
  36 |     |     /**
  37 |     |      * @dev Returns the downcasted uint64 from uint256, reverting on
  38 |     |      * overflow (when the input is greater than largest uint64).
  39 |     |      *
  40 |     |      * Counterpart to Solidity's `uint64` operator.
  41 |     |      *
  42 |     |      * Requirements:
  43 |     |      *
  44 |     |      * - input must fit into 64 bits
  45 |     |      */
  46 |     |     function toUint64(uint256 value) internal pure returns (uint64) {
  47 |     |         require(value < 2**64, "SafeCast: value doesn't fit in 64 bits");
  48 |     |         return uint64(value);
  49 |     |     }
  50 |     | 
  51 |     |     /**
  52 |     |      * @dev Returns the downcasted uint32 from uint256, reverting on
  53 |     |      * overflow (when the input is greater than largest uint32).
  54 |     |      *
  55 |     |      * Counterpart to Solidity's `uint32` operator.
  56 |     |      *
  57 |     |      * Requirements:
  58 |     |      *
  59 |     |      * - input must fit into 32 bits
  60 |     |      */
  61 |     |     function toUint32(uint256 value) internal pure returns (uint32) {
  62 |     |         require(value < 2**32, "SafeCast: value doesn't fit in 32 bits");
  63 |     |         return uint32(value);
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the downcasted uint16 from uint256, reverting on
  68 |     |      * overflow (when the input is greater than largest uint16).
  69 |     |      *
  70 |     |      * Counterpart to Solidity's `uint16` operator.
  71 |     |      *
  72 |     |      * Requirements:
  73 |     |      *
  74 |     |      * - input must fit into 16 bits
  75 |     |      */
  76 |     |     function toUint16(uint256 value) internal pure returns (uint16) {
  77 |     |         require(value < 2**16, "SafeCast: value doesn't fit in 16 bits");
  78 |     |         return uint16(value);
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Returns the downcasted uint8 from uint256, reverting on
  83 |     |      * overflow (when the input is greater than largest uint8).
  84 |     |      *
  85 |     |      * Counterpart to Solidity's `uint8` operator.
  86 |     |      *
  87 |     |      * Requirements:
  88 |     |      *
  89 |     |      * - input must fit into 8 bits.
  90 |     |      */
  91 |     |     function toUint8(uint256 value) internal pure returns (uint8) {
  92 |     |         require(value < 2**8, "SafeCast: value doesn't fit in 8 bits");
  93 |     |         return uint8(value);
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Converts a signed int256 into an unsigned uint256.
  98 |     |      *
  99 |     |      * Requirements:
 100 |     |      *
 101 |     |      * - input must be greater than or equal to 0.
 102 |     |      */
 103 |     |     function toUint256(int256 value) internal pure returns (uint256) {
 104 |     |         require(value >= 0, "SafeCast: value must be positive");
 105 |     |         return uint256(value);
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Returns the downcasted int128 from int256, reverting on
 110 |     |      * overflow (when the input is less than smallest int128 or
 111 |     |      * greater than largest int128).
 112 |     |      *
 113 |     |      * Counterpart to Solidity's `int128` operator.
 114 |     |      *
 115 |     |      * Requirements:
 116 |     |      *
 117 |     |      * - input must fit into 128 bits
 118 |     |      *
 119 |     |      * _Available since v3.1._
 120 |     |      */
 121 |     |     function toInt128(int256 value) internal pure returns (int128) {
 122 |     |         require(
 123 |     |             value >= -2**127 && value < 2**127,
 124 |     |             "SafeCast: value doesn't fit in 128 bits"
 125 |     |         );
 126 |     |         return int128(value);
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Returns the downcasted int64 from int256, reverting on
 131 |     |      * overflow (when the input is less than smallest int64 or
 132 |     |      * greater than largest int64).
 133 |     |      *
 134 |     |      * Counterpart to Solidity's `int64` operator.
 135 |     |      *
 136 |     |      * Requirements:
 137 |     |      *
 138 |     |      * - input must fit into 64 bits
 139 |     |      *
 140 |     |      * _Available since v3.1._
 141 |     |      */
 142 |     |     function toInt64(int256 value) internal pure returns (int64) {
 143 |     |         require(
 144 |     |             value >= -2**63 && value < 2**63,
 145 |     |             "SafeCast: value doesn't fit in 64 bits"
 146 |     |         );
 147 |     |         return int64(value);
 148 |     |     }
 149 |     | 
 150 |     |     /**
 151 |     |      * @dev Returns the downcasted int32 from int256, reverting on
 152 |     |      * overflow (when the input is less than smallest int32 or
 153 |     |      * greater than largest int32).
 154 |     |      *
 155 |     |      * Counterpart to Solidity's `int32` operator.
 156 |     |      *
 157 |     |      * Requirements:
 158 |     |      *
 159 |     |      * - input must fit into 32 bits
 160 |     |      *
 161 |     |      * _Available since v3.1._
 162 |     |      */
 163 |     |     function toInt32(int256 value) internal pure returns (int32) {
 164 |     |         require(
 165 |     |             value >= -2**31 && value < 2**31,
 166 |     |             "SafeCast: value doesn't fit in 32 bits"
 167 |     |         );
 168 |     |         return int32(value);
 169 |     |     }
 170 |     | 
 171 |     |     /**
 172 |     |      * @dev Returns the downcasted int16 from int256, reverting on
 173 |     |      * overflow (when the input is less than smallest int16 or
 174 |     |      * greater than largest int16).
 175 |     |      *
 176 |     |      * Counterpart to Solidity's `int16` operator.
 177 |     |      *
 178 |     |      * Requirements:
 179 |     |      *
 180 |     |      * - input must fit into 16 bits
 181 |     |      *
 182 |     |      * _Available since v3.1._
 183 |     |      */
 184 |     |     function toInt16(int256 value) internal pure returns (int16) {
 185 |     |         require(
 186 |     |             value >= -2**15 && value < 2**15,
 187 |     |             "SafeCast: value doesn't fit in 16 bits"
 188 |     |         );
 189 |     |         return int16(value);
 190 |     |     }
 191 |     | 
 192 |     |     /**
 193 |     |      * @dev Returns the downcasted int8 from int256, reverting on
 194 |     |      * overflow (when the input is less than smallest int8 or
 195 |     |      * greater than largest int8).
 196 |     |      *
 197 |     |      * Counterpart to Solidity's `int8` operator.
 198 |     |      *
 199 |     |      * Requirements:
 200 |     |      *
 201 |     |      * - input must fit into 8 bits.
 202 |     |      *
 203 |     |      * _Available since v3.1._
 204 |     |      */
 205 |     |     function toInt8(int256 value) internal pure returns (int8) {
 206 |     |         require(
 207 |     |             value >= -2**7 && value < 2**7,
 208 |     |             "SafeCast: value doesn't fit in 8 bits"
 209 |     |         );
 210 |     |         return int8(value);
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Converts an unsigned uint256 into a signed int256.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - input must be less than or equal to maxInt256.
 219 |     |      */
 220 |     |     function toInt256(uint256 value) internal pure returns (int256) {
 221 |     |         require(value < 2**255, "SafeCast: value doesn't fit in an int256");
 222 |     |         return int256(value);
 223 |     |     }
 224 |     | }
 225 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/libraries/TransferHelper.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.6.0;
  3 |     | 
  4 |     | // import "../interfaces/external/IERC20.sol";
  5 |     | import {ERC20Permit, IERC20, ERC20} from "../dependencies/ERC20Permit.sol";
  6 |     | 
  7 |     | //import "../interfaces/external/IERC20.sol";
  8 |     | 
  9 |     | library TransferHelper {
 10 |     |     /// @notice Transfers tokens from the targeted address to the given destination
 11 |     |     /// @notice Errors with 'STF' if transfer fails
 12 |     |     /// @param token The contract address of the token to be transferred
 13 |     |     /// @param from The originating address from which the tokens will be transferred
 14 |     |     /// @param to The destination address of the transfer
 15 |     |     /// @param value The amount to be transferred
 16 |     |     function safeTransferFrom(
 17 |     |         address token,
 18 |     |         address from,
 19 |     |         address to,
 20 |     |         uint256 value
 21 |     |     ) internal {
 22 |     |         (bool success, bytes memory data) = token.call(
 23 |     |             abi.encodeWithSelector(
 24 |     |                 IERC20.transferFrom.selector,
 25 |     |                 from,
 26 |     |                 to,
 27 |     |                 value
 28 |     |             )
 29 |     |         );
 30 |     |         require(
 31 |     |             success && (data.length == 0 || abi.decode(data, (bool))),
 32 |     |             "STF"
 33 |     |         );
 34 |     |     }
 35 |     | 
 36 |     |     /// @notice Transfers tokens from msg.sender to a recipient
 37 |     |     /// @dev Errors with ST if transfer fails
 38 |     |     /// @param token The contract address of the token which will be transferred
 39 |     |     /// @param to The recipient of the transfer
 40 |     |     /// @param value The value of the transfer
 41 |     |     function safeTransfer(
 42 |     |         address token,
 43 |     |         address to,
 44 |     |         uint256 value
 45 |     |     ) internal {
 46 |     |         (bool success, bytes memory data) = token.call(
 47 |     |             abi.encodeWithSelector(IERC20.transfer.selector, to, value)
 48 |     |         );
 49 |     |         require(
 50 |     |             success && (data.length == 0 || abi.decode(data, (bool))),
 51 |     |             "ST"
 52 |     |         );
 53 |     |     }
 54 |     | 
 55 |     |     /// @notice Approves the stipulated contract to spend the given allowance in the given token
 56 |     |     /// @dev Errors with 'SA' if transfer fails
 57 |     |     /// @param token The contract address of the token to be approved
 58 |     |     /// @param to The target of the approval
 59 |     |     /// @param value The amount of the given token the target will be allowed to spend
 60 |     |     function safeApprove(
 61 |     |         address token,
 62 |     |         address to,
 63 |     |         uint256 value
 64 |     |     ) internal {
 65 |     |         (bool success, bytes memory data) = token.call(
 66 |     |             abi.encodeWithSelector(IERC20.approve.selector, to, value)
 67 |     |         );
 68 |     |         require(
 69 |     |             success && (data.length == 0 || abi.decode(data, (bool))),
 70 |     |             "SA"
 71 |     |         );
 72 |     |     }
 73 |     | 
 74 |     |     /// @notice Transfers ETH to the recipient address
 75 |     |     /// @dev Fails with `STE`
 76 |     |     /// @param to The destination of the transfer
 77 |     |     /// @param value The value to be transferred
 78 |     |     function safeTransferETH(address to, uint256 value) internal {
 79 |     |         (bool success, ) = to.call{ value: value }(new bytes(0));
 80 |     |         require(success, "STE");
 81 |     |     }
 82 |     | }
 83 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/libraries/UniswapLiquidityManagement.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | import "./UniswapPoolActions.sol";
   4 |     | import "../dependencies/libraries/TickMath.sol";
   5 |     | import "../dependencies/libraries/SqrtPriceMath.sol";
   6 |     | import "../dependencies/PositionKey.sol";
   7 |     | import "../dependencies/LiquidityAmounts.sol";
   8 |     | import "../interfaces/IUnipilotVault.sol";
   9 |     | 
  10 |     | /// @title Liquidity and ticks functions
  11 |     | /// @notice Provides functions for computing liquidity and ticks for token amounts and prices
  12 |     | library UniswapLiquidityManagement {
  13 |     |     using LowGasSafeMath for uint256;
  14 |     | 
  15 |     |     struct Info {
  16 |     |         uint256 amount0Desired;
  17 |     |         uint256 amount1Desired;
  18 |     |         uint256 amount0;
  19 |     |         uint256 amount1;
  20 |     |         uint128 liquidity;
  21 |     |         int24 tickLower;
  22 |     |         int24 tickUpper;
  23 |     |     }
  24 |     | 
  25 |     |     /// @dev Wrapper around `LiquidityAmounts.getAmountsForLiquidity()`.
  26 |     |     /// @param pool Uniswap V3 pool
  27 |     |     /// @param liquidity  The liquidity being valued
  28 |     |     /// @param _tickLower The lower tick of the range
  29 |     |     /// @param _tickUpper The upper tick of the range
  30 |     |     /// @return amounts of token0 and token1 that corresponds to liquidity
  31 |     |     function getAmountsForLiquidity(
  32 |     |         IUniswapV3Pool pool,
  33 |     |         uint128 liquidity,
  34 |     |         int24 _tickLower,
  35 |     |         int24 _tickUpper
  36 |     |     ) internal view returns (uint256, uint256) {
  37 |     |         (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
  38 |     |         return
  39 |     |             LiquidityAmounts.getAmountsForLiquidity(
  40 |     |                 sqrtRatioX96,
  41 |     |                 TickMath.getSqrtRatioAtTick(_tickLower),
  42 |     |                 TickMath.getSqrtRatioAtTick(_tickUpper),
  43 |     |                 liquidity
  44 |     |             );
  45 |     |     }
  46 |     | 
  47 |     |     /// @dev Wrapper around `LiquidityAmounts.getLiquidityForAmounts()`.
  48 |     |     /// @param pool Uniswap V3 pool
  49 |     |     /// @param amount0 The amount of token0
  50 |     |     /// @param amount1 The amount of token1
  51 |     |     /// @param _tickLower The lower tick of the range
  52 |     |     /// @param _tickUpper The upper tick of the range
  53 |     |     /// @return The maximum amount of liquidity that can be held amount0 and amount1
  54 |     |     function getLiquidityForAmounts(
  55 |     |         IUniswapV3Pool pool,
  56 |     |         uint256 amount0,
  57 |     |         uint256 amount1,
  58 |     |         int24 _tickLower,
  59 |     |         int24 _tickUpper
  60 |     |     ) internal view returns (uint128) {
  61 |     |         (uint160 sqrtRatioX96, , , , , , ) = pool.slot0();
  62 |     | 
  63 |     |         return
  64 |     |             LiquidityAmounts.getLiquidityForAmounts(
  65 |     |                 sqrtRatioX96,
  66 |     |                 TickMath.getSqrtRatioAtTick(_tickLower),
  67 |     |                 TickMath.getSqrtRatioAtTick(_tickUpper),
  68 |     |                 amount0,
  69 |     |                 amount1
  70 |     |             );
  71 |     |     }
  72 |     | 
  73 |     |     /// @dev Amount of liquidity in contract position.
  74 |     |     /// @param pool Uniswap V3 pool
  75 |     |     /// @param _tickLower The lower tick of the range
  76 |     |     /// @param _tickUpper The upper tick of the range
  77 |     |     /// @return liquidity stored in position
  78 |     |     function getPositionLiquidity(
  79 |     |         IUniswapV3Pool pool,
  80 |     |         int24 _tickLower,
  81 |     |         int24 _tickUpper
  82 |     |     )
  83 |     |         internal
  84 |     |         view
  85 |     |         returns (
  86 |     |             uint128 liquidity,
  87 |     |             uint128 tokensOwed0,
  88 |     |             uint128 tokensOwed1
  89 |     |         )
  90 |     |     {
  91 |     |         bytes32 positionKey = PositionKey.compute(
  92 |     |             address(this),
  93 |     |             _tickLower,
  94 |     |             _tickUpper
  95 |     |         );
  96 |     |         (liquidity, , , tokensOwed0, tokensOwed1) = pool.positions(positionKey);
  97 |     |     }
  98 |     | 
  99 |     |     /// @dev Rounds tick down towards negative infinity so that it's a multiple
 100 |     |     /// of `tickSpacing`.
 101 |     |     function floor(int24 tick, int24 tickSpacing)
 102 |     |         internal
 103 |     |         pure
 104 |     |         returns (int24)
 105 |     |     {
 106 |     |         int24 compressed = tick / tickSpacing;
 107 |     |         if (tick < 0 && tick % tickSpacing != 0) compressed--;
 108 |     |         return compressed * tickSpacing;
 109 |     |     }
 110 |     | 
 111 |     |     function getSqrtRatioX96AndTick(IUniswapV3Pool pool)
 112 |     |         internal
 113 |     |         view
 114 |     |         returns (
 115 |     |             uint160 _sqrtRatioX96,
 116 |     |             int24 _tick,
 117 |     |             uint16 observationCardinality
 118 |     |         )
 119 |     |     {
 120 |     |         (_sqrtRatioX96, _tick, , observationCardinality, , , ) = pool.slot0();
 121 |     |     }
 122 |     | 
 123 |     |     /// @dev Calc base ticks depending on base threshold and tickspacing
 124 |     |     function getBaseTicks(
 125 |     |         int24 currentTick,
 126 |     |         int24 baseThreshold,
 127 |     |         int24 tickSpacing
 128 |     |     ) internal pure returns (int24 tickLower, int24 tickUpper) {
 129 |     |         int24 tickFloor = floor(currentTick, tickSpacing);
 130 |     |         tickLower = tickFloor - baseThreshold;
 131 |     |         tickUpper = tickFloor + baseThreshold;
 132 |     |     }
 133 |     | 
 134 |     |     function collectableAmountsInPosition(
 135 |     |         IUniswapV3Pool pool,
 136 |     |         int24 _lowerTick,
 137 |     |         int24 _upperTick
 138 |     |     )
 139 |     |         internal
 140 |     |         view
 141 |     |         returns (
 142 |     |             uint256,
 143 |     |             uint256,
 144 |     |             uint256,
 145 |     |             uint256
 146 |     |         )
 147 |     |     {
 148 |     |         (
 149 |     |             uint128 liquidity,
 150 |     |             uint128 earnable0,
 151 |     |             uint128 earnable1
 152 |     |         ) = getPositionLiquidity(pool, _lowerTick, _upperTick);
 153 |     |         (uint256 burnable0, uint256 burnable1) = UniswapLiquidityManagement
 154 |     |             .getAmountsForLiquidity(pool, liquidity, _lowerTick, _upperTick);
 155 |     | 
 156 |     |         return (burnable0, burnable1, earnable0, earnable1);
 157 |     |     }
 158 |     | 
 159 |     |     function computeLpShares(
 160 |     |         IUniswapV3Pool pool,
 161 |     |         bool isWhitelisted,
 162 |     |         uint256 amount0Max,
 163 |     |         uint256 amount1Max,
 164 |     |         uint256 balance0,
 165 |     |         uint256 balance1,
 166 |     |         uint256 totalSupply,
 167 |     |         IUnipilotVault.TicksData memory ticks
 168 |     |     )
 169 |     |         internal
 170 |     |         returns (
 171 |     |             uint256 shares,
 172 |     |             uint256 amount0,
 173 |     |             uint256 amount1
 174 |     |         )
 175 |     |     {
 176 |     |         (
 177 |     |             uint256 res0,
 178 |     |             uint256 res1,
 179 |     |             uint256 fees0,
 180 |     |             uint256 fees1,
 181 |     |             ,
 182 |     | 
 183 |     |         ) = getTotalAmounts(pool, isWhitelisted, ticks);
 184 |     | 
 185 |     |         uint256 reserve0 = res0.add(fees0).add(balance0);
 186 |     |         uint256 reserve1 = res1.add(fees1).add(balance1);
 187 |     | 
 188 |     |         // If total supply > 0, pool can't be empty
 189 |     |         assert(totalSupply == 0 || reserve0 != 0 || reserve1 != 0);
 190 |     |         (shares, amount0, amount1) = calculateShare(
 191 |     |             amount0Max,
 192 |     |             amount1Max,
 193 |     |             reserve0,
 194 |     |             reserve1,
 195 |     |             totalSupply
 196 |     |         );
 197 |     |     }
 198 |     | 
 199 |     |     function getTotalAmounts(
 200 |     |         IUniswapV3Pool pool,
 201 |     |         bool isWhitelisted,
 202 |     |         IUnipilotVault.TicksData memory ticks
 203 |     |     )
 204 |     |         internal
 205 |     |         returns (
 206 |     |             uint256 amount0,
 207 |     |             uint256 amount1,
 208 |     |             uint256 fees0,
 209 |     |             uint256 fees1,
 210 |     |             uint128 baseLiquidity,
 211 |     |             uint128 rangeLiquidity
 212 |     |         )
 213 |     |     {
 214 |     |         (amount0, amount1, fees0, fees1, baseLiquidity) = getReserves(
 215 |     |             pool,
 216 |     |             ticks.baseTickLower,
 217 |     |             ticks.baseTickUpper
 218 |     |         );
 219 |     | 
 220 |     |         if (!isWhitelisted) {
 221 |     |             (
 222 |     |                 uint256 range0,
 223 |     |                 uint256 range1,
 224 |     |                 uint256 rangeFees0,
 225 |     |                 uint256 rangeFees1,
 226 |     |                 uint128 rangeliquidity
 227 |     |             ) = getReserves(pool, ticks.rangeTickLower, ticks.rangeTickUpper);
 228 |     | 
 229 |     |             amount0 = amount0.add(range0);
 230 |     |             amount1 = amount1.add(range1);
 231 |     |             fees0 = fees0.add(rangeFees0);
 232 |     |             fees1 = fees1.add(rangeFees1);
 233 |     |             rangeLiquidity = rangeliquidity;
 234 |     |         }
 235 |     |     }
 236 |     | 
 237 |     |     function getReserves(
 238 |     |         IUniswapV3Pool pool,
 239 |     |         int24 tickLower,
 240 |     |         int24 tickUpper
 241 |     |     )
 242 |     |         internal
 243 |     |         returns (
 244 |     |             uint256 amount0,
 245 |     |             uint256 amount1,
 246 |     |             uint256 fees0,
 247 |     |             uint256 fees1,
 248 |     |             uint128 liquidity
 249 |     |         )
 250 |     |     {
 251 |     |         liquidity = UniswapPoolActions.updatePosition(
 252 |     |             pool,
 253 |     |             tickLower,
 254 |     |             tickUpper
 255 |     |         );
 256 |     |         if (liquidity > 0) {
 257 |     |             (amount0, amount1, fees0, fees1) = collectableAmountsInPosition(
 258 |     |                 pool,
 259 |     |                 tickLower,
 260 |     |                 tickUpper
 261 |     |             );
 262 |     |         }
 263 |     |     }
 264 |     | 
 265 |     |     function calculateShare(
 266 |     |         uint256 amount0Max,
 267 |     |         uint256 amount1Max,
 268 |     |         uint256 reserve0,
 269 |     |         uint256 reserve1,
 270 |     |         uint256 totalSupply
 271 |     |     )
 272 |     |         internal
 273 |     |         pure
 274 |     |         returns (
 275 |     |             uint256 shares,
 276 |     |             uint256 amount0,
 277 |     |             uint256 amount1
 278 |     |         )
 279 |     |     {
 280 |     |         if (totalSupply == 0) {
 281 |     |             // For first deposit, just use the amounts desired
 282 |     |             amount0 = amount0Max;
 283 |     |             amount1 = amount1Max;
 284 |     |             shares = amount0 > amount1 ? amount0 : amount1; // max
 285 |     |         } else if (reserve0 == 0) {
 286 |     |             amount1 = amount1Max;
 287 |     |             shares = FullMath.mulDiv(amount1, totalSupply, reserve1);
 288 |     |         } else if (reserve1 == 0) {
 289 |     |             amount0 = amount0Max;
 290 |     |             shares = FullMath.mulDiv(amount0, totalSupply, reserve0);
 291 |     |         } else {
 292 |     |             amount0 = FullMath.mulDiv(amount1Max, reserve0, reserve1);
 293 |     |             if (amount0 < amount0Max) {
 294 |     |                 amount1 = amount1Max;
 295 |     |                 shares = FullMath.mulDiv(amount1, totalSupply, reserve1);
 296 |     |             } else {
 297 |     |                 amount0 = amount0Max;
 298 |     |                 amount1 = FullMath.mulDiv(amount0, reserve1, reserve0);
 299 |     |                 shares = FullMath.mulDiv(amount0, totalSupply, reserve0);
 300 |     |             }
 301 |     |         }
 302 |     |     }
 303 |     | 
 304 |     |     /// @dev Gets ticks with proportion equivalent to desired amount
 305 |     |     /// @param pool Uniswap V3 pool
 306 |     |     /// @param amount0Desired The desired amount of token0
 307 |     |     /// @param amount1Desired The desired amount of token1
 308 |     |     /// @param baseThreshold The range for upper and lower ticks
 309 |     |     /// @param tickSpacing The pool tick spacing
 310 |     |     /// @return tickLower The lower tick of the range
 311 |     |     /// @return tickUpper The upper tick of the range
 312 |     |     function getPositionTicks(
 313 |     |         IUniswapV3Pool pool,
 314 |     |         uint256 amount0Desired,
 315 |     |         uint256 amount1Desired,
 316 |     |         int24 baseThreshold,
 317 |     |         int24 tickSpacing
 318 |     |     ) internal view returns (int24 tickLower, int24 tickUpper) {
 319 |     |         Info memory cache = Info(amount0Desired, amount1Desired, 0, 0, 0, 0, 0);
 320 |     |         // Get current price and tick from the pool
 321 |     |         (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();
 322 |     |         //Calc base ticks
 323 |     |         (cache.tickLower, cache.tickUpper) = getBaseTicks(
 324 |     |             currentTick,
 325 |     |             baseThreshold,
 326 |     |             tickSpacing
 327 |     |         );
 328 |     |         //Calc amounts of token0 and token1 that can be stored in base range
 329 |     |         (cache.amount0, cache.amount1) = getAmountsForTicks(
 330 |     |             pool,
 331 |     |             cache.amount0Desired,
 332 |     |             cache.amount1Desired,
 333 |     |             cache.tickLower,
 334 |     |             cache.tickUpper
 335 |     |         );
 336 |     |         // //Liquidity that can be stored in base range
 337 |     |         cache.liquidity = getLiquidityForAmounts(
 338 |     |             pool,
 339 |     |             cache.amount0,
 340 |     |             cache.amount1,
 341 |     |             cache.tickLower,
 342 |     |             cache.tickUpper
 343 |     |         );
 344 |     | 
 345 |     |         // //Get imbalanced token
 346 |     |         bool zeroGreaterOne = amountsDirection(
 347 |     |             cache.amount0Desired,
 348 |     |             cache.amount1Desired,
 349 |     |             cache.amount0,
 350 |     |             cache.amount1
 351 |     |         );
 352 |     | 
 353 |     |         //Calc new tick(upper or lower) for imbalanced token
 354 |     |         if (zeroGreaterOne) {
 355 |     |             uint160 nextSqrtPrice0 = SqrtPriceMath
 356 |     |                 .getNextSqrtPriceFromAmount0RoundingUp(
 357 |     |                     sqrtPriceX96,
 358 |     |                     cache.liquidity,
 359 |     |                     cache.amount0Desired,
 360 |     |                     false
 361 |     |                 );
 362 |     |             cache.tickUpper = floor(
 363 |     |                 TickMath.getTickAtSqrtRatio(nextSqrtPrice0),
 364 |     |                 tickSpacing
 365 |     |             );
 366 |     |         } else {
 367 |     |             uint160 nextSqrtPrice1 = SqrtPriceMath
 368 |     |                 .getNextSqrtPriceFromAmount1RoundingDown(
 369 |     |                     sqrtPriceX96,
 370 |     |                     cache.liquidity,
 371 |     |                     cache.amount1Desired,
 372 |     |                     false
 373 |     |                 );
 374 |     |             cache.tickLower = floor(
 375 |     |                 TickMath.getTickAtSqrtRatio(nextSqrtPrice1),
 376 |     |                 tickSpacing
 377 |     |             );
 378 |     |         }
 379 |     | 
 380 |     |         checkRange(cache.tickLower, cache.tickUpper, tickSpacing);
 381 |     | 
 382 |     |         /// floor the tick again because one tick is still not valid tick due to + - baseThreshold
 383 |     |         tickLower = floor(cache.tickLower, tickSpacing);
 384 |     |         tickUpper = floor(cache.tickUpper, tickSpacing);
 385 |     |     }
 386 |     | 
 387 |     |     /// @dev Gets amounts of token0 and token1 that can be stored in range of upper and lower ticks
 388 |     |     /// @param pool Uniswap V3 pool
 389 |     |     /// @param amount0Desired The desired amount of token0
 390 |     |     /// @param amount1Desired The desired amount of token1
 391 |     |     /// @param _tickLower The lower tick of the range
 392 |     |     /// @param _tickUpper The upper tick of the range
 393 |     |     /// @return amount0 amounts of token0 that can be stored in range
 394 |     |     /// @return amount1 amounts of token1 that can be stored in range
 395 |     |     function getAmountsForTicks(
 396 |     |         IUniswapV3Pool pool,
 397 |     |         uint256 amount0Desired,
 398 |     |         uint256 amount1Desired,
 399 |     |         int24 _tickLower,
 400 |     |         int24 _tickUpper
 401 |     |     ) internal view returns (uint256 amount0, uint256 amount1) {
 402 |     |         uint128 liquidity = getLiquidityForAmounts(
 403 |     |             pool,
 404 |     |             amount0Desired,
 405 |     |             amount1Desired,
 406 |     |             _tickLower,
 407 |     |             _tickUpper
 408 |     |         );
 409 |     | 
 410 |     |         (amount0, amount1) = getAmountsForLiquidity(
 411 |     |             pool,
 412 |     |             liquidity,
 413 |     |             _tickLower,
 414 |     |             _tickUpper
 415 |     |         );
 416 |     |     }
 417 |     | 
 418 |     |     /// @dev Common checks for valid tick inputs.
 419 |     |     /// @param tickLower The lower tick of the range
 420 |     |     /// @param tickUpper The upper tick of the range
 421 |     |     /// @param tickSpacing The pool tick spacing
 422 |     |     function checkRange(
 423 |     |         int24 tickLower,
 424 |     |         int24 tickUpper,
 425 |     |         int24 tickSpacing
 426 |     |     ) internal pure {
 427 |     |         require(tickLower < tickUpper, "TLU");
 428 |     |         require(tickLower >= TickMath.MIN_TICK, "TLM");
 429 |     |         require(tickUpper <= TickMath.MAX_TICK, "TUM");
 430 |     |         require(tickLower % tickSpacing == 0, "TLI");
 431 |     |         require(tickUpper % tickSpacing == 0, "TUI");
 432 |     |     }
 433 |     | 
 434 |     |     /// @dev Get imbalanced token
 435 |     |     /// @param amount0Desired The desired amount of token0
 436 |     |     /// @param amount1Desired The desired amount of token1
 437 |     |     /// @param amount0 Amounts of token0 that can be stored in base range
 438 |     |     /// @param amount1 Amounts of token1 that can be stored in base range
 439 |     |     /// @return zeroGreaterOne true if token0 is imbalanced. False if token1 is imbalanced
 440 |     |     function amountsDirection(
 441 |     |         uint256 amount0Desired,
 442 |     |         uint256 amount1Desired,
 443 |     |         uint256 amount0,
 444 |     |         uint256 amount1
 445 |     |     ) internal pure returns (bool zeroGreaterOne) {
 446 |     |         zeroGreaterOne = amount0Desired.sub(amount0).mul(amount1Desired) >
 447 |     |             amount1Desired.sub(amount1).mul(amount0Desired)
 448 |     |             ? true
 449 |     |             : false;
 450 |     |     }
 451 |     | }
 452 |     | 

/Users/kaifahmed/Downloads/WORK/Fuzzing/unipilot-v2-bug-fixes/contracts/libraries/UniswapPoolActions.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | import "./SafeCastExtended.sol";
   5 |     | import "./UniswapLiquidityManagement.sol";
   6 |     | 
   7 |     | import "../dependencies/interfaces/IUniswapV3Pool.sol";
   8 |     | import "../dependencies/libraries/FullMath.sol";
   9 |     | import "../dependencies/libraries/LowGasSafeMath.sol";
  10 |     | 
  11 |     | /// @title Liquidity and ticks functions
  12 |     | /// @notice Provides functions for computing liquidity and ticks for token amounts and prices
  13 |     | library UniswapPoolActions {
  14 |     |     using LowGasSafeMath for uint256;
  15 |     |     using SafeCastExtended for uint256;
  16 |     |     using UniswapLiquidityManagement for IUniswapV3Pool;
  17 |     | 
  18 |     |     function updatePosition(
  19 |     |         IUniswapV3Pool pool,
  20 |     |         int24 tickLower,
  21 |     |         int24 tickUpper
  22 |     |     ) internal returns (uint128 liquidity) {
  23 |     |         (liquidity, , ) = pool.getPositionLiquidity(tickLower, tickUpper);
  24 |     | 
  25 |     |         if (liquidity > 0) {
  26 |     |             pool.burn(tickLower, tickUpper, 0);
  27 |     |         }
  28 |     |     }
  29 |     | 
  30 |     |     function burnLiquidity(
  31 |     |         IUniswapV3Pool pool,
  32 |     |         int24 tickLower,
  33 |     |         int24 tickUpper,
  34 |     |         address recipient
  35 |     |     )
  36 |     |         internal
  37 |     |         returns (
  38 |     |             uint256 amount0,
  39 |     |             uint256 amount1,
  40 |     |             uint256 fees0,
  41 |     |             uint256 fees1
  42 |     |         )
  43 |     |     {
  44 |     |         (uint128 liquidity, , ) = pool.getPositionLiquidity(
  45 |     |             tickLower,
  46 |     |             tickUpper
  47 |     |         );
  48 |     |         if (liquidity > 0) {
  49 |     |             (amount0, amount1) = pool.burn(tickLower, tickUpper, liquidity);
  50 |     |             if (amount0 > 0 || amount1 > 0) {
  51 |     |                 (uint256 collect0, uint256 collect1) = pool.collect(
  52 |     |                     recipient,
  53 |     |                     tickLower,
  54 |     |                     tickUpper,
  55 |     |                     type(uint128).max,
  56 |     |                     type(uint128).max
  57 |     |                 );
  58 |     | 
  59 |     |                 (fees0, fees1) = (collect0.sub(amount0), collect1.sub(amount1));
  60 |     |             }
  61 |     |         }
  62 |     |     }
  63 |     | 
  64 |     |     function burnUserLiquidity(
  65 |     |         IUniswapV3Pool pool,
  66 |     |         int24 tickLower,
  67 |     |         int24 tickUpper,
  68 |     |         uint256 userSharePercentage,
  69 |     |         address recipient
  70 |     |     ) internal returns (uint256 amount0, uint256 amount1) {
  71 |     |         (uint128 liquidity, , ) = pool.getPositionLiquidity(
  72 |     |             tickLower,
  73 |     |             tickUpper
  74 |     |         );
  75 |     | 
  76 |     |         uint256 liquidityRemoved = FullMath.mulDiv(
  77 |     |             uint256(liquidity),
  78 |     |             userSharePercentage,
  79 |     |             1e18
  80 |     |         );
  81 |     | 
  82 |     |         (amount0, amount1) = pool.burn(
  83 |     |             tickLower,
  84 |     |             tickUpper,
  85 |     |             liquidityRemoved.toUint128()
  86 |     |         );
  87 |     | 
  88 |     |         if (amount0 > 0 || amount1 > 0) {
  89 |     |             (amount0, amount0) = pool.collect(
  90 |     |                 recipient,
  91 |     |                 tickLower,
  92 |     |                 tickUpper,
  93 |     |                 amount0.toUint128(),
  94 |     |                 amount1.toUint128()
  95 |     |             );
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     function mintLiquidity(
 100 |     |         IUniswapV3Pool pool,
 101 |     |         int24 tickLower,
 102 |     |         int24 tickUpper,
 103 |     |         uint256 amount0Desired,
 104 |     |         uint256 amount1Desired
 105 |     |     ) internal returns (uint256 amount0, uint256 amount1) {
 106 |     |         uint128 liquidity = pool.getLiquidityForAmounts(
 107 |     |             amount0Desired,
 108 |     |             amount1Desired,
 109 |     |             tickLower,
 110 |     |             tickUpper
 111 |     |         );
 112 |     | 
 113 |     |         if (liquidity > 0) {
 114 |     |             (amount0, amount1) = pool.mint(
 115 |     |                 address(this),
 116 |     |                 tickLower,
 117 |     |                 tickUpper,
 118 |     |                 liquidity,
 119 |     |                 abi.encode(address(this))
 120 |     |             );
 121 |     |         }
 122 |     |     }
 123 |     | 
 124 |     |     function swapToken(
 125 |     |         IUniswapV3Pool pool,
 126 |     |         address recipient,
 127 |     |         bool zeroForOne,
 128 |     |         int256 amountSpecified
 129 |     |     ) internal {
 130 |     |         (uint160 sqrtPriceX96, , ) = pool.getSqrtRatioX96AndTick();
 131 |     | 
 132 |     |         uint160 exactSqrtPriceImpact = (sqrtPriceX96 * (1e5 / 2)) / 1e6;
 133 |     | 
 134 |     |         uint160 sqrtPriceLimitX96 = zeroForOne
 135 |     |             ? sqrtPriceX96 - exactSqrtPriceImpact
 136 |     |             : sqrtPriceX96 + exactSqrtPriceImpact;
 137 |     | 
 138 |     |         pool.swap(
 139 |     |             recipient,
 140 |     |             zeroForOne,
 141 |     |             amountSpecified,
 142 |     |             sqrtPriceLimitX96,
 143 |     |             abi.encode(zeroForOne)
 144 |     |         );
 145 |     |     }
 146 |     | 
 147 |     |     function collectPendingFees(
 148 |     |         IUniswapV3Pool pool,
 149 |     |         address recipient,
 150 |     |         int24 tickLower,
 151 |     |         int24 tickUpper
 152 |     |     ) internal returns (uint256 collect0, uint256 collect1) {
 153 |     |         updatePosition(pool, tickLower, tickUpper);
 154 |     | 
 155 |     |         (collect0, collect1) = pool.collect(
 156 |     |             recipient,
 157 |     |             tickLower,
 158 |     |             tickUpper,
 159 |     |             type(uint128).max,
 160 |     |             type(uint128).max
 161 |     |         );
 162 |     |     }
 163 |     | 
 164 |     |     function rerangeLiquidity(
 165 |     |         IUniswapV3Pool pool,
 166 |     |         int24 baseThreshold,
 167 |     |         int24 tickSpacing,
 168 |     |         uint256 balance0,
 169 |     |         uint256 balance1
 170 |     |     ) internal returns (int24 tickLower, int24 tickUpper) {
 171 |     |         (tickLower, tickUpper) = pool.getPositionTicks(
 172 |     |             balance0,
 173 |     |             balance1,
 174 |     |             baseThreshold,
 175 |     |             tickSpacing
 176 |     |         );
 177 |     | 
 178 |     |         mintLiquidity(pool, tickLower, tickUpper, balance0, balance1);
 179 |     |     }
 180 |     | }
 181 |     | 

